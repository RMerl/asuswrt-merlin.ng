<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>json-c: json_object_iterator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">json-c
   &#160;<span id="projectnumber">0.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">json_object_iterator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>json-c forces clients to use its private data structures for JSON Object iteration. This API corrects that by abstracting the private json-c details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjson__object__iterator.html">json_object_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af30f56ca510d59da42e5592f9a436c10"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a> (void)</td></tr>
<tr class="separator:af30f56ca510d59da42e5592f9a436c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925eb97b5aa5b64986a0f663f53cf0fa"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a925eb97b5aa5b64986a0f663f53cf0fa">json_object_iter_begin</a> (struct <a class="el" href="structjson__object.html">json_object</a> *obj)</td></tr>
<tr class="separator:a925eb97b5aa5b64986a0f663f53cf0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa3784395fb14496e3f1a1633028fd4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end</a> (const struct <a class="el" href="structjson__object.html">json_object</a> *obj)</td></tr>
<tr class="separator:a1fa3784395fb14496e3f1a1633028fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98a310c340f6d9b4eeecb673aa5e240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#aa98a310c340f6d9b4eeecb673aa5e240">json_object_iter_next</a> (struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr class="separator:aa98a310c340f6d9b4eeecb673aa5e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17775b9b812a4206a84e4d3fb5774ab"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#af17775b9b812a4206a84e4d3fb5774ab">json_object_iter_peek_name</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr class="separator:af17775b9b812a4206a84e4d3fb5774ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b0af7f1722c10475dffd29efc0b89d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object.html">json_object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a47b0af7f1722c10475dffd29efc0b89d">json_object_iter_peek_value</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr class="separator:a47b0af7f1722c10475dffd29efc0b89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ca25f72b339882aa2607ac938e79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json__object_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a878ca25f72b339882aa2607ac938e79c">json_object_iter_equal</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter1, const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter2)</td></tr>
<tr class="separator:a878ca25f72b339882aa2607ac938e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>json-c forces clients to use its private data structures for JSON Object iteration. This API corrects that by abstracting the private json-c details. </p>
<p>Copyright (c) 2009-2012 Hewlett-Packard Development Company, L.P.</p>
<p>This library is free software; you can redistribute it and/or modify it under the terms of the MIT license. See COPYING for details.</p>
<p>API attributes: <br/>
</p>
<ul>
<li>Thread-safe: NO<br/>
</li>
<li>Reentrant: NO </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a925eb97b5aa5b64986a0f663f53cf0fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_begin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structjson__object.html">json_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves an iterator to the first pair of the JSON Object.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any modification of the underlying pair invalidates all iterators to that pair.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>JSON Object instance (MUST be of type <a class="el" href="structjson__object.html">json_object</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> If the JSON Object has at least one pair, on return, the iterator refers to the first pair. If the JSON Object doesn't have any pairs, the returned iterator is equivalent to the "end" iterator for the same JSON Object instance.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> it;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> itEnd;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structjson__object.html">json_object</a>* obj;</div>
<div class="line"></div>
<div class="line">obj = <a class="code" href="json__tokener_8h.html#abf031fdf1e5caab71e2225a99588c6bb">json_tokener_parse</a>(<span class="stringliteral">&quot;{&#39;first&#39;:&#39;george&#39;, &#39;age&#39;:100}&quot;</span>);</div>
<div class="line">it = <a class="code" href="json__object__iterator_8h.html#a925eb97b5aa5b64986a0f663f53cf0fa">json_object_iter_begin</a>(obj);</div>
<div class="line">itEnd = <a class="code" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end</a>(obj);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code" href="json__object__iterator_8h.html#a878ca25f72b339882aa2607ac938e79c">json_object_iter_equal</a>(&amp;it, &amp;itEnd)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>,</div>
<div class="line">           <a class="code" href="json__object__iterator_8h.html#af17775b9b812a4206a84e4d3fb5774ab">json_object_iter_peek_name</a>(&amp;it));</div>
<div class="line">    <a class="code" href="json__object__iterator_8h.html#aa98a310c340f6d9b4eeecb673aa5e240">json_object_iter_next</a>(&amp;it);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1fa3784395fb14496e3f1a1633028fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_end </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object.html">json_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the iterator that represents the position beyond the last pair of the given JSON Object instance.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do NOT write code that assumes that the "end" iterator value is NULL, even if it is so in a particular instance of the implementation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reason we do not (and MUST NOT) provide "json_object_iter_is_end(json_object_iterator* iter)" type of API is because it would limit the underlying representation of name/value containment (or force us to add additional, otherwise unnecessary, fields to the iterator structure). The "end" iterator and the equality test method, on the other hand, permit us to cleanly abstract pretty much any reasonable underlying representation without burdening the iterator structure with unnecessary data.</dd>
<dd>
For performance reasons, memorize the "end" iterator prior to any loop.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>JSON Object instance (MUST be of type <a class="el" href="structjson__object.html">json_object</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> On return, the iterator refers to the "end" of the Object instance's pairs (i.e., NOT the last pair, but "beyond the last
             pair" value) </dd></dl>

</div>
</div>
<a class="anchor" id="a878ca25f72b339882aa2607ac938e79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json__object_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a> json_object_iter_equal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests two iterators for equality. Typically used to test for end of iteration by comparing an iterator to the corresponding "end" iterator (that was derived from the same JSON Object instance).</p>
<dl class="section note"><dt>Note</dt><dd>The reason we do not (and MUST NOT) provide "json_object_iter_is_end(json_object_iterator* iter)" type of API is because it would limit the underlying representation of name/value containment (or force us to add additional, otherwise unnecessary, fields to the iterator structure). The equality test method, on the other hand, permits us to cleanly abstract pretty much any reasonable underlying representation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter1</td><td>Pointer to first valid, non-NULL iterator </td></tr>
    <tr><td class="paramname">iter2</td><td>POinter to second valid, non-NULL iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>if a NULL iterator pointer or an uninitialized or invalid iterator, or iterators derived from different JSON Object instances are passed, bad things will happen!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>json_bool non-zero if iterators are equal (i.e., both reference the same name/value pair or are both at "end"); zero if they are not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="af30f56ca510d59da42e5592f9a436c10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_init_default </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes an iterator structure to a "default" value that is convenient for initializing an iterator variable to a default state (e.g., initialization list in a class' constructor).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> iter = <a class="code" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a>();</div>
<div class="line">MyClass() : iter_(<a class="code" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a>())</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The initialized value doesn't reference any specific pair, is considered an invalid iterator, and MUST NOT be passed to any json-c API that expects a valid iterator.</dd>
<dd>
User and internal code MUST NOT make any assumptions about and dependencies on the value of the "default" iterator value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa98a310c340f6d9b4eeecb673aa5e240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void json_object_iter_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the next pair, if any</p>
<dl class="section warning"><dt>Warning</dt><dd>Any modification of the underlying pair invalidates all iterators to that pair.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>[IN/OUT] Pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator. WARNING: bad things will happen if invalid or "end" iterator is passed. Upon return will contain the reference to the next pair if there is one; if there are no more pairs, will contain the "end" iterator value, which may be compared against the return value of <a class="el" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end()</a> for the same JSON Object instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af17775b9b812a4206a84e4d3fb5774ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* json_object_iter_peek_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const pointer to the name of the pair referenced by the given iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>bad things will happen if an invalid or "end" iterator is passed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Pointer to the name of the referenced name/value pair. The name memory belongs to the name/value pair, will be freed when the pair is deleted or modified, and MUST NOT be modified or freed by the user. </dd></dl>

</div>
</div>
<a class="anchor" id="a47b0af7f1722c10475dffd29efc0b89d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object.html">json_object</a>* json_object_iter_peek_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the json-c instance representing the value of the referenced name/value pair, without altering the instance's reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>bad things will happen if invalid or "end" iterator is passed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>struct json_object* Pointer to the json-c value instance of the referenced name/value pair; the value's reference count is not changed by this function: if you plan to hold on to this json-c node, take a look at <a class="el" href="json__object_8h.html#acc3628d97c6308dc967006e4268c4e7f">json_object_get()</a> and <a class="el" href="json__object_8h.html#a1bb50e2d17832c404c3d5f13fbde5bf5">json_object_put()</a>. IMPORTANT: json-c API represents the JSON Null value as a NULL <a class="el" href="structjson__object.html">json_object</a> instance pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 31 2013 05:40:33 for json-c by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
