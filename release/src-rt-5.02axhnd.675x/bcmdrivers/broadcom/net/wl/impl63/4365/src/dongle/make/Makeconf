
#
# RTE Common Dongle Configuration
#
# This is shared between ROM and RAM builds.
#
# Copyright 2020 Broadcom
#
# This program is the proprietary software of Broadcom and/or
# its licensors, and may only be used, duplicated, modified or distributed
# pursuant to the terms and conditions of a separate, written license
# agreement executed between you and Broadcom (an "Authorized License").
# Except as set forth in an Authorized License, Broadcom grants no license
# (express or implied), right to use, or waiver of any kind with respect to
# the Software, and Broadcom expressly reserves all rights in and to the
# Software and all intellectual property rights therein.  IF YOU HAVE NO
# AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
# WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
# THE SOFTWARE.
#
# Except as expressly set forth in the Authorized License,
#
# 1. This program, including its structure, sequence and organization,
# constitutes the valuable trade secrets of Broadcom, and you shall use
# all reasonable efforts to protect the confidentiality thereof, and to
# use this information only in connection with your use of Broadcom
# integrated circuit products.
#
# 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
# "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR
# OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
#
# 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL,
# SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR
# IN ANY WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
# IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii)
# ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF
# OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY
# NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
#
# $Id: Makeconf 778298 2019-08-29 00:43:36Z $
#

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++ global default configurations +++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

EXTRA_DFLAGS += -DRXDMA_STUCK_WAR

#ifdef UNRELEASEDCHIP
# include things under UNRELEASEDCHIP conditional (for local built targets only)
# removed by mogrifier
EXTRA_DFLAGS += -DUNRELEASEDCHIP
#endif // endif

# Enable FLOWRING LAZY FETCH to get better throughput for multiple clients test
EXTRA_DFLAGS += -DFLOW_RING_LAZY_FETCH

# Enable ATF WAR for MU
EXTRA_DFLAGS += -DWL_ATF_MU

# Define RAM MEMBASE/SIZE for all ROM-offload and RAM "chip brand" builds.
ifneq ($(filter %-roml %-ram,$(CBRAND)),)
   ifneq ($(MEMBASE),)
      EXTRA_DFLAGS    += -DRAMBASE=$(MEMBASE)
   else
      $(error "MEMBASE not defined!")
   endif

   ifneq ($(MEMSIZE),)
      EXTRA_DFLAGS    += -DRAMSIZE=$(MEMSIZE)
   else
      $(error "MEMSIZE not defined!")
   endif
endif

# distinguish between boot loader and dongle build
ifeq ($(BOOTLOADER),1)
EXTRA_DFLAGS += -DBCM_BOOTLOADER
else
FULLDNGLBLD ?= 1
BCMHOSTVARS ?= 1
endif

# XXX need a better distinction between a dongle build with host bus (sdio/usb...) and
# a dongle build without (aka wl only).
ifeq ($(FULLDNGLBLD),1)
EXTRA_DFLAGS += -DDONGLEBUILD
ifeq ($(TARGET_ARCH),mips)
BCMHOSTVARS := 0
endif
endif	# FULLDNGLBLD

# support host-supplied nvram variables
ifeq ($(BCMHOSTVARS),1)
EXTRA_DFLAGS += -DBCMHOSTVARS
endif

# dongle does not need a delay before MPC starts
EXTRA_DFLAGS += -DWLC_MPC_MAX_DELAYCNT=1

# size optimization to exclude code except for one specific chip
ifneq ($(CHIP),UNKNOWN)
EXTRA_DFLAGS += $(CHIP:%=-DBCMCHIPID=BCM%_CHIP_ID)
endif

ifneq ($(REVID),)
# size optimization to exclude code except for one specific chip rev (especially for ROMmed code)
EXTRA_DFLAGS += -DBCMCHIPREV=$(REVID)
endif

ifneq ($(PCIEREVID),)
# size optimization to exclude code except for one specific chip rev (especially for ROMmed code)
EXTRA_DFLAGS += -DBCMPCIEREV=$(PCIEREVID)
endif

# Define BCM43xx and BCM43xxrx - for ROM patch emergency use only (do not abuse in regular code!)
ifneq ($(CHIP),)
EXTRA_DFLAGS += -DBCM$(CHIP)
ifneq ($(REV),)
EXTRA_DFLAGS += -D$(shell echo BCM$(CHIP)$(REV) | tr a-z A-Z)
endif
endif

# Include only HND OTP for 4320; include only IPX OTP for all others
ifeq ($(CHIP),4320)
EXTRA_DFLAGS += -DBCMHNDOTP
else
EXTRA_DFLAGS += -DBCMIPXOTP
endif

# build small dongle images
SMALL ?= 1
# support serial console
CONSOLE ?= 1
ifeq ($(call opt,ate),1)
UART ?= 0
ECICOEX ?= 0
else
UART ?= 1
endif
# support flash memory access and nvram variables read in flash
FLASH ?= 0
# support nvram variables read in SPROM/OTP
NVRAM ?= 1
# support trace messages (sent over HBUS)
MSGTRACE ?= 0
# number of rx buffers to post for pktpool feature
ifeq ($(CHIP),4325)
BUS_POST ?= 12
else
BUS_POST ?= 6
endif

# default RTE to hndrte
THREADX ?= 0
HNDRTE ?= 1

ifeq ($(THREADX),$(HNDRTE))
$(error Either THREADX or HNDRTE needs to be 1)
endif

# size of shared pool for pktpool feature
POOL_LEN ?= 24
POOL_LEN_MAX ?= 40

#SDTEST pktgen code in dongle
SDTEST	?= 1
TRX_FLAGS ?= 0x0020
TCAM ?= 0
# Default TCAM patch count
TCAM_PCNT ?= 0
# Default TCAM entries
TCAM_SIZE ?= 64

# No Minroml build by default
MINROML_BUILD ?= 0

#AMPDU rx packets host reorder
AMPDU_HOSTREORDER ?= 0

# pktpool
BCMPKTPOOL ?= 1
# size of shared pool
POOL_LEN ?= 24
POOL_LEN_MAX ?= 40

# specify common source files search paths
vpath %.S $(SRCBASE)/shared
vpath %.lds.in $(SRCBASE)/shared

DMATXRC ?= 1

WLMCNX_DISABLED ?= 1

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++ mandatory attributes +++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ifneq ($(findstring usb,$(TARGET_HBUS)),)
	vpath %.c $(SRCBASE)/usbdev/dongle $(SRCBASE)/usbdev/dongle/usb30d
	USBBULK_RXBUFS ?= 4
        USBBULK_RXBUF_GIANT ?= 0
	USBCTL_RXBUFS ?= 4
	USB_NRXD ?= 16
	USB_NTXD ?= 16
	USB_RXBND ?= 4
	USB_TXQ_DATAHIWAT ?= 2
	USB_TXQ_DATALOWAT ?= 1
# Specify the Bootloader PID to be used by the post boot image
	BCM_DNGL_BL_PID ?= 0xbdc
	HBUS_OBJECTS += usbdev_rte.o usbdev_sb.o usbdev_cdc.o
	HBUS_OBJECTS += xdc_rte.o xdc_cmd.o xdc_core.o xdc_dbg.o xdc_ep.o xdc_mem.o xdc_ring.o
	EXTRA_IFLAGS += -I$(SRCBASE)/usbdev/dongle
	EXTRA_DFLAGS += -DBCMUSBDEV
	EXTRA_DFLAGS += -DUSBBULK_RXBUFS=$(USBBULK_RXBUFS) -DUSBCTL_RXBUFS=$(USBCTL_RXBUFS)
	EXTRA_DFLAGS += -DUSB_NRXD=$(USB_NRXD) -DUSB_NTXD=$(USB_NTXD)
	EXTRA_DFLAGS += -DUSB_RXBND=$(USB_RXBND)
	EXTRA_DFLAGS += -DUSB_TXQ_DATAHIWAT=$(USB_TXQ_DATAHIWAT)
	EXTRA_DFLAGS += -DUSB_TXQ_DATALOWAT=$(USB_TXQ_DATALOWAT)
	CRC32BIN ?= 1
	ifeq ($(CRC32BIN),1)
		EXTRA_DFLAGS += -DRTE_CRC32_BIN
	endif
endif	# usb
# pcie full dongle
ifneq ($(findstring pcie,$(TARGET_HBUS)),)
	vpath %.c $(SRCBASE)/pciedev

	PCIE_H2D_NTXD ?= 256
        PCIE_H2D_NRXD ?= 256
        PCIE_D2H_NTXD ?= 256
        PCIE_D2H_NRXD ?= 256

	H2D_DMAQ_LEN ?= 256
	D2H_DMAQ_LEN ?= 256
	HBUS_OBJECTS += circularbuf.o pciedev_rte.o pciedev.o pciedev_data.o
	HBUS_OBJECTS += pcie_core.o
	EXTRA_IFLAGS += -I$(SRCBASE)/pciedev
	EXTRA_DFLAGS += -DBCMPCIEDEV
	EXTRA_DFLAGS += -DPD_H2D_NTXD=$(PCIE_H2D_NTXD) -DPD_H2D_NRXD=$(PCIE_H2D_NRXD)
        EXTRA_DFLAGS += -DPD_D2H_NTXD=$(PCIE_D2H_NTXD) -DPD_D2H_NRXD=$(PCIE_D2H_NRXD)

	EXTRA_DFLAGS += -DMAX_DMA_QUEUE_LEN_H2D=$(H2D_DMAQ_LEN) -DMAX_DMA_QUEUE_LEN_D2H=$(D2H_DMAQ_LEN)
	CRC32BIN ?= 1
	ifeq ($(PCIE_PHANTOM),1)
		HBUS_OBJECTS += pcie_phtm.o
		EXTRA_DFLAGS += -DPCIE_PHANTOM_DEV
	endif
	ifneq ($(PCIE_TXFLOWS),)
		EXTRA_DFLAGS += -DBCMPCIE_MAX_TX_FLOWS=$(PCIE_TXFLOWS)
	endif
	ifeq ($(CRC32BIN),1)
		EXTRA_DFLAGS += -DRTE_CRC32_BIN
	endif
	ifneq ($(PCIEDEV_MAX_LOCALBUF_COUNT),)
		EXTRA_DFLAGS    += -DPCIEDEV_MAX_LOCALBUF_COUNT=$(PCIEDEV_MAX_LOCALBUF_COUNT)
	endif
	ifneq ($(PCIEDEV_MAX_LOCALITEM_COUNT),)
		EXTRA_DFLAGS    += -DPCIEDEV_MAX_LOCALITEM_COUNT=$(PCIEDEV_MAX_LOCALITEM_COUNT)
	endif
	ifneq ($(PCIEDEV_MAX_PACKETFETCH_COUNT),)
		EXTRA_DFLAGS    += -DPCIEDEV_MAX_PACKETFETCH_COUNT=$(PCIEDEV_MAX_PACKETFETCH_COUNT)
	endif

	ifneq ($(NAR_MAX_TRANSIT_PACKETS),)
		EXTRA_DFLAGS    += -DNAR_MAX_TRANSIT_PACKETS=$(NAR_MAX_TRANSIT_PACKETS)
	endif

	ifeq ($(BCM_BUZZZ),1)
		HBUS_OBJECTS += bcm_buzzz.o
		EXTRA_DFLAGS += -DBCM_BUZZZ
	endif
		ifeq ($(IOCTL_RESP_LARGE),1)
			ifneq ($(PCIEDEV_MAX_IOCTLRSP_BUF_SIZE),)
				EXTRA_DFLAGS    += -DPCIEDEV_USE_EXT_BUF_FOR_IOCTL
				EXTRA_DFLAGS    += -DPCIEDEV_MAX_IOCTLRSP_BUF_SIZE=$(PCIEDEV_MAX_IOCTLRSP_BUF_SIZE)
			endif
		endif
	ifeq ($(MFGTEST),1)
	EXTRA_DFLAGS += -DPCIE_DELAYED_HOSTWAKE
	endif
endif	# pcie

ifneq ($(findstring sdio,$(TARGET_HBUS)),)
	vpath %.c $(SRCBASE)/sdpcmdev
	BUS_NRXD ?= 32
	BUS_NTXD ?= 64
	BUS_RXBND ?= 10
	SDPCMD_RXBUFS ?= $(BUS_POST)
	SDPCMD_NRXD		?= $(BUS_NRXD)
	SDPCMD_NTXD		?= $(BUS_NTXD)
	SDPCMD_RXBND	?= $(BUS_RXBND)
	SDPCMD_READAHEAD ?= TRUE
	SDPCMD_TXGLOM ?= 7
	HBUS_OBJECTS += sdpcmdev_rte.o sdpcmdev.o
	EXTRA_IFLAGS += -I$(SRCBASE)/sdpcmdev
	EXTRA_DFLAGS += -DBCMSDIODEV
	ifeq ($(SDTEST),1)
		EXTRA_DFLAGS += -DSDTEST
	endif
	EXTRA_DFLAGS += -DSDPCMD_RXBUFS=$(SDPCMD_RXBUFS) -DSDPCMD_READAHEAD=$(SDPCMD_READAHEAD) -DSDPCMD_TXGLOM=$(SDPCMD_TXGLOM)
	EXTRA_DFLAGS += -DSDPCMD_NRXD=$(SDPCMD_NRXD) -DSDPCMD_NTXD=$(SDPCMD_NTXD)
	EXTRA_DFLAGS += -DSDPCMD_RXBND=$(SDPCMD_RXBND)
	CRC32BIN ?= 1
	ifeq ($(CRC32BIN),1)
		EXTRA_DFLAGS += -DRTE_CRC32_BIN
	endif
endif	# sdio

ifneq ($(findstring m2m,$(TARGET_HBUS)),)
	vpath %.c $(SRCBASE)/m2mdev
	BUS_NRXD ?= 32
	BUS_NTXD ?= 64
	BUS_RXBND ?= 10
	M2M_RXBUFS ?= $(BUS_POST)
	M2M_NRXD		?= $(BUS_NRXD)
	M2M_NTXD		?= $(BUS_NTXD)
	M2M_RXBND	?= $(BUS_RXBND)
	M2M_READAHEAD ?= TRUE
	M2M_TXGLOM ?= 7
	ifeq ($(HBUS_PROTO),msgbuf)
		HBUS_OBJECTS += circularbuf.o m2mdev_msgbuf_rte.o m2mdev_msgbuf.o
	else
		HBUS_OBJECTS += m2mdev_sdpcm_rte.o m2mdev_sdpcm.o
	endif
	EXTRA_DFLAGS += -I$(SRCBASE)/m2mdev
	EXTRA_DFLAGS += -DBCMM2MDEV
	ifeq ($(SDTEST),1)
		EXTRA_DFLAGS += -DSDTEST
	endif
	EXTRA_DFLAGS += -DM2M_RXBUFS=$(M2M_RXBUFS) -DM2M_READAHEAD=$(M2M_READAHEAD) -DM2M_TXGLOM=$(M2M_TXGLOM)
	EXTRA_DFLAGS += -DM2M_NRXD=$(M2M_NRXD) -DM2M_NTXD=$(M2M_NTXD)
	EXTRA_DFLAGS += -DM2M_RXBND=$(M2M_RXBND)
	CRC32BIN ?= 1
	ifeq ($(CRC32BIN),1)
		EXTRA_DFLAGS += -DRTE_CRC32_BIN
	endif
endif	# m2m

ifneq ($(findstring pciol,$(TARGET_HBUS)),)
	vpath %.c $(SRCBASE)/pciedev
	HBUS_OBJECTS += pciedev_msg.o
	EXTRA_DFLAGS += -DBCM_OL_DEV
	EXTRA_IFLAGS += -I$(SRCBASE)/pciedev
endif	# pci

ifeq ($(TARGET_ARCH),mips)
	BOOT_OBJECTS ?= boot.o trap.o sisdram.o sbsdram.o aisdram.o
	RUN_OBJECTS ?= head.o trap.o
	ARCH_OBJECTS ?= hndmips.o
	RTOS_OBJECTS ?= hndrte_mips.o
	TARGET_CPU := mips
ifeq ($(CHIP),4320)
	EXTRA_DFLAGS += -DBCMPMUCTL=0
endif
endif

ifeq ($(TARGET_ARCH),arm)
	BOOT_OBJECTS ?= bootarm.o
	RUN_OBJECTS ?= headarm.o
	ARCH_OBJECTS ?= hndarm.o
	RTOS_OBJECTS ?= rte_arm.o
	TARGET_CPU ?= 7s
	EXTRA_DFLAGS += -DBCMPMUCTL=1

	ifeq ($(TARGET_CPU),cm3)
		THUMB := 1
	endif
	ifeq ($(TARGET_CPU),cr4)
		ifneq ($(BOOTLOADER),1)
			FIQMODE ?= 1
			FIQ_USE_COMMON_TRAP_HDLR ?= 0
		endif
		THUMB := 1
	endif
	ifeq ($(TARGET_CPU),ca7)
		ifneq ($(BOOTLOADER),1)
			FIQMODE ?= 1
			FIQ_USE_COMMON_TRAP_HDLR ?= 0
		endif
		THUMB := 1
	endif
endif

# Host BUS protocol
ifeq ($(findstring rndis,$(HBUS_PROTO)), rndis)
	PROJECT := rterndis
	PROTO_OBJECTS += dngl_rte.o rndis.o
	EXTRA_DFLAGS += -DRNDIS
	NDIS := 1
endif
ifeq ($(findstring cdc,$(HBUS_PROTO)), cdc)
	PROJECT := rtecdc
	PROTO_OBJECTS += dngl_rte.o bcmcdc.o
	EXTRA_DFLAGS += -DBCMCDC
endif
ifeq ($(findstring msgbuf,$(HBUS_PROTO)), msgbuf)
	PROJECT := rtecdc
	PROTO_OBJECTS += dngl_rte.o bcmmsgbuf.o
	EXTRA_DFLAGS += -DBCMMSGBUF
endif
PROTO_OBJECTS := $(sort $(PROTO_OBJECTS))

STRING_HBUSPROTO := $(findstring rndis,$(HBUS_PROTO))+$(findstring cdc,$(HBUS_PROTO))+$(findstring msgbuf,$(HBUS_PROTO))

#Multiple HBUS_PROTO is not allowed in case of ROML
ifneq ($(GENROMTBL),1)
	ifeq ($(filter $(STRING_HBUSPROTO),rndis++ +cdc+ ++msgbuf ++),)
$(error Multiple buses are enabled $(STRING_HBUSPROTO))
	endif
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++ optional attributes ++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#LFRAG
ifeq ($(BCMLFRAG),1)
	EXTRA_DFLAGS += -DBCMLFRAG

	ifeq ($(BCMLFRAG_DISABLED),1)
		EXTRA_DFLAGS += -DBCMLFRAG_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMLFRAG_DISABLED
	endif
endif # BCMLFRAG
# NRXD & NTXD from chipspecif mk file
ifneq ($(WL_NRXD),)
        EXTRA_DFLAGS += -DWL_NRXD=$(WL_NRXD)
        endif
ifneq ($(WL_NTXD),)
        EXTRA_DFLAGS += -DWL_NTXD=$(WL_NTXD)
        endif
#LFRAGPOOL
ifeq ($(BCMFRAGPOOL),1)
	EXTRA_DFLAGS += -DBCMFRAGPOOL

	ifeq ($(BCMFRAGPOOL_DISABLED),1)
		EXTRA_DFLAGS += -DBCMFRAGPOOL_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMFRAGPOOL_DISABLED
	endif
endif # BCMFRAGPOOL

# split RX
COPY_CNT_BYTES ?= 32
#for splitrx below values will be default
#it can be override in chip specific make file
WL_SPLITRX_MODE ?= 2
WL_CLASSIFY_FIFO ?= 1

ifeq ($(BCMSPLITRX),1)
	EXTRA_DFLAGS += -DBCMSPLITRX
	EXTRA_DFLAGS += -DBCMRXFRAGPOOL

	ifeq ($(BCMSPLITRX_DISABLED),1)
        	EXTRA_DFLAGS += -DBCMSPLITRX_DISABLED
		EXTRA_DFLAGS += -DBCMRXFRAGPOOL_DISABLED
	else
		EXTRA_DFLAGS += -DSHARED_RXFRAG_POOL_LEN=$(RXFRAG_POOL_LEN)
	endif
	ifneq ($(WL_POST_FIFO1),)
		EXTRA_DFLAGS += -DNRXBUFPOST_FIFO1=$(WL_POST_FIFO1)
	endif
        ifneq ($(WL_POST_CLASSIFIED_FIFO),)
            EXTRA_DFLAGS += -DNRXBUFPOST_CLASSIFIED_FIFO=$(WL_POST_CLASSIFIED_FIFO)
        endif
        ifneq ($(WL_SPLITRX_MODE),)
                EXTRA_DFLAGS += -DSPLIT_RXMODE=$(WL_SPLITRX_MODE)
        else
                EXTRA_DFLAGS += -DSPLIT_RXMODE=0
        endif
        ifneq ($(WL_CLASSIFY_FIFO),)
            EXTRA_DFLAGS += -DPKT_CLASSIFY_FIFO=$(WL_CLASSIFY_FIFO)
        endif
        ifneq ($(COPY_CNT_BYTES),)
            EXTRA_DFLAGS += -DCOPY_CNT_BYTES=$(COPY_CNT_BYTES)
         endif

else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMSPLITRX_DISABLED
		EXTRA_DFLAGS += -DBCMRXFRAGPOOL_DISABLED
	endif
endif # BCMSPLITRX

#Single Lfrag for AMSDU
ifeq ($(AMSDU_FRAG_OPT), 1)
	EXTRA_DFLAGS += -DAMSDU_FRAG_OPT
endif
# HOST TXHDR
ifeq ($(HOST_HDR_FETCH), 1)
	ifeq ($(HOST_HDR_FETCH_DISABLED), 1)
		EXTRA_DFLAGS += -DHOST_HDR_FETCH_DISABLED
	endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DHOST_HDR_FETCH_DISABLED
        endif
endif   # HOST TXHDR

ifeq ($(DBG_AMPDU),1)
	# Debug for: wl dump ampdu; wl ampdu_clear_dump
	EXTRA_DFLAGS += -DBCMDBG_AMPDU
endif

ifeq ($(DBG_AMSDU),1)
	# Debug for: wl dump amsdu
	EXTRA_DFLAGS += -DBCMDBG_AMSDU
endif

ifeq ($(DBG_MU),1)
	# Debug for MU:
	EXTRA_DFLAGS += -DBCMDBG_MU
endif

ifeq ($(DBG_PHYBU),1)
	# Debug for illegal phy register accesses during phy bringup
	# Phy register trace adds ~26KB
	EXTRA_DFLAGS += -DBCMDBG_PHYREGS_TRACE
endif

ifeq ($(BCM_SPLITBUF),1)
	EXTRA_DFLAGS += -DBCM_SPLITBUF

	ifeq ($(BCM_SPLITBUF_DISABLED),1)
		EXTRA_DFLAGS += -DBCM_SPLITBUF_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCM_SPLITBUF_DISABLED
	endif
endif

ifeq ($(WLOVERTHRUSTER),1)
	ifeq ($(WLOVERTHRUSTER_DISABLED), 1)
		EXTRA_DFLAGS += -DWLOVERTHRUSTER_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLOVERTHRUSTER_DISABLED
	endif
endif

# interconnect/backplane specific objects and flags
TARGET_IBUS ?= si
ifeq ($(TARGET_IBUS),pci)
	IBUS_OBJECTS += hndpci.o
	EXTRA_DFLAGS += -DHNDPCI
	EXTRA_DFLAGS += -DSDTEST
endif
ifeq ($(TARGET_IBUS),si)
	SIBUS := 1
endif

STARTUP ?= run
ifeq ($(STARTUP),boot)
	STARTUP_OBJECTS := $(BOOT_OBJECTS)
endif
ifeq ($(STARTUP),run)
	STARTUP_OBJECTS := $(RUN_OBJECTS)
endif

# mfgtest is in rom
ifeq ($(ROMMFG),1)
	EXTRA_DFLAGS += -DBCMROMMFG
endif

ifeq ($(ROMBUILD),1)
	EXTRA_DFLAGS += -DBCMROMBUILD
endif

# Use TCAM to patch ROM functions
ifeq ($(JMPTBL_TCAM),1)
	EXTRA_DFLAGS += -DBCMJMPTBL_TCAM
endif

ifeq ($(ROMOFFLOAD),1)
	EXTRA_DFLAGS += -DBCMROMOFFLOAD

        # Other chips might need long_call, but only these have dongle roml makefiles
	ifneq ($(findstring $(CHIP),4315 4322 4325 4328 4329 43236),)
		EXTRA_DFLAGS += -DBCMROMOFFLOAD_LONGCALL
	endif

	ifeq ($(ROMLDIR),)
		ifneq ($($(REALTGT)-romrev),)
			ROMREV := $($(REALTGT)-romrev)
		endif
ifndef ROMREV
$(error ROMREV is unknown)
endif
		REV := $(ROMREV)
	endif
	ifneq ($($(REALTGT)-romlib),)
		ROMLLIB := $($(REALTGT)-romlib)
	endif
	ifeq ($(ROMMFG),1)
		ifeq ($(MFGTEST),)
			EXTRA_DFLAGS += -DBCMROMMFG_DISABLE
		endif
	endif
	ifeq ($(JMPTBL_FULL),1)
		EXTRA_DFLAGS += -DBCMJMPTBL_FULL
	endif
endif

ifeq ($(INTERNAL),1)
	EXTRA_DFLAGS += -DBCMINTERNAL
	WLDIAG ?= 1
endif

ifeq ($(UPGRADE),1)
	EXTRA_DFLAGS += -DFLASH_UPGRADE
endif

ifeq ($(FLASH),1)
	EXTRA_DFLAGS += -DFLASH
endif

ifneq ($(MEMBASE),)
	EXTRA_DFLAGS += -DMEMBASE=$(MEMBASE)
endif

ifneq ($(MEMSIZE),)
	EXTRA_DFLAGS += -DMEMSIZE=$(MEMSIZE)
endif

ifeq ($(RECLAIM),1)
	EXTRA_DFLAGS += -DBCMRECLAIM -DBCMNODOWN
endif

ifeq ($(CONSOLE),1)
	EXTRA_DFLAGS += -DRTE_CONS
else
	EXTRA_DFLAGS += -DBCM_STDLIB_NO_PUTC
endif
ifeq ($(UART),1)
	EXTRA_DFLAGS += -DRTE_UART
endif

ifeq ($(SMALL),1)
	EXTRA_DFLAGS += -DBCMSMALL
endif

ifeq ($(POLL),1)
	EXTRA_DFLAGS += -DRTE_POLL
endif

ifeq ($(RWL_WIFI),1)
	EXTRA_DFLAGS += -DRWL_WIFI
endif

ifeq ($(RWL_DONGLE),1)
	EXTRA_DFLAGS += -DRWL_DONGLE -DCHIPC_UART_ALWAYS_ON
endif

ifeq ($(WIFI_REFLECTOR),1)
	EXTRA_DFLAGS += -DWIFI_REFLECTOR
endif

ifeq ($(UART_REFLECTOR),1)
	EXTRA_DFLAGS += -DUART_REFLECTOR -DCHIPC_UART_ALWAYS_ON
endif

ifeq ($(SPROMBUS),pcmcia)
	EXTRA_DFLAGS += -DSI_PCMCIA_SROM
endif

ifeq ($(NVRAM),1)
	EXTRA_DFLAGS += -DBCM_DONGLEVARS
endif

ifeq ($(DNG_DBGDMP),1)
	EXTRA_DFLAGS += -DBCM_DNGDMP
endif

ifeq ($(SDR),1)
	EXTRA_DFLAGS += -DBCM_SDRBL -DBCMTRXV2 -DLTC_NO_WCHAR
	ARFLAGS = rv
	LIBDIR = ../..
	LIBNAME = libtcm.a
	ifeq ($(findstring $(LIBNAME),$(wildcard $(LIBDIR)/$(LIBNAME))),)
		LIB_NAME = $(LIBDIR)$(LIBNAME)
	endif
	LIB = -L$(LIBDIR) -ltcm
endif

ifeq ($(TCAM),1)
	EXTRA_DFLAGS += -DBCMTCAM
	# Patch count: 0 - 4
	#       - consecutive locations (CPC) = 2 ** PCNT
	ifneq ($(TCAM_PCNT),)
		EXTRA_DFLAGS += -DPATCHCOUNT=$(TCAM_PCNT)
	endif
endif

ifeq ($(RSOCK),1)
	vpath %.c	$(SRCBASE)/toe/lwip/src/core \
			$(SRCBASE)/toe/lwip/src/core/ipv4 \
			$(SRCBASE)/toe/lwip/src/netif \
			$(SRCBASE)/toe/rserv \
			$(SRCBASE)/toe/rserv/rte \
			$(SRCBASE)/toe/shared
	vpath %.S	$(SRCBASE)/toe/shared

	PROTO_OBJECTS := $(subst dngl_rte.o,dngl_rte_rsock.o,$(PROTO_OBJECTS))
	PROTO_OBJECTS += rserv.o rserv_rte.o rserv_if.o \
		   inet.o mem.o memp.o netif.o dhcp.o pbuf.o \
		   raw.o stats.o sys.o tcp.o tcp_in.o tcp_out.o udp.o etharp.o
# IPV4 subdir
	PROTO_OBJECTS += icmp.o ip.o ip_addr.o ip_frag.o

	ifeq ($(TARGET_ARCH),arm)
		ifeq ($(THUMB),1)
			PROTO_OBJECTS += csumthumb.o
		else
			PROTO_OBJECTS += csumarm.o
		endif
	else
$(error RSOCK does not support $(TARGET_ARCH))
	endif

	EXTRA_IFLAGS += -I$(SRCBASE)/toe/include \
			-I$(SRCBASE)/toe/rserv \
			-I$(SRCBASE)/toe/rserv/rte \
			-I$(SRCBASE)/toe/lwip/src/include \
			-I$(SRCBASE)/toe/lwip/src/include/ipv4
	EXTRA_DFLAGS += -DRSOCK -DRSOCK_BUS_MTU=500
# Debug feature to automatically join a fixed SSID at startup
#	EXTRA_DFLAGS += -DHND_JOIN_SSID=\"csm-g\"
endif

ifeq ($(WLSCAN_PS),1)
   ifeq ($(WLSCAN_PS_DISABLED),1)
      EXTRA_DFLAGS += -DWLSCAN_PS_DISABLED
   endif
else
   ifneq ($(GENROMTBL),1)
      EXTRA_DFLAGS += -DWLSCAN_PS_DISABLED
   endif
endif

ifeq ($(WLOSEN),1)
   ifeq ($(WLOSEN_DISABLED),1)
      EXTRA_DFLAGS += -DWLOSEN_DISABLED
   endif
else
   ifneq ($(GENROMTBL),1)
      EXTRA_DFLAGS += -DWLOSEN_DISABLED
   endif
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++ optional attributes depending on others  +++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# TRX_OPTIONS: download & jumpto locations for image downloaded to bootloader
# BIN_TRX_OPTIONS: jumpto locations and flag to indicate uncompressed image to bootloader

ifneq ($(findstring usb,$(TARGET_HBUS)),)
	ifeq ($(TARGET_ARCH),arm)
		ifeq ($(TARGET_CPU),cm3)
			ifeq ($(THUMB),1)
				TRX_OPTIONS += -x 0x60000000 -x 0x00000081
			else
				TRX_OPTIONS += -x 0x60000000 -x 0x00000080
			endif
			TRX_OFFSET1	?= 0x00000081
		else ifeq ($(TARGET_CPU),cr4)
			EXTRA_DFLAGS += -DBCMTRXV2
			ifeq ($(FLOPS_SUPPORT),1)
				TRX_OFFSET1	?= 0x00180881
			else
				TRX_OFFSET1	?= 0x00000001
			endif
		else ifeq ($(TARGET_CPU),ca7)
			EXTRA_DFLAGS += -DBCMTRXV2
			ifeq ($(FLOPS_SUPPORT),1)
				TRX_OFFSET1	?= 0x00200881
			else
				TRX_OFFSET1	?= 0x00000001
			endif
		else
			TRX_OPTIONS += -x 0x80000000 -x 0x00000000
			TRX_OFFSET1	?= 0x00000000
		endif
	endif
	ifeq ($(TARGET_ARCH),mips)
		TRX_OPTIONS += -x 0x80001000 -x 0x80001000
		TRX_OFFSET1	?= 0x80001000
	endif
endif

TRX_OFFSET1 ?= 0x0

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++ optional attributes for debugging  +++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ifeq ($(BCMDBG),1)
	EXTRA_DFLAGS += -DBCMDBG
endif

ifeq ($(DBG_ASSERT),1)
	EXTRA_DFLAGS += -DBCMDBG_ASSERT
	# DBG_ASSERT_TRAP causes a trap/exception when an ASSERT fails, instead of calling an assert
	# handler to log the file and line number. This is a memory optimization that eliminates
	# the strings associated with the file/line and the function call overhead associated with
	# invoking the assert handler. The assert location can be determined based upon the program
	# counter displayed by the trap handler.
	ifeq ($(DBG_ASSERT_TRAP),1)
		EXTRA_DFLAGS += -DBCMDBG_ASSERT_TRAP
	endif
endif

ifeq ($(DBG_ERROR),1)
	EXTRA_DFLAGS += -DBCMDBG_ERR
endif

ifeq ($(DBG_MEM),1)
	EXTRA_DFLAGS += -DBCMDBG_MEM
endif

ifeq ($(DBG_TEMPSENSE),1)
	EXTRA_DFLAGS += -DBCMDBG_TEMPSENSE
endif

ifeq ($(DBG_SDLAT),1)
	EXTRA_DFLAGS += -DBCMDBG_SD_LATENCY
endif

ifeq ($(DBG_MEMFAIL),1)
	EXTRA_DFLAGS += -DBCMDBG_MEMFAIL
endif

ifeq ($(PRHDRS),1)
	EXTRA_DFLAGS += -DWLMSG_PRHDRS
endif

ifeq ($(PRPKT),1)
	EXTRA_DFLAGS += -DWLMSG_PRPKT
endif

ifeq ($(INFORM),1)
	EXTRA_DFLAGS += -DWLMSG_INFORM
endif

ifeq ($(ASSOC),1)
	EXTRA_DFLAGS += -DWLMSG_ASSOC
endif

ifeq ($(ASSOC_LT),1)
	EXTRA_DFLAGS += -DWLMSG_ASSOC_LT
endif

ifeq ($(PS),1)
	EXTRA_DFLAGS += -DWLMSG_PS
endif

ifeq ($(WSEC),1)
	EXTRA_DFLAGS += -DWLMSG_WSEC
endif

ifeq ($(MPC),1)
	EXTRA_DFLAGS += -DWLMSG_MPC
endif

ifeq ($(SCAN),1)
	EXTRA_DFLAGS += -DWLMSG_SCAN
endif

ifeq ($(DFS),1)
	EXTRA_DFLAGS += -DWLMSG_DFS
endif

ifeq ($(OID),1)
	EXTRA_DFLAGS += -DWLMSG_OID
endif

ifeq ($(BTA),1)
	EXTRA_DFLAGS += -DWLMSG_BTA
endif

ifeq ($(DUMP),1)
	EXTRA_DFLAGS += -DBCMDBG_DUMP
endif

ifeq ($(PHYDUMP),1)
	EXTRA_DFLAGS += -DBCMDBG_PHYDUMP
endif

ifeq ($(MACDBG),1)
	EXTRA_DFLAGS += -DBCM_MACDBG
endif

ifeq ($(CCA_STATS),1)
	EXTRA_DFLAGS += -DCCA_STATS
endif

ifeq ($(ROAM),1)
	EXTRA_DFLAGS += -DWLMSG_ROAM
endif

ifeq ($(MSGMCNX),1)
	EXTRA_DFLAGS += -DWLMSG_MCNX
endif

ifeq ($(PHY_EPAPD),1)
	EXTRA_DFLAGS += -DEPAPD_SUPPORT=1
else
	ifeq ($(PHY_EPAPD),0)
		EXTRA_DFLAGS += -DEPAPD_SUPPORT=0
	endif
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++ config/tunable options  ++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# usb retail support
ifneq ($(findstring usb,$(TARGET_HBUS)),)
	ifeq ($(HBUS_PROTO),rndis)
		ifeq ($(RETAIL),1)
			CONFIG_USBRNDIS_RETAIL := 1
		endif
		ifeq ($(MFGTEST),1)
			CONFIG_USBRNDIS_RETAIL := 1
		endif
	endif
endif

# interconnect support
ifeq ($(SIBUS),1)
	BCMSIBUS := 1
endif

# mac/phy support
ifeq ($(BAND),ag)
	DBAND := 1
	WL11H ?= 1
	WL11D ?= 1
endif

# mfgtest support
ifeq ($(MFGTEST),1)
	ifeq ($(ATE),1)
		EXTRA_DFLAGS += -DWLPKTENG
	else
		WLTEST ?= 1
		WLTINYDUMP ?= 1
	endif
	EXTRA_DFLAGS += -DWLTEST_DFSMSG
	SAMPLE_COLLECT ?= 1
	ifneq ($(findstring sdio,$(TARGET_HBUS)),)
		EXTRA_DFLAGS := $(filter-out -DSDPCMD_RXBUFS=% -DSDPCMD_NRXD=% -DSDPCMD_NTXD=%,\
			$(EXTRA_DFLAGS))
		EXTRA_DFLAGS += -DSDPCMD_RXBUFS=7 -DSDPCMD_NRXD=8 -DSDPCMD_NTXD=8
	endif
	ifeq ($(ATE),1)
		WL_STATS_DISABLED ?= 1
	else
		WL_STATS ?= 1
		WL_STATS_DISABLED ?= 0
	endif
else
	WL_STATS_DISABLED ?= 1
endif # MFGTEST

# LMTPC (lpc) support
ifeq ($(LPC),1)
	WL_LPC := 1
endif

ifeq ($(LPC_DEBUG),1)
        WL_LPC_DEBUG := 1
endif

ifeq ($(WL_RELMCAST),1)
	ifeq ($(WL_RELMCAST_DISABLED),1)
		EXTRA_DFLAGS += -DWL_RELMCAST_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_RELMCAST_DISABLED
	endif
endif

ifeq ($(WLAIBSS), 1)
	WLMCNX := 1
	EXTRA_DFLAGS += -DWLTSFSYNC
	ifeq ($WLAIBSS_DISABLED), 1)
		EXTRA_DFLAGS += -DWLAIBSS_DISABLED
	else
		WLMCNX_DISABLED := 0
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLAIBSS_DISABLED
	endif
endif

ifeq ($(WLIPFO), 1)
	ifeq ($WLIPFO_DISABLED), 1)
		EXTRA_DFLAGS += -DWLIPFO_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLIPFO_DISABLED
	endif
endif

ifeq ($(WL_FRWD_REORDER), 1)
	ifeq ($WL_FRWD_REORDER_DISABLED), 1)
		EXTRA_DFLAGS += -DWL_FRWD_REORDER_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_FRWD_REORDER_DISABLED
	endif
endif

#ULB
ifeq ($(WL11ULB),1)
	ifeq ($(WL11ULB_DISABLED),1)
		EXTRA_DFLAGS += -DWL11ULB_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL11ULB_DISABLED
	endif
endif

ifeq ($(BCMEXTSUP),1)
	EXTRA_DFLAGS += -DBCMEXTSUP
endif

ifeq ($(CCX),1)
	WLRM := 1
	WME := 1
	BCMCCX := 1

	ifeq ($(BCMEXTSUP),)
		IDSUP := 1
	endif
	ifeq ($(CCX_DISABLED),1)
		EXTRA_DFLAGS += -DBCMCCX_DISABLED
	endif
	ifeq ($(CCX_AP_KEEP_ALIVE_DISABLED),1)
		EXTRA_DFLAGS    += -DCCX_AP_KEEP_ALIVE_DISABLED
	endif	# CCX_AP_KEEP_ALIVE_DISABLED
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMCCX_DISABLED
	endif
endif	# CCX

ifeq ($(WLRM),1)
	ifeq ($(WLRM_DISABLED),1)
		EXTRA_DFLAGS += -DWLRM_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLRM_DISABLED
	endif
endif # WLRM

ifeq ($(IDSUP),1)
	BCMSUP_PSK := 1
	ifeq ($(IDSUP_DISABLED),1)
		EXTRA_DFLAGS += -DBCMSUP_PSK_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMSUP_PSK_DISABLED
	endif
endif

ifeq ($(IDAUTH),1)
	BCMAUTH_PSK := 1
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DBCMAUTH_PSK_DISABLED
	endif
endif

ifeq ($(LED),1)
	WLLED := 1
	ifeq ($(DEFAULT_GPIOTIMERVAL),)
		DEFAULT_GPIOTIMERVAL := 0x640000
	endif
	EXTRA_DFLAGS += -DDEFAULT_GPIOTIMERVAL=$(DEFAULT_GPIOTIMERVAL)
endif

ifeq ($(ANQPO),1)
	ifeq ($(ANQPO_DISABLED),1)
		EXTRA_DFLAGS += -DANQPO_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DANQPO_DISABLED
	endif
endif

# p2po
ifeq ($(P2PO),1)
	ifeq ($(P2PO_DISABLED),1)
		EXTRA_DFLAGS += -DP2PO_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DP2PO_DISABLED
	endif
endif

# USB+nodis+dis: turn on GIANT rx buffer and Partition management
ifneq ($(findstring usb,$(TARGET_HBUS)),)
	EXTRA_DFLAGS += -DUSBBULK_RXBUF_GIANT=$(USBBULK_RXBUF_GIANT)
	ifneq ($(USBBULK_RXBUF_GIANT),0)
		PT_GIANT := 1
		EXTRA_DFLAGS += -DHND_PT_GIANT
		HNDLBUFCOMPACT := 0
	endif
endif

ifeq ($(NODIS),1)
	NODIS := 1
# enable DTMTEST(required by WHQL) for all -nodis- image(enabled on NDIS builds)
	EXTRA_DFLAGS += -DDTMTEST

	ifneq ($(findstring usb,$(TARGET_HBUS)),)
		EXTRA_DFLAGS += -DBCMUSB_NODISCONNECT
		EXTRA_DFLAGS += -DBCM_DNGL_BL_PID=$(BCM_DNGL_BL_PID)
	endif
else
	ifneq ($(findstring usb,$(TARGET_HBUS)),)
		EXTRA_DFLAGS += -DBCM_DNGL_BL_PID=0xbdc
	endif
endif

ifeq ($(NDIS),1)
	NODIS := 1

	EXTRA_DFLAGS += -DADV_PS_POLL

	ifeq ($(VISTA),1)
		# dongle doesn't define WLNDIS, but need OIDs and vista monitor
		WLVISTA := 1
		BCMDONGLE := 1
		EXTRA_DFLAGS += -DWL_ASSOC_RECREATE
	else
		PROP_TXSTATUS := 0
		# if EXT_STA_DONGLE is defined in ROM
		EXTRA_DFLAGS += -DEXT_STA_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_DISCOVERY_EVENT_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_GROUP_KEY_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_MGMT_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DEXT_STA_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_DISCOVERY_EVENT_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_GROUP_KEY_DISABLED
		EXTRA_DFLAGS += -DIBSS_PEER_MGMT_DISABLED
	endif
endif

ifeq ($(DHDOID),1)
	EXTRA_DFLAGS += -DDHD_NDIS_OID -DADV_PS_POLL

	ifeq ($(HOSTOIDS_DISABLED),1)
		EXTRA_DFLAGS += -DHOSTOIDS_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DHOSTOIDS_DISABLED
	endif
endif

ifeq ($(PNO),1)
	WLPFN := 1
endif

ifeq ($(WLPFN),1)
	ifeq ($(WLPFN_DISABLED),1)
		EXTRA_DFLAGS += -DWLPFN_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLPFN_DISABLED
	endif
endif

ifeq ($(AOE),1)
	ARPOE := 1
	ifeq ($(ARPOE_DISABLED),1)
		EXTRA_DFLAGS += -DARPOE_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DARPOE_DISABLED
	endif
endif

ifeq ($(WL_BWTE),1)
        ifeq ($(WL_BWTE_DISABLED),1)
                EXTRA_DFLAGS += -DWL_BWTE_DISABLED
        endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DWL_BWTE_DISABLED
        endif
endif

ifeq ($(WL_TBOW),1)
   ifeq ($(WL_TBOW_DISABLED),1)
      EXTRA_DFLAGS += -DWL_TBOW_DISABLED
   endif
else
   ifneq ($(GENROMTBL),1)
      EXTRA_DFLAGS += -DWL_TBOW_DISABLED
   endif
endif

ifeq ($(TOE),1)
	ifeq ($(TOE_DISABLED),1)
		EXTRA_DFLAGS += -DTOE_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DTOE_DISABLED
	endif
endif

ifeq ($(NWOE),1)
	ifeq ($(NWOE_DISABLED),1)
		EXTRA_DFLAGS += -DNWOE_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DNWOE_DISABLED
	endif
endif

ifeq ($(WL_OKC),1)
	ifeq ($(WL_OKC_DISABLED),1)
		EXTRA_DFLAGS += -DWL_OKC_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_OKC_DISABLED
	endif
endif

ifeq ($(PLT),1)
	WLPLT := 1
	EXTRA_DFLAGS += -DWLPLT_ENABLED
endif

ifeq ($(BTAMP),1)
	APSTA := 1
	WME := 1
	WDS := 1
	APCS := 1
	WLBTAMP := 1
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLBTAMP_DISABLED
	endif
endif	# BTAMP

ifeq ($(WLFCTS), 1)
	ifeq ($(WLFCTS_DISABLED),1)
		EXTRA_DFLAGS += -DWLFCTS_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLFCTS_DISABLED
	endif
endif

ifeq ($(SRSCAN), 1)
	ifeq ($(SRSCAN_DISABLED),1)
		EXTRA_DFLAGS += -DWLMSG_SRSCAN_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLMSG_SRSCAN_DISABLED
	endif
endif

#p2p
ifeq ($(P2P),1)
	APSTA := 1
	WME := 1
	WLP2P := 1
	ifeq ($(VISTA),1)
		# biggest value should be last place VDEV is modified
		VDEV := 6
	else
		VDEV := 1
	endif
	WLMCHAN := 1
	WIFI_ACT_FRAME := 1
	WLMCNX := 1
	WLMCNX_DISABLED := 0
	ifeq ($(WLP2P_DISABLED),1)
		EXTRA_DFLAGS += -DWLP2P_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLP2P_DISABLED
		WLMCHAN_DISABLED := 1
		EXTRA_DFLAGS += -DWLMCHAN_DISABLED
	endif
endif	# P2P

#mchan
ifeq ($(WLMCHAN),1)
	ifeq ($(WLMCHAN_DISABLED),1)
		EXTRA_DFLAGS += -DWLMCHAN_DISABLED
	endif
endif

#RSDB
ifeq ($(RSDB), 1)
	WLRSDB := 1
endif

ifeq ($(WLRSDB), 1)
	ifeq ($(WL_RSDB_DISABLED), 1)
		EXTRA_DFLAGS += -DWLRSDB_DISABLED
        else
                ifeq ($(WLTEST), 1)
#For DVT sharing has to be selectively avoided on certain obj reg entries and iovars
                    RSDB_DVT := 1
                endif
	endif
else
   ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLRSDB_DISABLED
	endif
endif

# DYN160
ifeq ($(DYN160),1)
	ifeq ($(DYN160_DISABLED),1)
		EXTRA_DFLAGS += -DDYN160_DISABLED
	endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DDYN160_DISABLED
        endif
endif   # DYN160

#BGDFS
ifeq ($(BGDFS),1)
	ifeq ($(BGDFS_DISABLED),1)
		EXTRA_DFLAGS += -DBGDFS_DISABLED
	endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DBGDFS_DISABLED
        endif
endif   # BGDFS

#MFP
ifeq ($(MFP),1)
	ifeq ($(MFP_DISABLED),1)
		EXTRA_DFLAGS += -DMFP_DISABLED
	endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DMFP_DISABLED
        endif
endif   # MFP

#SLAVE_RADAR
ifeq ($(SLAVE_RADAR),1)
	EXTRA_DFLAGS += -DSLAVE_RADAR
endif	# SLAVE_RADAR

ifeq ($(WLSTB),1)
	EXTRA_DFLAGS += -DWLSTB
endif	# WLSTB

#LTECX
ifeq ($(BCMLTECOEX), 1)
	ifeq ($(BCMLTECOEX_DISABLED), 1)
		EXTRA_DFLAGS += -DBCMLTECOEX_DISABLED
	endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DBCMLTECOEX_DISABLED
        endif
endif   # LTECX

ifeq ($(AMPDU_HOSTREORDER),1)
   ifeq ($(AMPDU_HOSTREORDER_DISABLED),1)
      EXTRA_DFLAGS += -DWLAMPDU_HOSTREORDER_DISABLED
   endif
else
   ifneq ($(GENROMTBL),1)
      EXTRA_DFLAGS += -DWLAMPDU_HOSTREORDER_DISABLED
   endif
endif

ifeq ($(SRHWVSDB),1)
   ifeq ($(SRHWVSDB_DISABLED),1)
      EXTRA_DFLAGS += -DSRHWVSDB_DISABLED
   endif
else
   ifneq ($(GENROMTBL),1)
      EXTRA_DFLAGS += -DSRHWVSDB_DISABLED
   endif
endif

ifeq ($(PROP_TXSTATUS),1)
	EXTRA_DFLAGS += -DPROP_TXSTATUS
	METADATA_TO_HOST := 1
	CREDIT_INFO_UPDATE := 1
	ifeq ($(PROP_TXSTATUS_ENABLED),1)
		EXTRA_DFLAGS += -DPROP_TXSTATUS_ENABLED
	endif
	# for message buf protocol proptx status shouldn't be enabled
	ifneq ($(MSGBUF),1)
		ifneq ($(ROMOFFLOAD),1)
			EXTRA_DFLAGS += -DPROP_TXSTATUS_ENABLED
		endif
	endif
endif	# PROP_TXSTATUS

ifeq ($(METADATA_TO_HOST), 1)
	EXTRA_DFLAGS += -DMETADATA_TO_HOST
	ifeq ($(METADATA_TO_HOST_DISABLED),1)
		EXTRA_DFLAGS += -DMETADATA_TO_HOST_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DMETADATA_TO_HOST_DISABLED
	endif
endif

ifeq ($(CREDIT_INFO_UPDATE), 1)
	EXTRA_DFLAGS += -DCREDIT_INFO_UPDATE
	ifeq ($(CREDIT_INFO_UPDATE_DISABLED),1)
		EXTRA_DFLAGS += -DCREDIT_INFO_UPDATE_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DCREDIT_INFO_UPDATE_DISABLED
	endif
endif

ifeq ($(LPAS),1)
        EXTRA_DFLAGS += -DLPAS
endif   # LPAS

ifeq ($(BASIC_APSTA),1)
	APSTA := 1
	VDEV := 1
endif

ifeq ($(APSTA),1)
	AP := 1
	STA := 1
endif

ifeq ($(APONLY),1)
	AP := 1
	STA := 0
endif

# AP has limited AP features/capabilities
ifeq ($(AP),1)
	EXTRA_DFLAGS += -DPSQ_PKTS_LO=0 -DPSQ_PKTS_HI=8 -DPSQ_LEN=8
	ifeq ($(VISTA), 1)
		EXTRA_DFLAGS += -DEXT_AP=1
	endif
endif

ifeq ($(APCS),1)
	ifeq ($(APCS_DISABLED),1)
		EXTRA_DFLAGS += -DAPCS_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DAPCS_DISABLED
	endif
endif

# For MBSS currently support 2 IF's unless specified otherwise
ifeq ($(MBSS),1)
ifneq ($(MBSS_MAXSLAVES),)
	EXTRA_DFLAGS += -DMAXVSLAVEDEVS=$(MBSS_MAXSLAVES)
else
	EXTRA_DFLAGS += -DMAXVSLAVEDEVS=2
endif
else
# Virtual device
ifeq ($(VDEV),1)
	EXTRA_DFLAGS += -DMAXVSLAVEDEVS=1
endif
endif

ifdef MEMSIZE
#If not explicitly disabled per chip; on <=2M dongles enable lbuf head/end compaction
HNDLBUFCOMPACT_MEMSIZE := 2097152

ifndef HNDLBUFCOMPACT
	HNDLBUFCOMPACT := $(shell if [ $(MEMSIZE) -le $(HNDLBUFCOMPACT_MEMSIZE) ]; then echo 1; else echo 0; fi)
endif

ifeq ($(HNDLBUFCOMPACT),1)
	EXTRA_DFLAGS += -DHNDLBUFCOMPACT
endif
endif # MEMSIZE

# pktptr to pktid mapping for memory reduction
BCMPKTIDMAP ?= 0
PKT_MAXIMUM_ID ?= 400

# Packet pointer to packet ID suppression: using PKTID mapping to PKTPTR
# BCMPKTIDMAP and PKT_MAXIMUM_ID, defined on a per chip basis.
ifeq ($(BCMPKTIDMAP),1)

	ifneq ($(PKT_MAXIMUM_ID),)
		PKTID_TOTAL := $(PKT_MAXIMUM_ID)
	else
		PKTID_TOTAL := 256
	endif

	EXTRA_DFLAGS += -DBCMPKTIDMAP -DPKT_MAXIMUM_ID=$(PKTID_TOTAL)
endif

# BCMPKTIDAUDIT: Audit the DHD packet Id
BCMPKTIDAUDIT ?= 0
ifeq ($(BCMPKTIDAUDIT),1)
	EXTRA_DFLAGS += -DPCIEDEV_HOST_PKTID_AUDIT_ENABLED
endif

# BCMH2DCHECKSEQNUM: Check for sequence number sanity for H2D msgs
BCMH2DCHECKSEQNUM ?= 0
ifeq ($(BCMH2DCHECKSEQNUM),1)
	EXTRA_DFLAGS += -DH2D_CHECK_SEQNUM
endif

# BCMCHKD2HDMA: places a modulo-253 sequence number marker on every D2H msg
BCMCHKD2HDMA ?= 0
ifeq ($(BCMCHKD2HDMA),1)
	EXTRA_DFLAGS += -DPCIE_M2M_D2H_SYNC_SEQNUM
endif

# BCMXORCSUM: places an xor checksum on every D2H msg
BCMXORCSUM ?= 0
ifeq ($(BCMXORCSUM),1)
	EXTRA_DFLAGS += -DPCIE_M2M_D2H_SYNC_XORCSUM
endif

# BCMM2MREADBARRIER enables a read barrier access to host to force the flush
#   of pending D2H RX DMAs before updating the WR index for Msgs posted to host.
BCMM2MREADBARRIER ?= 0
ifeq ($(BCMM2MREADBARRIER),1)
	EXTRA_DFLAGS += -DPCIE_M2M_HOST_READ_BARRIER
endif

# BCMDMAINDEX: Dongle DMAs WRITE and READ indices to/from Host Support
# Indices maintained in 16bit or 32bit indices arrays.
ifeq ($(BCMDMAINDEX16),1)
	EXTRA_DFLAGS += -DPCIE_DMAINDEX16
endif
ifeq ($(BCMDMAINDEX32),1)
	EXTRA_DFLAGS += -DPCIE_DMAINDEX32
endif

# BCMHOSTRINGER enables a soft doorbell, wherein dongle will write a value into
# a host address to wakeup a thread for D2H PCIE FD rings
ifeq ($(BCMHOSTRINGER),1)
	EXTRA_DFLAGS += -DPCIE_D2H_DOORBELL_RINGER
endif

# Packet Pool
ifeq ($(BCMPKTPOOL),1)
	EXTRA_DFLAGS += -DBCMPKTPOOL

	ifneq ($(ROMOFFLOAD),1)
		EXTRA_DFLAGS += -DBCMPKTPOOL_ENABLED
	endif

	ifeq ($(MFGTEST),1)
		ifneq ($(MFGTESTPOOL_LEN),)
			POOL_LEN := $(MFGTESTPOOL_LEN)
		else
			POOL_LEN := 14
		endif
	endif

	EXTRA_DFLAGS += -DSHARED_POOL_LEN=$(POOL_LEN)
	EXTRA_DFLAGS += -DSHARED_FRAG_POOL_LEN=$(FRAG_POOL_LEN)
	ifneq ($(FRAG_POOL_LEN_SHRINK),)
		EXTRA_DFLAGS += -DSHARED_FRAG_POOL_LEN_SHRINK=$(FRAG_POOL_LEN_SHRINK)
	endif
	EXTRA_DFLAGS += -DPKTPOOL_LEN_MAX=$(POOL_LEN_MAX)

	ifneq ($(WL_POST),)
		EXTRA_DFLAGS += -DNRXBUFPOST=$(WL_POST)
	endif
endif	# BCMPKTPOOL

# dma early txreclaim
ifeq ($(DMATXRC),1)
	EXTRA_DFLAGS += -DDMATXRC

	ifeq ($(DMATXRC_DISABLED),1)
		EXTRA_DFLAGS += -DDMATXRC_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DDMATXRC_DISABLED
	endif
endif

ifeq ($(TINY_PKTJOIN),1)
	EXTRA_DFLAGS += -DTINY_PKTJOIN
	ifeq ($(TINY_PKTJOIN_DISABLED),1)
		EXTRA_DFLAGS += -DTINY_PKTJOIN_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DTINY_PKTJOIN_DISABLED
	endif
endif

ifeq ($(WL_RXEARLYRC),1)
	EXTRA_DFLAGS += -DWL_RXEARLYRC

	ifeq ($(WL_RXEARLYRC_DISABLED),1)
		EXTRA_DFLAGS += -DWL_RXEARLYRC_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_RXEARLYRC_DISABLED
	endif
endif

# rxfifo overflow handler
ifeq ($(WLRXOV),1)
	EXTRA_DFLAGS += -DWLRXOV

	ifeq ($(WLRXOV_DISABLED),1)
		EXTRA_DFLAGS += -DWLRXOV_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLRXOV_DISABLED
	endif
endif

ifeq ($(WLFBT),1)
	ifeq ($(WLFBT_DISABLED),1)
		EXTRA_DFLAGS += -DWLFBT_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLFBT_DISABLED
	endif
endif

# MBSS
ifeq ($(MBSS),1)
	ifeq ($(MBSS_DISABLED),1)
		EXTRA_DFLAGS += -DMBSS_DISABLED
	else
		WLMCNX_DISABLED := 1
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DMBSS_DISABLED
	endif
endif

# TDLS
ifeq ($(WLTDLS),1)
	ifeq ($(WLTDLS_DISABLED),1)
		EXTRA_DFLAGS += -DWLTDLS_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLTDLS_DISABLED
	endif
endif

# WL11K
ifeq ($(WL11K),1)
	ifeq ($(WL11K_DISABLED),1)
		EXTRA_DFLAGS += -DWL11K_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL11K_DISABLED
	endif
endif

# WLWNM
ifeq ($(WLWNM),1)
	ifeq ($(WLWNM_DISABLED),1)
		EXTRA_DFLAGS += -DWLWNM_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLWNM_DISABLED
	endif
endif

# WLSCANCACHE
ifeq ($(WLSCANCACHE),1)
	ifeq ($(WLSCANCACHE_DISABLED),1)
		EXTRA_DFLAGS += -DWLSCANCACHE_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLSCANCACHE_DISABLED
	endif
endif

# WL11U
L2_FILTER_STA ?= 1
ifeq ($(WL11U),1)
	ifeq ($(WL11U_DISABLED),1)
		EXTRA_DFLAGS += -DWL11U_DISABLED
		EXTRA_DFLAGS += -DL2_FILTER_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL11U_DISABLED
		EXTRA_DFLAGS += -DL2_FILTER_DISABLED
	endif
endif

ifeq ($(WLFMC),1)
	ifeq ($(WLFMC_DISABLED),1)
		EXTRA_DFLAGS += -DWLFMC_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLFMC_DISABLED
	endif
endif

ifeq ($(WLRCC),1)
	ifeq ($(WLRCC_DISABLED),1)
		EXTRA_DFLAGS += -DWLRCC_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLRCC_DISABLED
	endif
endif

ifeq ($(WLABT),1)
	ifeq ($(WLABT_DISABLED),1)
		EXTRA_DFLAGS += -DWLABT_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLABT_DISABLED
	endif
endif

# HW Overlay
ifeq ($(BCMOVLHW),1)
	EXTRA_DFLAGS += -DBCMOVLHW
endif

ifeq ($(DEVRAM_REMAP),1)
	EXTRA_DFLAGS += -DDEVRAM_REMAP
endif

ifeq ($(CAC_DISABLED),1)
	EXTRA_DFLAGS += -DWLCAC_DISABLED
endif

# ucode download
ifeq ($(UCDOWNLOAD),1)
	EXTRA_DFLAGS += -DBCMUCDOWNLOAD
ifeq ($(WLP2P),1)
	P2PUCODE = 1
else
	P2PUCODE = 0
endif
ifeq ($(DONGLEOVERLAYS),1)
	TRX_FLAGS ?= 0x002c
else
	TRX_FLAGS ?= 0x0028
endif
else	# !UCDOWNLOAD
	TRX_FLAGS ?= 0x0024
endif	# !UCDOWNLOAD

# ECI
ifeq ($(ECICOEX),1)
	EXTRA_DFLAGS += -DBCMECICOEX
	BT_FLAG = 1
else
	BT_FLAG = 0
endif

ifeq ($(SR_ESSENTIALS_DISABLED),1)
	EXTRA_DFLAGS += -DSR_ESSENTIALS_DISABLED
endif

# save-restore feature enabled
ifeq ($(SAVERESTORE),1)
	ifeq ($(SRFAST),1)
		EXTRA_DFLAGS += -DSRFAST
	endif

# Printf map to event log.
ifeq ($(BCM_EVENT_LOG),1)
	ifeq ($(BCM_MAP_ROM_PRINTF_TO_EVENT_LOG),1)
		EXTRA_DFLAGS += -DEVENT_LOG_ROM_PRINTF_MAP
	endif
endif

	ifeq ($(SAVERESTORE_DISABLED),1)
		EXTRA_DFLAGS += -DSAVERESTORE_DISABLED
	endif
	ifeq ($(SR_DEBUG),1)
		EXTRA_DFLAGS += -DSR_DEBUG
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DSAVERESTORE_DISABLED
	endif
endif

# if MAXASSOC_LIMIT is set, use it for maxassoc; otherwise use MAXSCB
ifneq ($(MAXASSOC_LIMIT),)
	EXTRA_DFLAGS += -DMAXASSOC_LIMIT=$(MAXASSOC_LIMIT)
endif

ifeq ($(call opt,fdaggr),1)
    BCM_FD_AGGR := 1
endif

# wowlpf specific flags
ifeq ($(call opt,wowlpf),1)
    WOWLPF := 1
endif

# secwowl specific flags
ifeq ($(call opt,secwowl),1)
    SECURE_WOWL := 1
endif

ifeq ($(USBDEV_COMPOSITE),1)
	EXTRA_DFLAGS	+= -DBCMUSBDEV_COMPOSITE
endif

# TXBF
ifeq ($(WLTXBF),1)
        ifeq ($(WLTXBF_DISABLED),1)
                EXTRA_DFLAGS += -DWLTXBF_DISABLED
        endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DWLTXBF_DISABLED
        endif
endif

# Enable ROM auto abandon by default for ROM offload builds.
ifeq ($(ROMOFFLOAD),1)
# Do not enable ROM auto abandon for legacy dongles.
ifneq ($(JMPTBL_FULL)$(JMPTBL_TCAM),)
# Do not enable ROM auto abandon for min-roml.
ifeq ($(findstring min-roml,$(CBRAND)),)
	BCM_ROM_AUTO_ABANDON := 1
endif
endif
endif

# ROM auto abandon feature.
ifeq ($(BCM_ROM_AUTO_ABANDON),1)
	# Disable compiler optimizations that might rename functions. All functions need to
	# maintain their original names in case they are abandoned.
	NOFNRENAME := 1

	# ROM auto IOCTL/IOVAR patching is enabled by default.
	BCM_ROM_AUTO_IOCTL_PATCH ?= 1
endif

# To enable common usb feature
ifeq ($(call opt,vusb),1)
	BCM_VUSB := 1
endif

ifeq ($(BCM_VUSB),1)
        HBUS_OBJECTS += vusbd.o
        EXTRA_DFLAGS    += -DBCMUSBDEV_COMPOSITE -DBCM_VUSBD
        BCM_USBF := 0
#       EXTRA_DFLAGS    += -DBCMDBG_ASSERT -DBCMDBG_SD_LATENCY
        EXTRA_DFLAGS    += -DVUSBD_DBG
        EXTRA_DFLAGS    += -DVUSBD_EXPT
        EXTRA_DFLAGS    += -DXDC_INT_XFER
endif

# ROM auto IOCTL/IOVAR patching feature.
ifeq ($(BCM_ROM_AUTO_IOCTL_PATCH),1)
	WLC_PATCH_IOCTL := 1
endif

# proximity detection
ifeq ($(WL_PROXDETECT),1)
	ifeq ($(WL_PROXDETECT_DISABLED),1)
		EXTRA_DFLAGS += -DWL_PROXDETECT_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_PROXDETECT_DISABLED
	endif
endif

# rssi refinement
ifeq ($(WL_RSSIREFINE),1)
	EXTRA_DFLAGS += -DRSSI_REFINE
endif

# Event log tracing
ifeq ($(BCM_LOGTRACE),1)
	BCM_EVENT_LOG := 1
	EXTRA_DFLAGS += -DLOGTRACE
endif

# Event logging
ifeq ($(BCM_EVENT_LOG),1)
	BCM_EVENT_PCI_TRACE ?= 0
	BCM_EVENT_PCI_ERROR ?= 1
	BCM_ERR_USE_EVENT_LOG ?= 1
	BCM_EVENT_MEM_ALLOC ?= 1
	EXTRA_DFLAGS += -DEVENT_LOG_COMPILE
	ifeq ($(BCM_DBG_FRAMEWORK),1)
		EXTRA_DFLAGS += -DWL_EVENT_LOG_COMPILE
	endif
# ECOUNTERS
# Ecounters has dependency on one second timer so include it
# If logtrace is not defined, disable ecounters as
# underlying transport mechanism is not available to deliver
# stats report to host
	ifneq ($(BCM_LOGTRACE),1)
		BCM_ECOUNTERS_DISABLED := 1
	endif
	ifeq ($(BCM_ECOUNTERS),1)
		ifeq ($(BCM_ECOUNTERS_DISABLED),1)
			EXTRA_DFLAGS += -DECOUNTERS_DISABLED
		endif
		BCM_RTE_ONE_SECOND_PERIODIC_TIMER ?= 1
		EXTRA_DFLAGS += -DECOUNTERS
	endif
endif

# if dbg error is defined and bcm_event_log is defined
# and if errors need to use event log, define ERR_USE_EVENT_LOG
ifeq ($(DBG_ERROR),1)
ifeq ($(BCM_EVENT_LOG),1)
# for normal event logs
ifeq ($(BCM_ERR_USE_EVENT_LOG),1)
EXTRA_DFLAGS	+= -DERR_USE_EVENT_LOG
endif
# For event logs with return address only
ifeq ($(BCM_ERR_USE_EVENT_LOG_RA),1)
EXTRA_DFLAGS	+= -DERR_USE_EVENT_LOG_RA
endif
endif
endif

# One second timer
ifeq ($(BCM_RTE_ONE_SECOND_PERIODIC_TIMER),1)
	EXTRA_DFLAGS += -DRTE_ONE_SECOND_PERIODIC_TIMER
endif

ifeq ($(BCM_EVENT_PCI_ERROR),1)
	EXTRA_DFLAGS += -DEVENT_PCI_ERROR
endif

ifeq ($(BCM_EVENT_PCI_TRACE),1)
    EXTRA_DFLAGS += -DEVENT_PCI_TRACE
endif

ifeq ($(BCM_EVENT_MEM_ALLOC),1)
    EXTRA_DFLAGS += -DEVENT_MEM_ALLOC
endif

# WFDS support
ifeq ($(WLWFDS),1)
        ifeq ($(WLWFDS_DISABLED),1)
                EXTRA_DFLAGS += -DWLWFDS_DISABLED
        endif
else
        ifneq ($(GENROMTBL),1)
                EXTRA_DFLAGS += -DWLWFDS_DISABLED
        endif
endif

# System Monitor
ifeq ($(SYSMON),1)
	EXTRA_DFLAGS += -DBCMDBG_LOADAVG -DBCMDBG_FORCEHT
endif

ifeq ($(FIQMODE),1)
	EXTRA_DFLAGS += -DFIQMODE
endif

ifeq ($(FIQ_USE_COMMON_TRAP_HDLR),1)
	EXTRA_DFLAGS += -DFIQ_USE_COMMON_TRAP_HDLR
endif

# Stack underflow protection
STACK_PROT	?= 0
ifeq ($(STACK_PROT),1)
EXTRA_DFLAGS	+= -DSTACK_PROT_TRAP
endif

# Add bss_info_t to selected events
ifeq ($(EVDATA_BSSINFO), 1)
	ifeq ($(EVDATA_BSSINFO_DISABLED), 1)
		EXTRA_DFLAGS += -DWL_EVDATA_BSSINFO_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_EVDATA_BSSINFO_DISABLED
	endif
endif

ifeq ($(WLMCNX), 1)
	ifeq ($(WLMCNX_DISABLED),1)
		EXTRA_DFLAGS += -DWLMCNX_DISABLED
	else
		# force P2P UCODE for MCNX on dongle
		WLP2P_UCODE_ONLY := 1
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLMCNX_DISABLED
	endif
endif

# STA BSS Load reporting
ifeq ($(WLBSSLOAD_REPORT),1)
	ifeq ($(WLBSSLOAD_REPORT_DISABLED),1)
		EXTRA_DFLAGS += -DWLBSSLOAD_REPORT_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLBSSLOAD_REPORT_DISABLED
	endif
endif

ifeq ($(WL_STATS),1)
	ifeq ($(WL_STATS_DISABLED),1)
		EXTRA_DFLAGS += -DWL_STATS_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWL_STATS_DISABLED
	endif
endif

AXI_TO ?= 19
# AXI backplane timout exponent value; set to 0 to disable timeouts
ifneq ($(AXI_TO),0)
	EXTRA_DFLAGS += -DAXI_TIMEOUTS -DAXI_TO_VAL=$(AXI_TO)
endif

# 11n proprietary rates support
ifeq ($(PROPRIETARY_11N_RATES),1)
	ifeq ($(PROPRIETARY_11N_RATES_DISABLED),1)
		EXTRA_DFLAGS += -DWLPROPRIETARY_11N_RATES_DISABLED
	endif
else
	ifneq ($(GENROMTBL),1)
		EXTRA_DFLAGS += -DWLPROPRIETARY_11N_RATES_DISABLED
	endif
endif

ifeq ($(DLL_USE_MACROS), 1)
	EXTRA_DFLAGS	+= -DDLL_USE_MACROS
endif

ifeq ($(HNDLBUF_USE_MACROS), 1)
	EXTRA_DFLAGS	+= -DHNDLBUF_USE_MACROS
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++ default RTE features +++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

WL ?= 1
WLWSEC ?= 1
WLRTE := 1
OSLRTE := 1
STA ?= 1
AP ?= 0
BCMNVRAMR ?= 1
BCMUTILS := 1
BCMSROM := 1
HNDDMA := 1
SIUTILS ?= 1

# Memory optimization. Use functions instead of macros for bit operations.
BCMUTILS_BIT_MACROS_USE_FUNCS ?= 1

CLM_TYPE ?= 43xx

# Set WLCLMINC to indicate that we need an incremental CLM data file
# if ROM-ed CLM data is available to compare with.
ifeq ($(ROMOFFLOAD),1)
    CLM_XML_FILE := $(abspath $(firstword $(wildcard $(addsuffix /wlc_clm_data.xml,\
	$(ROMLDIR) $(SRCBASE)/dongle/images/roml/$(CHIP)$(REV)))))
    WLCLMINC ?= 0
endif	# ROMOFFLOAD

ifeq ($(THREADX),1)
include $(SRCBASE)/dongle/make/threadx.mk
endif
ifeq ($(HNDRTE),1)
include $(SRCBASE)/dongle/make/hndrte.mk
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++ objects ++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ifeq ($(OBJECTS),)
# common object files and flags for all targets
COMMON_OBJECTS  += bcmstdlib.o hndchipc.o hnd_pktid.o hnd_lbuf.o hnd_pkt.o hnd_pt.o
COMMON_OBJECTS  += rte_isr.o rte_dev.o rte_heap.o rte_mem.o rte_pktpool.o
COMMON_OBJECTS  += rte_fetch.o rte_pktfetch.o
COMMON_OBJECTS  += rte.o rte_chipc.o rte_pmu.o
COMMON_OBJECTS  += rte_cons.o
COMMON_OBJECTS  += rte_gpio.o
ifeq ($(UART),1)
	COMMON_OBJECTS	+= rte_uart.o
endif
ifeq ($(TCAM),1)
	COMMON_OBJECTS += hndtcam.o rte_tcam.o
endif
ifeq ($(BCM_EVENT_LOG),1)
	COMMON_OBJECTS += event_log.o
endif
ifeq ($(BCM_LOGTRACE),1)
	COMMON_OBJECTS += logtrace.o
endif

# OBJECTS variable lists all object files we need for the target
OBJECTS := $(COMMON_OBJECTS) $(ARCH_OBJECTS) $(IBUS_OBJECTS)
OBJECTS += $(HBUS_OBJECTS) $(PROTO_OBJECTS) $(EXTERN_OBJECTS) $(RTOS_OBJECTS)
ifdef PROJECT
OBJECTS += $(PROJECT).o
endif
ifdef PROGRAM
OBJECTS += $(PROGRAM).o
endif
# 4366 WAR: Put the STARTUP_OBJECTS in first place, except ATE driver.
ifeq ($(ATE),1)
	OBJECTS := $(STARTUP_OBJECTS) $(OBJECTS)
	OBJECTS := $(sort $(OBJECTS))
else
	OBJECTS := $(sort $(OBJECTS))
	OBJECTS := $(STARTUP_OBJECTS) $(OBJECTS)
endif
else
OBJECTS := $(sort $(OBJECTS))
endif # OBJECTS

# Tell emacs to use Makefile mode since it does not know from the filename:
#       Local Variables:
#       mode: makefile
#       End:
