/*
 * Trace messages sent over HBUS
 *
 * Copyright 2020 Broadcom
 *
 * This program is the proprietary software of Broadcom and/or
 * its licensors, and may only be used, duplicated, modified or distributed
 * pursuant to the terms and conditions of a separate, written license
 * agreement executed between you and Broadcom (an "Authorized License").
 * Except as set forth in an Authorized License, Broadcom grants no license
 * (express or implied), right to use, or waiver of any kind with respect to
 * the Software, and Broadcom expressly reserves all rights in and to the
 * Software and all intellectual property rights therein.  IF YOU HAVE NO
 * AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
 * WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
 * THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof, and to
 * use this information only in connection with your use of Broadcom
 * integrated circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR
 * OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL,
 * SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR
 * IN ANY WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
 * IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii)
 * ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF
 * OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 * $Id: msgtrace.c 708017 2017-06-29 14:11:45Z $
 */

#include <typedefs.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmendian.h>
#include <msgtrace.h>
#include <bcmsdpcm.h>
#include <bcmpcie.h>
#include <rte_timer.h>

/* LOG_BUf_LEN must be a power of 2 */
#define LOG_BUF_LEN (2 * 1024)
#define LOG_BUF_MASK (LOG_BUF_LEN-1)

/* Retry timeout value to handle the retry of lost message */
#define RETRY_TIMEOUT_VALUE	100

/* Send timeout value to trigger immmediately the sending by leaving the context of caller */
#define SEND_TIMEOUT_VALUE	0

#define MSG_MAX_SIZE  (1500 - MSGTRACE_HDRLEN)

/* Definition of trace buffer for sending trace over host bus */
typedef struct msgtrace {
	void	*hdl1;			/* hdl1 : handler used to send trace event */
	void	*hdl2;			/* hdl2 : handler used to send trace event */
	uint8	log_buf[LOG_BUF_LEN];  	/* trace buffer     */
	uint16	write_idx;   		/* Write index to the trace buffer */
	uint16	read_idx;     		/* Read index to the trace buffer  */
	uint16	read_get_idx; 		/* Read index to the trace buffer at retrieve time  */
	uint32 	discarded_bytes;    	/* Number of discarded bytes when trace buffer is full */
	uint32 	discarded_bytes_saved; 	/* Save of discarded_bytes when sending trace event */
	uint32 	discarded_printf;    	/* Number of discarded printf when trace buffer is full */
	uint32	discarded_printf_saved;	/* Save of discarded_printf when sending trace event */
	uint32	seqnum;			/* Sequence number of event sent */
	hnd_timer_t *timer;		/* Timer used to trigger the sending  of trace buffer and
					 * used to handle the retry of lost event
					 */
	bool	sending;		/* Indicate that the sending is in progress */
	bool	pending;		/* A msg has been sent but not ackd */
	bool	filter_hbus;		/* Filter the hbus trace generated from the sending of
					 *  traces messages to its release
					 */
	bool	filter_cb;		/* Filter the trace generated by the execution callback of
					 *  sending
					 */
	msgtrace_func_send_t func_send; /* Function pointer to send trace event */
	bool event_trace_enabled;   /* EVENT_TRACE enabled/disabled flag */
	uint16 retry_count;
} msgtrace_t;

msgtrace_t msgtrace = {
	NULL,	/* hdl1 */
	NULL,	/* hdl2 */
	"",	/* log_buf */
	0,	/* write_idx */
	0,	/* read_idx */
	0,	/* read_get_idx */
	0,	/* discarded_bytes */
	0,	/* discarded_bytes_saved */
	0,	/* discarded_printf */
	0,	/* discarded_printf_saved */
	0,	/* seqnum */
	NULL,	/* timer */
	FALSE,	/* sending */
	FALSE,	/* pending */
	FALSE,	/* filter_hbus */
	FALSE,	/* filter_cb */
	NULL	/* func_send */
};

bool
msgtrace_event_enabled(void)
{
	return msgtrace.event_trace_enabled;
}

/* Flags used to avoid endless trace from hbus device code */
bool msgtrace_hbus_trace = FALSE;

void
msgtrace_stop(void)
{
	if (msgtrace.event_trace_enabled) {
		/* Stop the timer since EVENT tracing is disabled */
		hnd_timer_stop(msgtrace.timer);
		msgtrace.event_trace_enabled = FALSE;
	}
}

void
msgtrace_start(void)
{
	if (!msgtrace.event_trace_enabled) {
		/* Start the timer since EVENT tracing is enabled */
		hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
		msgtrace.event_trace_enabled = TRUE;
	}
}

/* Called when the trace has been sent over the HBUS. After this call, the HBUS device code
 *  shall not generated traces related the sent messsage, otherwise, there are endless traces.
 *  Retrieve len and update the read index of trace buffer
 *  The pointer must be aligned on 32 bits
 */
int
msgtrace_sent(void)
{
	msgtrace.read_idx = msgtrace.read_get_idx;

	if (msgtrace.event_trace_enabled) {
		/* Stop the timer started with RETRY_TIMEOUT_VALUE for handling retry */
		hnd_timer_stop(msgtrace.timer);
	}

	if (msgtrace.pending == FALSE) {
		/* Not sending anything - just return */
		return 0;
	}

	msgtrace.pending = FALSE;

	if ((msgtrace.read_idx != msgtrace.write_idx) && msgtrace.event_trace_enabled) {
		/* Traces has been added during the sending. Send again */
		hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
	}
	else {
		msgtrace.sending      = FALSE;
		msgtrace.filter_hbus  = FALSE;
	}

	/* Substract msgtrace.discarded_bytes_saved since the message has been sent
	 * with or without retry
	 */
	msgtrace.discarded_bytes   -= msgtrace.discarded_bytes_saved;
	msgtrace.discarded_printf  -= msgtrace.discarded_printf_saved;

	return 1;
}

/* Extract the trace from the buffer
 * Return two buffers address to handle the wrap
 */
static uint16
msgtrace_get(uint8 **trace)
{
	uint32 len;

	*trace = &msgtrace.log_buf[msgtrace.read_get_idx];

	if (msgtrace.read_get_idx <= msgtrace.write_idx)
		len = msgtrace.write_idx - msgtrace.read_get_idx;
	else if (msgtrace.read_get_idx > msgtrace.write_idx)
	    /* Only return up to the end of buffer to provide contiguous
	     * memory. Another call is required to retrieve the rest
	     */
		len = LOG_BUF_LEN - msgtrace.read_get_idx;

	/* Retrieved traces must not be greater than the message max size */
	if (len > MSG_MAX_SIZE)
		len = MSG_MAX_SIZE;

	msgtrace.read_get_idx = (msgtrace.read_get_idx + len) & LOG_BUF_MASK;

	return len;
}

static void
msgtrace_timeout(hnd_timer_t *t)
{
	msgtrace_hdr_t hdr;
	uint8 *trace;
	uint16 len;
	{
		/* First send of the event. Save discarded_bytes / discarded_printf */
		msgtrace.discarded_bytes_saved  = msgtrace.discarded_bytes;
		msgtrace.discarded_printf_saved = msgtrace.discarded_printf;
		msgtrace.seqnum++;
		msgtrace.retry_count = 0;
	}

	if ((len = msgtrace_get(&trace)) > 0) {
		/* Fill the trace header */
		hdr.version	     = MSGTRACE_VERSION;
		hdr.trace_type	     = MSGTRACE_HDR_TYPE_MSG;
		hdr.len              = hton16(len);
		hdr.discarded_bytes  = hton32(msgtrace.discarded_bytes_saved);
		hdr.discarded_printf = hton32(msgtrace.discarded_printf_saved);
		hdr.seqnum           = hton32(msgtrace.seqnum);

		/* Filter the HBUS device traces */
		msgtrace.filter_hbus  = TRUE;
		/* Filter the traces generated by function_send callback */
		msgtrace.filter_cb    = TRUE;

		msgtrace.pending = TRUE;
		msgtrace.func_send(msgtrace.hdl1, msgtrace.hdl2,
		                   (uint8*)&hdr, sizeof(msgtrace_hdr_t),
		                   trace, len);

		msgtrace.filter_cb    = FALSE;

		if (msgtrace.event_trace_enabled) {
			/* Restart timer if the message is lost due to lack of resources */
			hnd_timer_start(msgtrace.timer, RETRY_TIMEOUT_VALUE, FALSE);
		}
	}
}

void
msgtrace_put(char *buf, int count)
{
	uint16 freebytes;
	bool hbus_trace = msgtrace_hbus_trace;

	msgtrace_hbus_trace = FALSE;

	/* Filter the HBUS device traces generating during the sending of HBUS messages */
	if (msgtrace.filter_cb || (msgtrace.filter_hbus && hbus_trace)) {
		msgtrace.discarded_bytes += count;
		msgtrace.discarded_printf++;
		return;
	}

	freebytes = (msgtrace.read_idx == msgtrace.write_idx)
			? LOG_BUF_LEN
			: (msgtrace.read_idx - msgtrace.write_idx) & LOG_BUF_MASK;

	if (freebytes > 1) {
		/* Let 1 byte in the trace buffer so that the condition (read_idx == write_idx) is
		 *  only tied to empty buffer (not to full buffer)
		 */
		if (count > (freebytes-1)) {
			msgtrace.discarded_bytes += count - freebytes + 1;
			count = freebytes - 1;
		}

		/*  Copy the buffer */
		if (msgtrace.write_idx + count <= LOG_BUF_LEN)
			memcpy(&(msgtrace.log_buf[msgtrace.write_idx]), buf, count);
		else {
			uint16 bytes = LOG_BUF_LEN - msgtrace.write_idx;
			memcpy(&(msgtrace.log_buf[msgtrace.write_idx]), &(buf[0]), bytes);
			memcpy(&(msgtrace.log_buf[0]), &(buf[bytes]), count - bytes);
		}

		msgtrace.write_idx = (msgtrace.write_idx + count) & LOG_BUF_MASK;

		if (msgtrace.timer != NULL &&
		    !msgtrace.sending &&
		    msgtrace.event_trace_enabled) {
			/* Trigger immediately the sending by setting the timer to 0 */
			hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
			msgtrace.sending = TRUE;
		}
	} else {
		msgtrace.discarded_bytes += count;
		msgtrace.discarded_printf++;
	}
}

void
BCMATTACHFN(msgtrace_init)(void *hdl1, void *hdl2, msgtrace_func_send_t func_send)
{
	ASSERT(func_send != NULL);

	msgtrace.hdl1 = hdl1;
	msgtrace.hdl2 = hdl2;
	msgtrace.func_send = func_send;
	msgtrace.retry_count = 0;

	msgtrace.timer  = hnd_timer_create(NULL, NULL, msgtrace_timeout,  NULL);

#if defined(BCMSDIODEV_ENABLED) && defined(_RTE_)
	/* Let the host known the address of msgtrace.
	 * If there is a crash before sending the first event, then the host can download
	 * msgtrace.
	 */
	sdpcm_shared.msgtrace_addr = (uint32)&msgtrace;
#endif // endif
#if defined(BCMPCIEDEV) && defined(_RTE_)
	if (BCMPCIEDEV_ENAB()) {
		pciedev_shared.msgtrace_addr = (uint32)&msgtrace;
	}
#endif /* BCMPCIEDEV && _RTE_ */

}
