#
# Network device configuration
#

menuconfig NETDEVICES
	default y if UML
	depends on NET
	bool "Network device support"
	---help---
	  You can say N here if you don't intend to connect your Linux box to
	  any other computer at all.

	  You'll have to say Y if your computer contains a network card that
	  you want to use under Linux. If you are going to run SLIP or PPP over
	  telephone line or null modem cable you need say Y here. Connecting
	  two machines with parallel ports using PLIP needs this, as well as
	  AX.25/KISS for sending Internet traffic over amateur radio links.

	  See also "The Linux Network Administrator's Guide" by Olaf Kirch and
	  Terry Dawson. Available at <http://www.tldp.org/guides.html>.

	  If unsure, say Y.

# All the following symbols are dependent on NETDEVICES - do not repeat
# that for each of the symbols.
if NETDEVICES

config MII
	tristate

config NET_CORE
	default y
	bool "Network core driver support"
	---help---
	  You can say N here if you do not intend to use any of the
	  networking core drivers (i.e. VLAN, bridging, bonding, etc.)

if NET_CORE

config BONDING
	tristate "Bonding driver support"
	depends on INET
	depends on IPV6 || IPV6=n
	---help---
	  Say 'Y' or 'M' if you wish to be able to 'bond' multiple Ethernet
	  Channels together. This is called 'Etherchannel' by Cisco,
	  'Trunking' by Sun, 802.3ad by the IEEE, and 'Bonding' in Linux.

	  The driver supports multiple bonding modes to allow for both high
	  performance and high availability operation.

	  Refer to <file:Documentation/networking/bonding.txt> for more
	  information.

	  To compile this driver as a module, choose M here: the module
	  will be called bonding.

config DUMMY
	tristate "Dummy net driver support"
	---help---
	  This is essentially a bit-bucket device (i.e. traffic you send to
	  this device is consigned into oblivion) with a configurable IP
	  address. It is most commonly used in order to make your currently
	  inactive SLIP address seem like a real address for local programs.
	  If you use SLIP or PPP, you might want to say Y here. Since this
	  thing often comes in handy, the default is Y. It won't enlarge your
	  kernel either. What a deal. Read about it in the Network
	  Administrator's Guide, available from
	  <http://www.tldp.org/docs.html#guide>.

	  To compile this driver as a module, choose M here: the module
	  will be called dummy.

config EQUALIZER
	tristate "EQL (serial line load balancing) support"
	---help---
	  If you have two serial connections to some other computer (this
	  usually requires two modems and two telephone lines) and you use
	  SLIP (the protocol for sending Internet traffic over telephone
	  lines) or PPP (a better SLIP) on them, you can make them behave like
	  one double speed connection using this driver.  Naturally, this has
	  to be supported at the other end as well, either with a similar EQL
	  Linux driver or with a Livingston Portmaster 2e.

	  Say Y if you want this and read
	  <file:Documentation/networking/eql.txt>.  You may also want to read
	  section 6.2 of the NET-3-HOWTO, available from
	  <http://www.tldp.org/docs.html#howto>.

	  To compile this driver as a module, choose M here: the module
	  will be called eql.  If unsure, say N.

config NET_FC
	bool "Fibre Channel driver support"
	depends on SCSI && PCI
	help
	  Fibre Channel is a high speed serial protocol mainly used to connect
	  large storage devices to the computer; it is compatible with and
	  intended to replace SCSI.

	  If you intend to use Fibre Channel, you need to have a Fibre channel
	  adaptor card in your computer; say Y here and to the driver for your
	  adaptor below. You also should have said Y to "SCSI support" and
	  "SCSI generic support".

config IFB
	tristate "Intermediate Functional Block support"
	depends on NET_CLS_ACT
	---help---
	  This is an intermediate driver that allows sharing of
	  resources.
	  To compile this driver as a module, choose M here: the module
	  will be called ifb.  If you want to use more than one ifb
	  device at a time, you need to compile this driver as a module.
	  Instead of 'ifb', the devices will then be called 'ifb0',
	  'ifb1' etc.
	  Look at the iproute2 documentation directory for usage etc

source "drivers/net/team/Kconfig"

config MACVLAN
	tristate "MAC-VLAN support"
	---help---
	  This allows one to create virtual interfaces that map packets to
	  or from specific MAC addresses to a particular interface.

	  Macvlan devices can be added using the "ip" command from the
	  iproute2 package starting with the iproute2-2.6.23 release:

	  "ip link add link <real dev> [ address MAC ] [ NAME ] type macvlan"

	  To compile this driver as a module, choose M here: the module
	  will be called macvlan.

config MACVTAP
	tristate "MAC-VLAN based tap driver"
	depends on MACVLAN
	depends on INET
	help
	  This adds a specialized tap character device driver that is based
	  on the MAC-VLAN network interface, called macvtap. A macvtap device
	  can be added in the same way as a macvlan device, using 'type
	  macvtap', and then be accessed through the tap user space interface.

	  To compile this driver as a module, choose M here: the module
	  will be called macvtap.


config IPVLAN
    tristate "IP-VLAN support"
    depends on INET
    depends on IPV6
    ---help---
      This allows one to create virtual devices off of a main interface
      and packets will be delivered based on the dest L3 (IPv6/IPv4 addr)
      on packets. All interfaces (including the main interface) share L2
      making it transparent to the connected L2 switch.

      Ipvlan devices can be added using the "ip" command from the
      iproute2 package starting with the iproute2-3.19 release:

      "ip link add link <main-dev> [ NAME ] type ipvlan"

      To compile this driver as a module, choose M here: the module
      will be called ipvlan.


config VXLAN
       tristate "Virtual eXtensible Local Area Network (VXLAN)"
       depends on INET
       select NET_UDP_TUNNEL
       ---help---
	  This allows one to create vxlan virtual interfaces that provide
	  Layer 2 Networks over Layer 3 Networks. VXLAN is often used
	  to tunnel virtual network infrastructure in virtualized environments.
	  For more information see:
	    http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02

	  To compile this driver as a module, choose M here: the module
	  will be called vxlan.

config NETCONSOLE
	tristate "Network console logging support"
	---help---
	If you want to log kernel messages over the network, enable this.
	See <file:Documentation/networking/netconsole.txt> for details.

config NETCONSOLE_DYNAMIC
	bool "Dynamic reconfiguration of logging targets"
	depends on NETCONSOLE && SYSFS && CONFIGFS_FS && \
			!(NETCONSOLE=y && CONFIGFS_FS=m)
	help
	  This option enables the ability to dynamically reconfigure target
	  parameters (interface, IP addresses, port numbers, MAC addresses)
	  at runtime through a userspace interface exported using configfs.
	  See <file:Documentation/networking/netconsole.txt> for details.

config NETPOLL
	def_bool NETCONSOLE
	select SRCU

config NET_POLL_CONTROLLER
	def_bool NETPOLL

config NTB_NETDEV
	tristate "Virtual Ethernet over NTB"
	depends on NTB

config RIONET
	tristate "RapidIO Ethernet over messaging driver support"
	depends on RAPIDIO

config RIONET_TX_SIZE
	int "Number of outbound queue entries"
	depends on RIONET
	default "128"

config RIONET_RX_SIZE
	int "Number of inbound queue entries"
	depends on RIONET
	default "128"

config IMQ
	tristate "IMQ (intermediate queueing device) support"
	depends on NETDEVICES && NETFILTER
	---help---
	  The IMQ device(s) is used as placeholder for QoS queueing
	  disciplines. Every packet entering/leaving the IP stack can be
	  directed through the IMQ device where it's enqueued/dequeued to the
	  attached qdisc. This allows you to treat network devices as classes
	  and distribute bandwidth among them. Iptables is used to specify
	  through which IMQ device, if any, packets travel.

	  More information at: https://github.com/imq/linuximq

	  To compile this driver as a module, choose M here: the module
	  will be called imq.  If unsure, say N.

choice
	prompt "IMQ behavior (PRE/POSTROUTING)"
	depends on IMQ
	default IMQ_BEHAVIOR_AB
	help
	  This setting defines how IMQ behaves in respect to its
	  hooking in PREROUTING and POSTROUTING.

	  IMQ can work in any of the following ways:

	      PREROUTING   |      POSTROUTING
	  -----------------|-------------------
	  #1  After NAT    |      After NAT
	  #2  After NAT    |      Before NAT
	  #3  Before NAT   |      After NAT
	  #4  Before NAT   |      Before NAT

	  The default behavior is to hook before NAT on PREROUTING
	  and after NAT on POSTROUTING (#3).

	  This settings are specially usefull when trying to use IMQ
	  to shape NATed clients.

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

config IMQ_BEHAVIOR_AA
	bool "IMQ AA"
	help
	  This setting defines how IMQ behaves in respect to its
	  hooking in PREROUTING and POSTROUTING.

	  Choosing this option will make IMQ hook like this:

	  PREROUTING:   After NAT
	  POSTROUTING:  After NAT

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

config IMQ_BEHAVIOR_AB
	bool "IMQ AB"
	help
	  This setting defines how IMQ behaves in respect to its
	  hooking in PREROUTING and POSTROUTING.

	  Choosing this option will make IMQ hook like this:

	  PREROUTING:   After NAT
	  POSTROUTING:  Before NAT

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

config IMQ_BEHAVIOR_BA
	bool "IMQ BA"
	help
	  This setting defines how IMQ behaves in respect to its
	  hooking in PREROUTING and POSTROUTING.

	  Choosing this option will make IMQ hook like this:

	  PREROUTING:   Before NAT
	  POSTROUTING:  After NAT

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

config IMQ_BEHAVIOR_BB
	bool "IMQ BB"
	help
	  This setting defines how IMQ behaves in respect to its
	  hooking in PREROUTING and POSTROUTING.

	  Choosing this option will make IMQ hook like this:

	  PREROUTING:   Before NAT
	  POSTROUTING:  Before NAT

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

endchoice

config IMQ_NUM_DEVS
	int "Number of IMQ devices"
	range 2 16
	depends on IMQ
	default "16"
	help
	  This setting defines how many IMQ devices will be created.

	  The default value is 16.

	  More information can be found at: https://github.com/imq/linuximq

	  If not sure leave the default settings alone.

config TUN
	tristate "Universal TUN/TAP device driver support"
	depends on INET
	select CRC32
	---help---
	  TUN/TAP provides packet reception and transmission for user space
	  programs.  It can be viewed as a simple Point-to-Point or Ethernet
	  device, which instead of receiving packets from a physical media,
	  receives them from user space program and instead of sending packets
	  via physical media writes them to the user space program.

	  When a program opens /dev/net/tun, driver creates and registers
	  corresponding net device tunX or tapX.  After a program closed above
	  devices, driver will automatically delete tunXX or tapXX device and
	  all routes corresponding to it.

	  Please read <file:Documentation/networking/tuntap.txt> for more
	  information.

	  To compile this driver as a module, choose M here: the module
	  will be called tun.

	  If you don't know what to use this for, you don't need it.

config VETH
	tristate "Virtual ethernet pair device"
	---help---
	  This device is a local ethernet tunnel. Devices are created in pairs.
	  When one end receives the packet it appears on its pair and vice
	  versa.

config VIRTIO_NET
	tristate "Virtio network driver"
	depends on VIRTIO
	select AVERAGE
	---help---
	  This is the virtual network driver for virtio.  It can be used with
	  lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.

config NLMON
	tristate "Virtual netlink monitoring device"
	---help---
	  This option enables a monitoring net device for netlink skbs. The
	  purpose of this is to analyze netlink messages with packet sockets.
	  Thus applications like tcpdump will be able to see local netlink
	  messages if they tap into the netlink device, record pcaps for further
	  diagnostics, etc. This is mostly intended for developers or support
	  to debug netlink issues. If unsure, say N.

endif # NET_CORE

config SUNGEM_PHY
	tristate

source "drivers/net/arcnet/Kconfig"

source "drivers/atm/Kconfig"

source "drivers/net/caif/Kconfig"

source "drivers/net/dsa/Kconfig"

source "drivers/net/ethernet/Kconfig"

source "drivers/net/fddi/Kconfig"

source "drivers/net/hippi/Kconfig"

config NET_SB1000
	tristate "General Instruments Surfboard 1000"
	depends on PNP
	---help---
	  This is a driver for the General Instrument (also known as
	  NextLevel) SURFboard 1000 internal
	  cable modem. This is an ISA card which is used by a number of cable
	  TV companies to provide cable modem access. It's a one-way
	  downstream-only cable modem, meaning that your upstream net link is
	  provided by your regular phone modem.

	  At present this driver only compiles as a module, so say M here if
	  you have this card. The module will be called sb1000. Then read
	  <file:Documentation/networking/README.sb1000> for information on how
	  to use this module, as it needs special ppp scripts for establishing
	  a connection. Further documentation and the necessary scripts can be
	  found at:

	  <http://www.jacksonville.net/~fventuri/>
	  <http://home.adelphia.net/~siglercm/sb1000.html>
	  <http://linuxpower.cx/~cable/>

	  If you don't have this card, of course say N.

source "drivers/net/phy/Kconfig"

source "drivers/net/plip/Kconfig"

source "drivers/net/ppp/Kconfig"

source "drivers/net/slip/Kconfig"

source "drivers/s390/net/Kconfig"

source "drivers/net/usb/Kconfig"

source "drivers/net/wireless/Kconfig"

source "drivers/net/wimax/Kconfig"

source "drivers/net/wan/Kconfig"

source "drivers/net/ieee802154/Kconfig"

config XEN_NETDEV_FRONTEND
	tristate "Xen network device frontend driver"
	depends on XEN
	select XEN_XENBUS_FRONTEND
	default y
	help
	  This driver provides support for Xen paravirtual network
	  devices exported by a Xen network driver domain (often
	  domain 0).

	  The corresponding Linux backend driver is enabled by the
	  CONFIG_XEN_NETDEV_BACKEND option.

	  If you are compiling a kernel for use as Xen guest, you
	  should say Y here. To compile this driver as a module, chose
	  M here: the module will be called xen-netfront.

config XEN_NETDEV_BACKEND
	tristate "Xen backend network device"
	depends on XEN_BACKEND
	help
	  This driver allows the kernel to act as a Xen network driver
	  domain which exports paravirtual network devices to other
	  Xen domains. These devices can be accessed by any operating
	  system that implements a compatible front end.

	  The corresponding Linux frontend driver is enabled by the
	  CONFIG_XEN_NETDEV_FRONTEND configuration option.

	  The backend driver presents a standard network device
	  endpoint for each paravirtual network device to the driver
	  domain network stack. These can then be bridged or routed
	  etc in order to provide full network connectivity.

	  If you are compiling a kernel to run in a Xen network driver
	  domain (often this is domain 0) you should say Y here. To
	  compile this driver as a module, chose M here: the module
	  will be called xen-netback.

config VMXNET3
	tristate "VMware VMXNET3 ethernet driver"
	depends on PCI && INET
	depends on !(PAGE_SIZE_64KB || ARM64_64K_PAGES || \
		     IA64_PAGE_SIZE_64KB || MICROBLAZE_64K_PAGES || \
		     PARISC_PAGE_SIZE_64KB || PPC_64K_PAGES)
	help
	  This driver supports VMware's vmxnet3 virtual ethernet NIC.
	  To compile this driver as a module, choose M here: the
	  module will be called vmxnet3.

source "drivers/net/hyperv/Kconfig"

endif # NETDEVICES
