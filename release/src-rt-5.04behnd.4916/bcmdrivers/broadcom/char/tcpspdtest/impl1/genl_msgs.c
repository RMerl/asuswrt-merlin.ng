/*
<:copyright-BRCM:2018:DUAL/GPL:standard

   Copyright (c) 2018 Broadcom 
   All Rights Reserved

Unless you and Broadcom execute a separate written software license
agreement governing use of this software, this software is licensed
to you under the terms of the GNU General Public License version 2
(the "GPL"), available at http://www.broadcom.com/licenses/GPLv2.php,
with the following added to such license:

   As a special exception, the copyright holders of this software give
   you permission to link this software with independent modules, and
   to copy and distribute the resulting executable under terms of your
   choice, provided that you also meet, for each linked independent
   module, the terms and conditions of the license of that module.
   An independent module is a module which is not derived from this
   software.  The special exception does not apply to any modifications
   of the software.

Not withstanding the above, under no circumstances may you combine
this software in any way with any other Broadcom software provided
under a license other than the GPL, without Broadcom's express prior
written consent.

:>
*/

/*
*******************************************************************************
* File Name  : genl_msgs.c
*
* Description: This file contains the Broadcom Tcp Speed Test Generic Netlink Implementation.
*
*  Created on: Dec 20, 2017
*      Author: ilanb, yonatani
*******************************************************************************
*/

#include <net/genetlink.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include "tcpspdtest.h"
#include "sock_mgr.h"
#include "tcp_engine_api.h"
#include "genl_msgs.h"

/******************************************** Defines ********************************************/
#define VERSION_NR 1

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))
/* https://forums.ni.com/t5/Linux-Users/Fix-for-NI-VISA-for-kernel-gt-4-10/gpm-p/3771178?profile.language=en */
#define GENL_ID_GENERATE 0
#endif

struct event_struct 
{
    tcp_spdt_rep_t spd_report;
    tcpspdtest_genl_cmd_status_t status;
};

/**************************************** Global / Static ****************************************/
static int recv_req_cmd_own_msg(struct sk_buff *skb, struct genl_info *info);

/* Genl Policy */
static struct nla_policy genl_policy[TCPSPDTEST_GENL_POLICY_MAX] =
{
    [TCPSPDTEST_GENL_POLICY_OWN_MSG] = { .type = NLA_UNSPEC },     /* OWN Policy Attribute */
};

static const struct genl_ops genl_ops[] =
{
    {
        .cmd = TCPSPDTEST_GENL_FAMILY_MSG_OWN_MSG,
        .flags = 0,
        .policy = genl_policy,
        .doit = recv_req_cmd_own_msg,
        .dumpit = NULL,
    },
};

/* Genl declare family */
static struct genl_family genl_family =
{
    .id = GENL_ID_GENERATE,                    /* New family id is generated by Genetlink */
    .hdrsize = 0,                              /* No family specific header */
    .name = TCPSPDTEST_GENL_FAMILY_NAME,       /* New family name */
    .version = VERSION_NR,                     /* Version num */
    .maxattr = TCPSPDTEST_GENL_POLICY_MAX - 1, /* Max policies */
    .ops = genl_ops,                           /* Family operations */
    .n_ops = ARRAY_SIZE(genl_ops),             /* Family operations array size */
    .netnsok = true,                           /* Support namespace */
};

static const tcpspd_mode_t genl_protocol2mode[] =
{
	TCPSPD_MODE_NONE,
	TCPSPD_MODE_HTTP,
    TCPSPD_MODE_FTP,
    TCPSPD_MODE_IPERF3,
    TCPSPD_MODE_BASIC
};

static struct genl_info client_info[SPDT_NUM_OF_STREAMS] = {};     /* Registered clients for asynchronuous messages */
static struct genl_info *client_info_p[SPDT_NUM_OF_STREAMS] = { NULL }; /* points to static client_info[]. a pointer is needed to check whether client info is initialized */
static struct event_struct *event_p[SPDT_NUM_OF_STREAMS];
/**************************************** Implementation *****************************************/
static int handle_req_speed_report(uint8_t stream_idx, tcpspdtest_genl_resp_msg_t *resp_msg)
{
    int rc = 0;
    struct rtnl_link_stats64 dev_stats;
 
    memcpy(&(resp_msg->msg.spd_report), &(g_spd_report[stream_idx]), sizeof(resp_msg->msg.spd_report));

    if (g_tcpspd[stream_idx].state == TCPSPD_STATE_RUNNING)
    {
        if (0 == tcpspd_get_iface_stats_by_stream(stream_idx, &dev_stats))
        {
            resp_msg->msg.spd_report.total_rx_bytes = dev_stats.rx_bytes - g_spd_iface_stats_start[stream_idx].rx_bytes;
            resp_msg->msg.spd_report.total_tx_bytes = dev_stats.tx_bytes - g_spd_iface_stats_start[stream_idx].tx_bytes;
        }

        rc = tcpspd_engine_get_bytes(stream_idx, &resp_msg->msg.spd_report.num_bytes);
        resp_msg->msg.spd_report.status = TCPSPDTEST_GENL_CMD_STATUS_IN_PROCESS;
    }

    return rc;
}

/* Handle received messages, activate by tcpspd_cmd */
static void handle_req_own_msg(tcpspdtest_genl_req_msg_t *req_msg, tcpspdtest_genl_resp_msg_t *resp_msg, struct genl_info *info)
{
    switch (req_msg->cmd)
    {
        case TCPSPDTEST_GENL_CMD_CONNECT:
        	resp_msg->cmd = TCPSPDTEST_GENL_CMD_CONNECT;
            if (req_msg->stream_params.protocol < SPDT_MAX && req_msg->stream_idx < SPDT_NUM_OF_STREAMS)
                resp_msg->status = tcpspd_cmd_connect(req_msg->stream_idx, req_msg->stream_params.dir, genl_protocol2mode[req_msg->stream_params.protocol], &req_msg->stream_params.conn_params);
            else
                resp_msg->status = -1;
            break;

        case TCPSPDTEST_GENL_CMD_DNLD:
        	resp_msg->cmd = TCPSPDTEST_GENL_CMD_DNLD;
                resp_msg->status = tcpspd_cmd_download(req_msg->stream_idx, req_msg->host_str, req_msg->file_name, req_msg->dn_up_size);
            break;

        case TCPSPDTEST_GENL_CMD_UPLOAD:
        	resp_msg->cmd = TCPSPDTEST_GENL_CMD_UPLOAD;

            /* POST Request-URI is passed in req_msg->file_name */
	        resp_msg->status = tcpspd_cmd_upload(req_msg->stream_idx, req_msg->file_name, req_msg->dn_up_size);
            break;

        case TCPSPDTEST_GENL_CMD_DISCONNECT:
        	resp_msg->cmd = TCPSPDTEST_GENL_CMD_DISCONNECT;
            resp_msg->status = tcpspd_cmd_disconnect(req_msg->stream_idx);
            break;

        case TCPSPDTEST_GENL_CMD_RELEASE:
        	resp_msg->cmd = TCPSPDTEST_GENL_CMD_RELEASE;
            resp_msg->status = tcpspd_cmd_release(req_msg->stream_idx);
            break;
        case TCPSPDTEST_GENL_CMD_OOB_SEND:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_OOB_SEND;
            resp_msg->status = tcpspd_cmd_oob_send(req_msg->stream_idx, req_msg->file_name, req_msg->dn_up_size);
            break;

        case TCPSPDTEST_GENL_CMD_SPEED_REPORT:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_SPEED_REPORT;
            if (TCPSPDTEST_GENL_CMD_PARAM_BLOCKING_END_OF_TEST == req_msg->cmd_param)
                resp_msg->status = tcpspd_cmd_speed_report_blocking(req_msg->stream_idx);
            else
                resp_msg->status = handle_req_speed_report(req_msg->stream_idx, resp_msg);
            break;

        case TCPSPDTEST_GENL_CMD_STREAM_IDX:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_STREAM_IDX;
            resp_msg->status = tcpspd_cmd_stream_idx(&req_msg->stream_idx, &resp_msg->num_streams, req_msg->cmd_param);
            if (resp_msg->status)
                break;
            if (TCPSPDTEST_GENL_CMD_PARAM_ALLOC == req_msg->cmd_param)
            {
                /* Stream allocation is done at spdt_init(), save client info for asynchronuous messages */
                if (NULL != client_info_p[req_msg->stream_idx])
                {
                    tc_err("[%hhu] Client info Already initialized !\n", req_msg->stream_idx);
                    /* The customer kill -9 it's own tr143 app such that client_info_p[] was not reset by TCPSPDTEST_GENL_CMD_PARAM_FREE.
                       Ignore NULL check to allow mulit tests executions. */
                }
                client_info_p[req_msg->stream_idx] = &client_info[req_msg->stream_idx];
                memcpy(client_info_p[req_msg->stream_idx], info, sizeof(*client_info_p[req_msg->stream_idx]));
            }
            else if (TCPSPDTEST_GENL_CMD_PARAM_FREE == req_msg->cmd_param)
            {
                if (NULL == client_info_p[req_msg->stream_idx])
                {
                    tc_err("[%hhu] Client info Not initialized !\n", req_msg->stream_idx);
                    resp_msg->status = -1;
                    break;
                }
                client_info_p[req_msg->stream_idx] = NULL;
            }
            break;

        case TCPSPDTEST_GENL_CMD_PROTOCOL:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_PROTOCOL;
            resp_msg->status = tcpspd_cmd_protocol(req_msg->stream_idx, &req_msg->stream_params.protocol, req_msg->cmd_param);
            resp_msg->msg.stream_params.protocol = req_msg->stream_params.protocol;
            break;

        case TCPSPDTEST_GENL_CMD_STREAM_PARAMS:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_STREAM_PARAMS;
            resp_msg->status = tcpspd_cmd_stream_params(req_msg->stream_idx, &req_msg->stream_params, &resp_msg->msg.stream_params, req_msg->cmd_param);
            break;

        case TCPSPDTEST_GENL_CMD_NUM_STREAMS:
            resp_msg->cmd = TCPSPDTEST_GENL_CMD_NUM_STREAMS;
            resp_msg->status = tcpspd_cmd_num_streams(req_msg->stream_idx, &resp_msg->num_streams, &resp_msg->num_udp_streams);
            break;

        case UDPSPDTEST_GENL_CMD_INIT:
            resp_msg->cmd = UDPSPDTEST_GENL_CMD_INIT;
            resp_msg->status = udpspd_sock_mgr_init();
            break;

        case UDPSPDTEST_GENL_CMD_UNINIT:
            resp_msg->cmd = UDPSPDTEST_GENL_CMD_UNINIT;
            resp_msg->status = udpspd_sock_mgr_uninit();
            break;

        default:
        	resp_msg->status = -1;
        	break;
    }
    resp_msg->stream_idx = req_msg->stream_idx;
}

/* Send response msg */
static int send_resp_cmd_own_msg(tcpspdtest_genl_resp_msg_t *resp_msg, struct genl_info *info)
{
    struct sk_buff *resp_skb;
    void *msg_head;
    int rc;

    /* Allocate netlink message buffer */
    resp_skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
    if (NULL == resp_skb)
    {
        tc_err("GENL Failed to allocate resp skb\n");
        return -ENOMEM;
    }

    /* Create the message headers */
    msg_head = genlmsg_put(resp_skb, 0, info->snd_seq+1, &genl_family, 0, TCPSPDTEST_GENL_FAMILY_MSG_OWN_MSG);
    if (NULL == msg_head)
    {
        tc_err("GENL Failed to add GENL header\n");
        return -ENOMEM;
    }

    /* Add resp msg */
    rc = nla_put(resp_skb, TCPSPDTEST_GENL_POLICY_OWN_MSG, sizeof(*resp_msg), (void *)resp_msg);
    if (rc)
    {
        tc_err("GENL Failed to add GENL resp msg\n");
        return rc;
    }

    /* Finalize the message */
    genlmsg_end(resp_skb, msg_head);

    /* Send resp msg and free message */
    return genlmsg_reply(resp_skb, info);
}

/* Received req command own message, handle it and sends reply message back */
static int recv_req_cmd_own_msg(struct sk_buff *skb, struct genl_info *info)
{
    struct nlattr *nl_attr;
    tcpspdtest_genl_req_msg_t *req_msg;
    tcpspdtest_genl_resp_msg_t resp_msg = {};
    (void)skb; /* genl_ops.doit cb prototype. skb currently not in use */

    if (NULL == info)
    {
        tc_err("Received NULL GENL info\n");
        return -1;
    }

    /* get GENL attribute */
    nl_attr = info->attrs[TCPSPDTEST_GENL_POLICY_OWN_MSG];
    if (NULL == nl_attr)
    {
        tc_err("Received NULL GENL %d attribute\n", TCPSPDTEST_GENL_POLICY_OWN_MSG);
        return -1;
    }

    /* get recv req cmd str */
    req_msg = (tcpspdtest_genl_req_msg_t *)nla_data(nl_attr);
    if (NULL == req_msg)
    {
        tc_err("Received NULL GENL message\n");
        return -1;
	}

    handle_req_own_msg(req_msg, &resp_msg, info);

    switch (req_msg->cmd)
    {
        case TCPSPDTEST_GENL_CMD_DISCONNECT:
        case TCPSPDTEST_GENL_CMD_RELEASE:
            return 0; /* No response */

        case TCPSPDTEST_GENL_CMD_STREAM_IDX:
            if (TCPSPDTEST_GENL_CMD_PARAM_FREE == req_msg->cmd_param)
                return 0;  /* No response */
            break;

        case TCPSPDTEST_GENL_CMD_SPEED_REPORT:
            if (TCPSPDTEST_GENL_CMD_PARAM_BLOCKING_END_OF_TEST == req_msg->cmd_param)
            {
                /* No speed report response now, just send pending event if have */
                tcpspd_genl_send_pending_event(req_msg->stream_idx);
                return 0; 
            }
            break;

        default:
        	break;
    }

    /* Send reponse message */
    return send_resp_cmd_own_msg(&resp_msg, info);
}

/* Send speed report message to client */
int tcpspd_genl_send_speed_report_msg(uint8_t stream_idx, tcp_spdt_rep_t *spd_report, tcpspdtest_genl_cmd_status_t status)
{
    tcpspdtest_genl_resp_msg_t resp_msg;

    if (NULL == client_info_p[stream_idx])
    {
        tc_err("[%hhu] Failed to send asynchronuous message, client info NULL !\n", stream_idx);
        return -1;
    }

    resp_msg.cmd = TCPSPDTEST_GENL_CMD_SPEED_REPORT;
    resp_msg.stream_idx = stream_idx;
    memcpy(&resp_msg.msg.spd_report, spd_report, sizeof(resp_msg.msg.spd_report));
    resp_msg.msg.spd_report.status = status;
    resp_msg.status = 0;

    return send_resp_cmd_own_msg(&resp_msg, client_info_p[stream_idx]);
}

static int store_event(uint8_t stream_idx, tcp_spdt_rep_t *spd_report, tcpspdtest_genl_cmd_status_t status)
{
    if (event_p[stream_idx] == NULL)
    { 
        event_p[stream_idx] = kmalloc(sizeof(struct event_struct), GFP_KERNEL);
        if (!event_p[stream_idx]) 
        {
            tc_err("[%hhu] Failed to allocate event memory!\n", stream_idx);
            return -1;
        }
    }

    /* only save last event */
    memcpy(&(event_p[stream_idx]->spd_report), spd_report, sizeof (tcp_spdt_rep_t));
    event_p[stream_idx]->status = status;

    tc_debug("[%hhu] store event, type=%d\n", stream_idx, status);
    return 0;
}

int tcpspd_genl_clear_event(uint8_t stream_idx)
{      
    if (event_p[stream_idx] != NULL)
    {
        tc_debug("[%hhu] del event, type=%d\n", stream_idx, event_p[stream_idx]->status);
        kfree(event_p[stream_idx]);
        event_p[stream_idx] = NULL;
    }

    return 0;
}

int tcpspd_genl_send_event(uint8_t stream_idx, tcp_spdt_rep_t *spd_report, tcpspdtest_genl_cmd_status_t status)
{
    int rc;

    if (g_tcpspd[stream_idx].end_of_test_spd_report)
    {
        rc = tcpspd_genl_send_speed_report_msg(stream_idx, spd_report, status);
    }
    else
    {
        rc = store_event(stream_idx, spd_report, status);
    }

    return rc;
}

int tcpspd_genl_send_pending_event(uint8_t stream_idx)
{
    if (event_p[stream_idx] == NULL)
        return 0;

    if (tcpspd_genl_send_speed_report_msg(stream_idx, &(event_p[stream_idx]->spd_report), event_p[stream_idx]->status) == 0)
    {
        tc_debug("[%hhu] send pending event, type=%d\n", stream_idx, event_p[stream_idx]->status);
        kfree(event_p[stream_idx]);
        event_p[stream_idx] = NULL;
    }
    else
    {
        tc_err("[%hhu] Failed to send pending event, type=%d\n", stream_idx, event_p[stream_idx]->status);
        return -1;
    }

    return 0;
}

/* Init GENL with new family for tcpspdtest */
int tcpspd_genl_init(void)
{
    int rc;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0))
    /* Register the new family and ops (commands) */
    rc = genl_register_family_with_ops(&genl_family, genl_ops);
    if (rc)
    {
        tc_err("Failed to register TCPSPDTEST GENL family with ops: %d\n", rc);
        return rc;
    }
#else
    rc = genl_register_family(&genl_family);
    if (rc)
    {
        tc_err("Failed to register TCPSPDTEST GENL family: %d\n", rc);
        return rc;
    }
#endif

    memset(client_info_p, 0, sizeof(client_info_p));
    memset(event_p, 0, sizeof(event_p));

    tc_info("TCPSPDTEST GENL registered Successfully\n");

    return 0;
}

int tcpspd_genl_shutdown(void)
{
    int rc;

    memset(client_info_p, 0, sizeof(client_info_p));

    /* Unregister the family */
    rc = genl_unregister_family(&genl_family);
    if(rc)
    {
        tc_err("Failed to unregister TCPSPDTEST GENL family: %d\n", rc);
        return -1;
    }

    tc_info("TCPSPDTEST GENL unregistered Successfully\n");

    return 0;
}
