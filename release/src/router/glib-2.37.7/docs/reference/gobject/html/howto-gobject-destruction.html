<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>GObject Reference Manual: Object Destruction</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="index.html" title="GObject Reference Manual">
<link rel="up" href="howto-gobject.html" title="How to define and implement a new GObject">
<link rel="prev" href="howto-gobject-construction.html" title="Object Construction">
<link rel="next" href="howto-gobject-methods.html" title="Object methods">
<meta name="generator" content="GTK-Doc V1.19.1 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="10"><tr valign="middle">
<td width="100%" align="left"></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="16" height="16" border="0" alt="Home"></a></td>
<td><a accesskey="u" href="howto-gobject.html"><img src="up.png" width="16" height="16" border="0" alt="Up"></a></td>
<td><a accesskey="p" href="howto-gobject-construction.html"><img src="left.png" width="16" height="16" border="0" alt="Prev"></a></td>
<td><a accesskey="n" href="howto-gobject-methods.html"><img src="right.png" width="16" height="16" border="0" alt="Next"></a></td>
</tr></table>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="howto-gobject-destruction"></a>Object Destruction</h2></div></div></div>
<p>
      Again, it is often difficult to figure out which mechanism to use to
      hook into the object's destruction process: when the last
      <code class="function"><a class="link" href="gobject-The-Base-Object-Type.html#g-object-unref" title="g_object_unref ()">g_object_unref</a></code>
      function call is made, a lot of things happen as described in
      <a class="xref" href="gobject-memory.html#gobject-destruction-table" title="Table 5. g_object_unref">Table 5, “g_object_unref”</a>.
    </p>
<p>
      The destruction process of your object might be split in two different
      phases: dispose and the finalize. This split is necessary to handle
      potential cycles due to the nature of the reference counting mechanism
      used by GObject, as well as dealing with temporary vivification of
      instances in case of signal emission during the destruction sequence.
</p>
<pre class="programlisting">
struct _MamanBarPrivate
{
  GObject *an_object;

  gchar *a_string;
};

G_DEFINE_TYPE_WITH_PRIVATE (MamanBar, maman_bar, G_TYPE_OBJECT)

static void
maman_bar_dispose (GObject *gobject)
{
  MamanBar *self = MAMAN_BAR (gobject);

  /* In dispose(), you are supposed to free all types referenced from this
   * object which might themselves hold a reference to self. Generally,
   * the most simple solution is to unref all members on which you own a 
   * reference.
   */

  /* dispose() might be called multiple times, so we must guard against
   * calling g_object_unref() on an invalid GObject by setting the member
   * NULL; g_clear_object() does this for us, atomically.
   */
  g_clear_object (&amp;self-&gt;priv-&gt;an_object);

  /* Always chain up to the parent class; there is no need to check if
   * the parent class implements the dispose() virtual function: it is
   * always guaranteed to do so
   */
  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;dispose (gobject);
}

static void
maman_bar_finalize (GObject *gobject)
{
  MamanBar *self = MAMAN_BAR (gobject);

  g_free (self-&gt;priv-&gt;a_string);

  /* Always chain up to the parent class; as with dispose(), finalize()
   * is guaranteed to exist on the parent's class virtual function table
   */
  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;finalize (gobject);
}

static void
maman_bar_class_init (MamanBarClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class-&gt;dispose = maman_bar_dispose;
  gobject_class-&gt;finalize = maman_bar_finalize;
}

static void
maman_bar_init (MamanBar *self);
{
  self-&gt;priv = maman_bar_get_instance_private (self); 

  self-&gt;priv-&gt;an_object = g_object_new (MAMAN_TYPE_BAZ, NULL);
  self-&gt;priv-&gt;a_string = g_strdup ("Maman");
}
</pre>
<p>
    </p>
<p>
      It is possible that object methods might be invoked after dispose is
      run and before finalize runs. GObject does not consider this to be a
      program error: you must gracefully detect this and neither crash nor
      warn the user, by having a disposed instance revert to an inhert state.
    </p>
</div>
<div class="footer">
<hr>
          Generated by GTK-Doc V1.19.1</div>
</body>
</html>