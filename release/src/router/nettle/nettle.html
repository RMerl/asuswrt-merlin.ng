<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is for the Nettle library (version 3.4), a
low-level cryptographic library.

Originally written 2001 by Niels MÃ¶ller, updated 2017.

This manual is placed in the public domain. You may freely copy it, in
whole or in part, with or without modification. Attribution is
appreciated, but not required. -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Nettle: a low-level cryptographic library</title>

<meta name="description" content="Nettle: a low-level cryptographic library">
<meta name="keywords" content="Nettle: a low-level cryptographic library">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Index" rel="index" title="Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">Nettle: a low-level cryptographic library</h1>






<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a id="toc-Copyright-1" href="#Copyright">2 Copyright</a></li>
  <li><a id="toc-Conventions-1" href="#Conventions">3 Conventions</a></li>
  <li><a id="toc-Example-1" href="#Example">4 Example</a></li>
  <li><a id="toc-Linking-1" href="#Linking">5 Linking</a></li>
  <li><a id="toc-Compatibility-1" href="#Compatibility">6 Compatibility</a></li>
  <li><a id="toc-Reference-1" href="#Reference">7 Reference</a>
  <ul class="no-bullet">
    <li><a id="toc-Hash-functions-1" href="#Hash-functions">7.1 Hash functions</a>
    <ul class="no-bullet">
      <li><a id="toc-Recommended-hash-functions-1" href="#Recommended-hash-functions">7.1.1 Recommended hash functions</a>
      <ul class="no-bullet">
        <li><a id="toc-SHA256" href="#SHA256">7.1.1.1 <acronym>SHA256</acronym></a></li>
        <li><a id="toc-SHA224" href="#SHA224">7.1.1.2 <acronym>SHA224</acronym></a></li>
        <li><a id="toc-SHA512" href="#SHA512">7.1.1.3 <acronym>SHA512</acronym></a></li>
        <li><a id="toc-SHA384-and-other-variants-of-SHA512" href="#SHA384-and-other-variants-of-SHA512">7.1.1.4 <acronym>SHA384 and other variants of SHA512</acronym></a></li>
        <li><a id="toc-SHA3_002d224" href="#SHA3_002d224">7.1.1.5 <acronym>SHA3-224</acronym></a></li>
        <li><a id="toc-SHA3_002d256" href="#SHA3_002d256">7.1.1.6 <acronym>SHA3-256</acronym></a></li>
        <li><a id="toc-SHA3_002d384" href="#SHA3_002d384">7.1.1.7 <acronym>SHA3-384</acronym></a></li>
        <li><a id="toc-SHA3_002d512" href="#SHA3_002d512">7.1.1.8 <acronym>SHA3-512</acronym></a></li>
        <li><a id="toc-SHAKE_002d256" href="#SHAKE_002d256">7.1.1.9 <acronym>SHAKE-256</acronym></a></li>
      </ul></li>
      <li><a id="toc-Miscellaneous-hash-functions-1" href="#Miscellaneous-hash-functions">7.1.2 Miscellaneous hash functions</a>
      <ul class="no-bullet">
        <li><a id="toc-STREEBOG512" href="#STREEBOG512">7.1.2.1 <acronym>STREEBOG512</acronym></a></li>
        <li><a id="toc-STREEBOG256" href="#STREEBOG256">7.1.2.2 <acronym>STREEBOG256</acronym></a></li>
        <li><a id="toc-SM3" href="#SM3">7.1.2.3 <acronym>SM3</acronym></a></li>
      </ul></li>
      <li><a id="toc-Legacy-hash-functions-1" href="#Legacy-hash-functions">7.1.3 Legacy hash functions</a>
      <ul class="no-bullet">
        <li><a id="toc-MD5" href="#MD5">7.1.3.1 <acronym>MD5</acronym></a></li>
        <li><a id="toc-MD2" href="#MD2">7.1.3.2 <acronym>MD2</acronym></a></li>
        <li><a id="toc-MD4" href="#MD4">7.1.3.3 <acronym>MD4</acronym></a></li>
        <li><a id="toc-RIPEMD160" href="#RIPEMD160">7.1.3.4 <acronym>RIPEMD160</acronym></a></li>
        <li><a id="toc-SHA1" href="#SHA1">7.1.3.5 <acronym>SHA1</acronym></a></li>
        <li><a id="toc-GOSTHASH94-and-GOSTHASH94CP" href="#GOSTHASH94-and-GOSTHASH94CP">7.1.3.6 <acronym>GOSTHASH94 and GOSTHASH94CP</acronym></a></li>
      </ul></li>
      <li><a id="toc-The-struct-nettle_005fhash-abstraction" href="#nettle_005fhash-abstraction">7.1.4 The <code>struct nettle_hash</code> abstraction</a></li>
    </ul></li>
    <li><a id="toc-Cipher-functions-1" href="#Cipher-functions">7.2 Cipher functions</a>
    <ul class="no-bullet">
      <li><a id="toc-AES-1" href="#AES">7.2.1 AES</a></li>
      <li><a id="toc-Arcfour-1" href="#Arcfour">7.2.2 Arcfour</a></li>
      <li><a id="toc-Arctwo-1" href="#Arctwo">7.2.3 Arctwo</a></li>
      <li><a id="toc-Blowfish-1" href="#Blowfish">7.2.4 Blowfish</a></li>
      <li><a id="toc-Camellia-1" href="#Camellia">7.2.5 Camellia</a></li>
      <li><a id="toc-CAST128-1" href="#CAST128">7.2.6 CAST128</a></li>
      <li><a id="toc-ChaCha-1" href="#ChaCha">7.2.7 ChaCha</a>
      <ul class="no-bullet">
        <li><a id="toc-32_002dbit-counter-variant" href="#g_t32_002dbit-counter-variant">7.2.7.1 32-bit counter variant</a></li>
      </ul></li>
      <li><a id="toc-DES-1" href="#DES">7.2.8 DES</a></li>
      <li><a id="toc-DES3-1" href="#DES3">7.2.9 DES3</a></li>
      <li><a id="toc-Salsa20-1" href="#Salsa20">7.2.10 Salsa20</a></li>
      <li><a id="toc-Serpent-1" href="#Serpent">7.2.11 Serpent</a></li>
      <li><a id="toc-Twofish-1" href="#Twofish">7.2.12 Twofish</a></li>
      <li><a id="toc-The-struct-nettle_005fcipher-abstraction" href="#nettle_005fcipher-abstraction">7.2.13 The <code>struct nettle_cipher</code> abstraction</a></li>
    </ul></li>
    <li><a id="toc-Cipher-modes-1" href="#Cipher-modes">7.3 Cipher modes</a>
    <ul class="no-bullet">
      <li><a id="toc-Cipher-Block-Chaining" href="#CBC">7.3.1 Cipher Block Chaining</a>
      <ul class="no-bullet">
        <li><a id="toc-Utility-macros" href="#Utility-macros">7.3.1.1 Utility macros</a></li>
        <li><a id="toc-Cipher_002dspecific-functions" href="#Cipher_002dspecific-functions">7.3.1.2 Cipher-specific functions</a></li>
      </ul></li>
      <li><a id="toc-Counter-mode" href="#CTR">7.3.2 Counter mode</a></li>
      <li><a id="toc-Cipher-Feedback-mode" href="#CFB-and-CFB8">7.3.3 Cipher Feedback mode</a></li>
      <li><a id="toc-XEX_002dbased-tweaked_002dcodebook-mode-with-ciphertext-stealing" href="#XTS">7.3.4 XEX-based tweaked-codebook mode with ciphertext stealing</a>
      <ul class="no-bullet">
        <li><a id="toc-General-_0028XTS_0029-interface_002e" href="#General-_0028XTS_0029-interface_002e">7.3.4.1 General (<acronym>XTS</acronym>) interface.</a></li>
        <li><a id="toc-XTS_002dAES-interface" href="#XTS_002dAES-interface">7.3.4.2 <acronym>XTS</acronym>-<acronym>AES</acronym> interface</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Authenticated-encryption-with-associated-data" href="#Authenticated-encryption">7.4 Authenticated encryption with associated data</a>
    <ul class="no-bullet">
      <li><a id="toc-EAX-1" href="#EAX">7.4.1 EAX</a>
      <ul class="no-bullet">
        <li><a id="toc-General-EAX-interface" href="#General-EAX-interface">7.4.1.1 General <acronym>EAX</acronym> interface</a></li>
        <li><a id="toc-EAX-helper-macros" href="#EAX-helper-macros">7.4.1.2 <acronym>EAX</acronym> helper macros</a></li>
        <li><a id="toc-EAX_002dAES128-interface" href="#EAX_002dAES128-interface">7.4.1.3 <acronym>EAX</acronym>-<acronym>AES</acronym>128 interface</a></li>
      </ul></li>
      <li><a id="toc-Galois-counter-mode" href="#GCM">7.4.2 Galois counter mode</a>
      <ul class="no-bullet">
        <li><a id="toc-General-GCM-interface" href="#General-GCM-interface">7.4.2.1 General <acronym>GCM</acronym> interface</a></li>
        <li><a id="toc-GCM-helper-macros" href="#GCM-helper-macros">7.4.2.2 <acronym>GCM</acronym> helper macros</a></li>
        <li><a id="toc-GCM_002dAES-interface" href="#GCM_002dAES-interface">7.4.2.3 <acronym>GCM</acronym>-<acronym>AES</acronym> interface</a></li>
        <li><a id="toc-GCM_002dCamellia-interface" href="#GCM_002dCamellia-interface">7.4.2.4 <acronym>GCM</acronym>-Camellia interface</a></li>
      </ul></li>
      <li><a id="toc-Counter-with-CBC_002dMAC-mode" href="#CCM">7.4.3 Counter with CBC-MAC mode</a>
      <ul class="no-bullet">
        <li><a id="toc-General-CCM-interface" href="#General-CCM-interface">7.4.3.1 General <acronym>CCM</acronym> interface</a></li>
        <li><a id="toc-CCM-message-interface" href="#CCM-message-interface">7.4.3.2 <acronym>CCM</acronym> message interface</a></li>
        <li><a id="toc-CCM_002dAES-interface" href="#CCM_002dAES-interface">7.4.3.3 <acronym>CCM</acronym>-<acronym>AES</acronym> interface</a></li>
      </ul></li>
      <li><a id="toc-ChaCha_002dPoly1305-1" href="#ChaCha_002dPoly1305">7.4.4 ChaCha-Poly1305</a></li>
      <li><a id="toc-Synthetic-Initialization-Vector-AEAD" href="#SIV_002dCMAC">7.4.5 Synthetic Initialization Vector AEAD</a>
      <ul class="no-bullet">
        <li><a id="toc-General-interface" href="#General-interface">7.4.5.1 General interface</a></li>
        <li><a id="toc-SIV_002dCMAC_002dAES-interface" href="#SIV_002dCMAC_002dAES-interface">7.4.5.2 <acronym>SIV-CMAC</acronym>-<acronym>AES</acronym> interface</a></li>
      </ul></li>
      <li><a id="toc-The-struct-nettle_005faead-abstraction" href="#nettle_005faead-abstraction">7.4.6 The <code>struct nettle_aead</code> abstraction</a></li>
    </ul></li>
    <li><a id="toc-Keyed-Hash-Functions" href="#Keyed-hash-functions">7.5 Keyed Hash Functions</a>
    <ul class="no-bullet">
      <li><a id="toc-HMAC-1" href="#HMAC">7.5.1 <acronym>HMAC</acronym></a>
      <ul class="no-bullet">
        <li><a id="toc-HMAC_002dMD5" href="#HMAC_002dMD5">7.5.1.1 <acronym>HMAC-MD5</acronym></a></li>
        <li><a id="toc-HMAC_002dRIPEMD160" href="#HMAC_002dRIPEMD160">7.5.1.2 <acronym>HMAC-RIPEMD160</acronym></a></li>
        <li><a id="toc-HMAC_002dSHA1" href="#HMAC_002dSHA1">7.5.1.3 <acronym>HMAC-SHA1</acronym></a></li>
        <li><a id="toc-HMAC_002dSHA256" href="#HMAC_002dSHA256">7.5.1.4 <acronym>HMAC-SHA256</acronym></a></li>
        <li><a id="toc-HMAC_002dSHA512" href="#HMAC_002dSHA512">7.5.1.5 <acronym>HMAC-SHA512</acronym></a></li>
        <li><a id="toc-HMAC_002dSM3" href="#HMAC_002dSM3">7.5.1.6 <acronym>HMAC-SM3</acronym></a></li>
      </ul></li>
      <li><a id="toc-UMAC-1" href="#UMAC">7.5.2 <acronym>UMAC</acronym></a></li>
      <li><a id="toc-CMAC-1" href="#CMAC">7.5.3 <acronym>CMAC</acronym></a></li>
      <li><a id="toc-Poly1305-1" href="#Poly1305">7.5.4 Poly1305</a></li>
    </ul></li>
    <li><a id="toc-Key-derivation-Functions" href="#Key-derivation-functions">7.6 Key derivation Functions</a>
    <ul class="no-bullet">
      <li><a id="toc-HKDF_003a-HMAC_002dbased-Extract_002dand_002dExpand" href="#HKDF_003a-HMAC_002dbased-Extract_002dand_002dExpand">7.6.1 HKDF: HMAC-based Extract-and-Expand</a></li>
      <li><a id="toc-PBKDF2" href="#PBKDF2">7.6.2 <acronym>PBKDF2</acronym></a></li>
      <li><a id="toc-Concrete-PBKDF2-functions" href="#Concrete-PBKDF2-functions">7.6.3 Concrete <acronym>PBKDF2</acronym> functions</a>
      <ul class="no-bullet">
        <li><a id="toc-PBKDF2_002dHMAC_002dSHA1" href="#PBKDF2_002dHMAC_002dSHA1">7.6.3.1 <acronym>PBKDF2-HMAC-SHA1</acronym></a></li>
        <li><a id="toc-PBKDF2_002dHMAC_002dSHA256" href="#PBKDF2_002dHMAC_002dSHA256">7.6.3.2 <acronym>PBKDF2-HMAC-SHA256</acronym></a></li>
        <li><a id="toc-PBKDF2_002dHMAC_002dSHA384" href="#PBKDF2_002dHMAC_002dSHA384">7.6.3.3 <acronym>PBKDF2-HMAC-SHA384</acronym></a></li>
        <li><a id="toc-PBKDF2_002dHMAC_002dSHA512" href="#PBKDF2_002dHMAC_002dSHA512">7.6.3.4 <acronym>PBKDF2-HMAC-SHA512</acronym></a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Public_002dkey-algorithms-1" href="#Public_002dkey-algorithms">7.7 Public-key algorithms</a>
    <ul class="no-bullet">
      <li><a id="toc-RSA-1" href="#RSA">7.7.1 <acronym>RSA</acronym></a>
      <ul class="no-bullet">
        <li><a id="toc-Nettle_0027s-RSA-support" href="#Nettle_0027s-RSA-support">7.7.1.1 Nettle&rsquo;s <acronym>RSA</acronym> support</a></li>
      </ul></li>
      <li><a id="toc-DSA-1" href="#DSA">7.7.2 <acronym>DSA</acronym></a>
      <ul class="no-bullet">
        <li><a id="toc-Nettle_0027s-DSA-support" href="#Nettle_0027s-DSA-support">7.7.2.1 Nettle&rsquo;s <acronym>DSA</acronym> support</a></li>
        <li><a id="toc-Old_002c-deprecated_002c-DSA-interface" href="#Old_002c-deprecated_002c-DSA-interface">7.7.2.2 Old, deprecated, <acronym>DSA</acronym> interface</a></li>
      </ul></li>
      <li><a id="toc-Elliptic-curves-1" href="#Elliptic-curves">7.7.3 Elliptic curves</a>
      <ul class="no-bullet">
        <li><a id="toc-Side_002dchannel-silence-1" href="#Side_002dchannel-silence">7.7.3.1 Side-channel silence</a></li>
        <li><a id="toc-ECDSA-1" href="#ECDSA">7.7.3.2 ECDSA</a></li>
        <li><a id="toc-GOSTDSA-1" href="#GOSTDSA">7.7.3.3 GOSTDSA</a></li>
        <li><a id="toc-Curve25519-and-Curve448" href="#Curve-25519-and-Curve-448">7.7.3.4 Curve25519 and Curve448</a></li>
        <li><a id="toc-EdDSA" href="#EdDSA">7.7.3.5 EdDSA</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Randomness-1" href="#Randomness">7.8 Randomness</a>
    <ul class="no-bullet">
      <li><a id="toc-Yarrow" href="#Yarrow">7.8.1 Yarrow</a></li>
    </ul></li>
    <li><a id="toc-ASCII-encoding-1" href="#ASCII-encoding">7.9 ASCII encoding</a></li>
    <li><a id="toc-Miscellaneous-functions-1" href="#Miscellaneous-functions">7.10 Miscellaneous functions</a></li>
    <li><a id="toc-Compatibility-functions-1" href="#Compatibility-functions">7.11 Compatibility functions</a></li>
  </ul></li>
  <li><a id="toc-Traditional-Nettle-Soup" href="#Nettle-soup">8 Traditional Nettle Soup</a></li>
  <li><a id="toc-Installation-1" href="#Installation">9 Installation</a></li>
  <li><a id="toc-Function-and-Concept-Index" href="#Index" rel="index">Function and Concept Index</a></li>
</ul>
</div>


<span id="Top"></span><div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Nettle"></span><h1 class="top">Nettle</h1>

<p>This document describes the Nettle low-level cryptographic library. You
can use the library directly from your C programs, or write or use an
object-oriented wrapper for your favorite language or application.
</p>
<p>This manual is for the Nettle library (version 3.4), a
low-level cryptographic library.
</p>
<p>Originally written 2001 by Niels MÃ¶ller, updated 2017.
</p>
<blockquote>
<p>This manual is placed in the public domain. You may freely copy it, in
whole or in part, with or without modification. Attribution is
appreciated, but not required.
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">What is Nettle?
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Copyright" accesskey="2">Copyright</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Your rights.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conventions" accesskey="3">Conventions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">General interface conventions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example" accesskey="4">Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">An example program.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linking" accesskey="5">Linking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Linking with libnettle and libhogweed.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility" accesskey="6">Compatibility</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">On API and ABI compatibility between versions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference" accesskey="7">Reference</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">All Nettle functions and features.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nettle-soup" accesskey="8">Nettle soup</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">For the serious nettle hacker.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installation" accesskey="9">Installation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to install Nettle.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Index" rel="index">Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Function and concept index.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment"> &mdash; The Detailed Node Listing &mdash;

Reference

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Hash-functions">Hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cipher-functions">Cipher functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cipher-modes">Cipher modes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Authenticated-encryption">Authenticated encryption</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Keyed-hash-functions">Keyed hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Key-derivation-functions">Key derivation functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Public_002dkey-algorithms">Public-key algorithms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Randomness">Randomness</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ASCII-encoding">ASCII encoding</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-functions">Miscellaneous functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-functions">Compatibility functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Hash functions

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Recommended-hash-functions">Recommended hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Legacy-hash-functions">Legacy hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005fhash-abstraction">nettle_hash abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Cipher functions

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#AES">AES</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Arcfour">Arcfour</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Arctwo">Arctwo</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Blowfish">Blowfish</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Camellia">Camellia</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CAST128">CAST128</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ChaCha">ChaCha</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DES">DES</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DES3">DES3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Salsa20">Salsa20</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Serpent">Serpent</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Twofish">Twofish</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Cipher modes

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#CBC">CBC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CTR">CTR</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CFB-and-CFB8">CFB and CFB8</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#XTS">XTS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Authenticated encryption with associated data

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#EAX">EAX</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GCM">GCM</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CCM">CCM</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SIV_002dCMAC">SIV-CMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005faead-abstraction">nettle_aead abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Keyed Hash Functions

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#HMAC">HMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UMAC">UMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CMAC">CMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Poly1305">Poly1305</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Public-key algorithms

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#RSA">RSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The RSA public key algorithm.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DSA">DSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The DSA digital signature algorithm.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Elliptic-curves">Elliptic curves</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Elliptic curves and ECDSA
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Elliptic curves

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Side_002dchannel-silence">Side-channel silence</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ECDSA">ECDSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GOSTDSA">GOSTDSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></table>


<hr>
<span id="Introduction"></span><div class="header">
<p>
Next: <a href="#Copyright" accesskey="n" rel="next">Copyright</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction-1"></span><h2 class="chapter">1 Introduction</h2>

<p>Nettle is a cryptographic library that is designed to fit easily in more
or less any context: In crypto toolkits for object-oriented languages
(C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in
kernel space. In most contexts, you need more than the basic
cryptographic algorithms, you also need some way to keep track of available
algorithms, their properties and variants. You often have some algorithm
selection process, often dictated by a protocol you want to implement.
</p>
<p>And as the requirements of applications differ in subtle and not so
subtle ways, an API that fits one application well can be a pain to use
in a different context. And that is why there are so many different
cryptographic libraries around.
</p>
<p>Nettle tries to avoid this problem by doing one thing, the low-level
crypto stuff, and providing a <em>simple</em> but general interface to it.
In particular, Nettle doesn&rsquo;t do algorithm selection. It doesn&rsquo;t do
memory allocation. It doesn&rsquo;t do any I/O.
</p>
<p>The idea is that one can build several application and context specific
interfaces on top of Nettle, and share the code, test cases, benchmarks,
documentation, etc. Examples are the Nettle module for the Pike
language, and LSH, which both use an object-oriented abstraction on top
of the library.
</p>
<p>This manual explains how to use the Nettle library. It also tries to
provide some background on the cryptography, and advice on how to best
put it to use.
</p>
<hr>
<span id="Copyright"></span><div class="header">
<p>
Next: <a href="#Conventions" accesskey="n" rel="next">Conventions</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Copyright-1"></span><h2 class="chapter">2 Copyright</h2>

<p>Nettle is dual licenced under the GNU General Public License version 2
or later, and the GNU Lesser General Public License version 3 or later.
When using Nettle, you must comply fully with all conditions of at least
one of these licenses. A few of the individual files are licensed under
more permissive terms, or in the public domain. To find the current
status of particular files, you have to read the copyright notices at
the top of the files.
</p>
<p>This manual is in the public domain. You may freely copy it in whole or
in part, e.g., into documentation of programs that build on Nettle.
Attribution, as well as contribution of improvements to the text, is of
course appreciated, but it is not required.
</p>
<hr>
<span id="Conventions"></span><div class="header">
<p>
Next: <a href="#Example" accesskey="n" rel="next">Example</a>, Previous: <a href="#Copyright" accesskey="p" rel="prev">Copyright</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Conventions-1"></span><h2 class="chapter">3 Conventions</h2>

<p>For each supported algorithm, there is an include file that defines a
<em>context struct</em>, a few constants, and declares functions for
operating on the context. The context struct encapsulates all information
needed by the algorithm, and it can be copied or moved in memory with no
unexpected effects.
</p>
<p>For consistency, functions for different algorithms are very similar,
but there are some differences, for instance reflecting if the key setup
or encryption function differ for encryption and decryption, and whether
or not key setup can fail. There are also differences between algorithms
that don&rsquo;t show in function prototypes, but which the application must
nevertheless be aware of. There is no big difference between the
functions for stream ciphers and for block ciphers, although they should
be used quite differently by the application.
</p>
<p>If your application uses more than one algorithm of the same type, you
should probably create an interface that is tailor-made for your needs,
and then write a few lines of glue code on top of Nettle.
</p>
<p>By convention, for an algorithm named <code>foo</code>, the struct tag for the
context struct is <code>foo_ctx</code>, constants and functions uses prefixes
like <code>FOO_BLOCK_SIZE</code> (a constant) and <code>foo_set_key</code> (a
function).
</p>
<p>In all functions, strings are represented with an explicit length, of
type <code>size_t</code>, and a pointer of type <code>uint8_t *</code> or
<code>const uint8_t *</code>. For functions that transform one string to
another, the argument order is length, destination pointer and source
pointer. Source and destination areas are usually of the same length.
When they differ, e.g., for <code>ccm_encrypt_message</code>, the length
argument specifies the size of the destination area. Source and
destination pointers may be equal, so that you can process strings in
place, but source and destination areas <em>must not</em> overlap in any
other way.
</p>
<p>Many of the functions lack return value and can never fail. Those
functions which can fail, return one on success and zero on failure.
</p>

<hr>
<span id="Example"></span><div class="header">
<p>
Next: <a href="#Linking" accesskey="n" rel="next">Linking</a>, Previous: <a href="#Conventions" accesskey="p" rel="prev">Conventions</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Example-1"></span><h2 class="chapter">4 Example</h2>

<p>A simple example program that reads a file from standard input and
writes its SHA1 check-sum on standard output should give the flavor of
Nettle.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;nettle/sha1.h&gt;

#define BUF_SIZE 1000

static void
display_hex(unsigned length, uint8_t *data)
{
  unsigned i;

  for (i = 0; i&lt;length; i++)
    printf(&quot;%02x &quot;, data[i]);

  printf(&quot;\n&quot;);
}

int
main(int argc, char **argv)
{
  struct sha1_ctx ctx;
  uint8_t buffer[BUF_SIZE];
  uint8_t digest[SHA1_DIGEST_SIZE];
  
  sha1_init(&amp;ctx);
  for (;;)
  {
    int done = fread(buffer, 1, sizeof(buffer), stdin);
    sha1_update(&amp;ctx, done, buffer);
    if (done &lt; sizeof(buffer))
      break;
  }
  if (ferror(stdin))
    return EXIT_FAILURE;

  sha1_digest(&amp;ctx, SHA1_DIGEST_SIZE, digest);

  display_hex(SHA1_DIGEST_SIZE, digest);
  return EXIT_SUCCESS;  
}
</pre></div>

<p>On a typical Unix system, this program can be compiled and linked with
the command line 
</p><div class="example">
<pre class="example">gcc sha-example.c -o sha-example -lnettle
</pre></div>

<hr>
<span id="Linking"></span><div class="header">
<p>
Next: <a href="#Compatibility" accesskey="n" rel="next">Compatibility</a>, Previous: <a href="#Example" accesskey="p" rel="prev">Example</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Linking-1"></span><h2 class="chapter">5 Linking</h2>

<p>Nettle actually consists of two libraries, <samp>libnettle</samp> and
<samp>libhogweed</samp>. The <samp>libhogweed</samp> library contains those
functions of Nettle that uses bignum operations, and depends on the GMP
library. With this division, linking works the same for both static and
dynamic libraries.
</p>
<p>If an application uses only the symmetric crypto algorithms of Nettle
(i.e., block ciphers, hash functions, and the like), it&rsquo;s sufficient to
link with <code>-lnettle</code>. If an application also uses public-key
algorithms, the recommended linker flags are <code>-lhogweed -lnettle
-lgmp</code>. If the involved libraries are installed as dynamic libraries, it
may be sufficient to link with just <code>-lhogweed</code>, and the loader
will resolve the dependencies automatically.
</p>
<hr>
<span id="Compatibility"></span><div class="header">
<p>
Next: <a href="#Reference" accesskey="n" rel="next">Reference</a>, Previous: <a href="#Linking" accesskey="p" rel="prev">Linking</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compatibility-1"></span><h2 class="chapter">6 Compatibility</h2>
<span id="index-ABI-compatibility"></span>
<span id="index-API-compatibility"></span>
<span id="index-Binary-compatibility"></span>

<p>When you write a program using the Nettle library, it&rsquo;s desirable to
have it work together not only with exactly the same version of Nettle
you had at hand, but with other current and future versions. If a
different version of Nettle is used at compile time, i.e., you recompile
it using the header and library files belonging to a different version,
we talk about API compatibility (for Application Programming Interface).
If a different version of Nettle isn&rsquo;t used until link time, we talk
about ABI compatibility (Application Binary Interface) or binary
compatibility. ABI compatibility matters mainly when using dynamic
linking with a shared library. E.g., a user has an executable linking at
run-time with <samp>libnettle.so</samp>, and then updates to a later version
of the shared library, without updating or recompiling the executable.
</p>
<p>Nettle aims to provide backwards compatibility, i.e., a program written
for a particular version of the Nettle library should usually work fine
with later version of the library. Note that the opposite is not
supported: The program should <em>not</em> be expected to work with older
versions of the Nettle library; and ABI breakage can be unobvious. E.g,
the later version may define a new library symbol, and let header files
redefine an old API name as an alias for the new symbol. If the later
version ensures that the old symbol is still defined in the library,
this change is backwards compatible: A program compiled using headers
from the older version can be successfully linked with either version of
the library. But if you compile the same program using headers from the
later version of the library, and attempt to link with the older
version, you&rsquo;ll get an undefined reference to the new symbol.
</p>
<p>API compatibility is rarely broken; exceptions are noted in the NEWS
file. For example, the key size argument to the function
<code>cast128_set_key</code> was dropped in the Nettle-3.0 release, and all
programs using that function had to be updated to work with the new
version.
</p>
<p>ABI compatibility is broken occasionally. This is also noted in the NEWS
file, and the name of the shared library is updated to prevent
accidental run-time linking with the wrong version. All programs have to
be recompiled before they can link with the new version. Since names are
different, multiple versions can be installed on the same system, with a
mix of programs linking to one version or the other.
</p>
<p>Under some circumstances, it is possible to have a single program
linking dynamically with two binary incompatible versions of the Nettle
library, thanks to the use of symbol versioning. Consider a program
calling functions in both Nettle and GnuTLS. For the direct dependency
on Nettle, the program is linked with a particular version of the Nettle
shared library. GnuTLS uses Nettle internally, but does not expose any
Nettle data structures or the like in its own ABI. In this situation,
the GnuTLS shared library may link with a different version of the
Nettle library. Then both versions of the Nettle library will be loaded
into the program&rsquo;s address space, and each reference to a symbol will be
resolved to the correct version.
</p>
<p>Finally, some of Nettle&rsquo;s symbols are internal. They carry a leading
underscore, and are not declared in installed header files. They can be
used for local or experimental purposes, but programs referring directly
to those symbols get neither API nor ABI compatibility, not even between
minor versions.
</p>
<hr>
<span id="Reference"></span><div class="header">
<p>
Next: <a href="#Nettle-soup" accesskey="n" rel="next">Nettle soup</a>, Previous: <a href="#Compatibility" accesskey="p" rel="prev">Compatibility</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Reference-1"></span><h2 class="chapter">7 Reference</h2>

<p>This chapter describes all the Nettle functions, grouped by family.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Hash-functions" accesskey="1">Hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cipher-functions" accesskey="2">Cipher functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cipher-modes" accesskey="3">Cipher modes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Authenticated-encryption" accesskey="4">Authenticated encryption</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Keyed-hash-functions" accesskey="5">Keyed hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Key-derivation-functions" accesskey="6">Key derivation functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Public_002dkey-algorithms" accesskey="7">Public-key algorithms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Randomness" accesskey="8">Randomness</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ASCII-encoding" accesskey="9">ASCII encoding</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-functions">Miscellaneous functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-functions">Compatibility functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Hash-functions"></span><div class="header">
<p>
Next: <a href="#Cipher-functions" accesskey="n" rel="next">Cipher functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hash-functions-1"></span><h3 class="section">7.1 Hash functions</h3>
<span id="index-Hash-function"></span>

<p>A cryptographic <em>hash function</em> is a function that takes variable
size strings, and maps them to strings of fixed, short, length. There
are naturally lots of collisions, as there are more possible 1MB files
than 20 byte strings. But the function is constructed such that is hard
to find the collisions. More precisely, a cryptographic hash function
<code>H</code> should have the following properties:
</p>
<dl compact="compact">
<dt><em>One-way</em></dt>
<dd><span id="index-One_002dway"></span>
<p>Given a hash value <code>H(x)</code> it is hard to find a string <code>x</code>
that hashes to that value.
</p>
</dd>
<dt><em>Collision-resistant</em></dt>
<dd><span id="index-Collision_002dresistant"></span>
<p>It is hard to find two different strings, <code>x</code> and <code>y</code>, such
that <code>H(x)</code> = <code>H(y)</code>.
</p>
</dd>
</dl>

<p>Hash functions are useful as building blocks for digital signatures,
message authentication codes, pseudo random generators, association of
unique ids to documents, and many other things.
</p>
<p>The most commonly used hash functions are MD5 and SHA1. Unfortunately,
both these fail the collision-resistance requirement; cryptologists have
found ways to construct colliding inputs. The recommended hash functions
for new applications are SHA2 (with main variants SHA256 and SHA512). At
the time of this writing (Autumn 2015), SHA3 has recently been
standardized, and the new SHA3 and other top SHA3 candidates may also be
reasonable alternatives.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Recommended-hash-functions" accesskey="1">Recommended hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-hash-functions" accesskey="2">Miscellaneous hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Legacy-hash-functions" accesskey="3">Legacy hash functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005fhash-abstraction" accesskey="4">nettle_hash abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Recommended-hash-functions"></span><div class="header">
<p>
Next: <a href="#Miscellaneous-hash-functions" accesskey="n" rel="next">Miscellaneous hash functions</a>, Up: <a href="#Hash-functions" accesskey="u" rel="up">Hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Recommended-hash-functions-1"></span><h4 class="subsection">7.1.1 Recommended hash functions</h4>

<p>The following hash functions have no known weaknesses, and are suitable
for new applications. The SHA2 family of hash functions were specified
by <em>NIST</em>, intended as a replacement for <acronym>SHA1</acronym>.
</p>
<span id="SHA256"></span><h4 class="subsubsection">7.1.1.1 <acronym>SHA256</acronym></h4>

<p>SHA256 is a member of the SHA2 family. It outputs hash values of 256
bits, or 32 octets. Nettle defines SHA256 in <samp>&lt;nettle/sha2.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sha256_005fctx">Context struct: <strong>struct sha256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA256_005fDIGEST_005fSIZE">Constant: <strong>SHA256_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA256 digest, i.e. 32.
</p></dd></dl>

<dl>
<dt id="index-SHA256_005fBLOCK_005fSIZE">Constant: <strong>SHA256_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA256. Useful for some special constructions,
in particular HMAC-SHA256.
</p></dd></dl>

<dl>
<dt id="index-sha256_005finit">Function: <em>void</em> <strong>sha256_init</strong> <em>(struct sha256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA256 state.
</p></dd></dl>

<dl>
<dt id="index-sha256_005fupdate">Function: <em>void</em> <strong>sha256_update</strong> <em>(struct sha256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha256_005fdigest">Function: <em>void</em> <strong>sha256_digest</strong> <em>(struct sha256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>sha256_init</code>.
</p></dd></dl>

<p>Earlier versions of nettle defined SHA256 in the header file
<samp>&lt;nettle/sha.h&gt;</samp>, which is now deprecated, but kept for
compatibility.
</p>
<span id="SHA224"></span><h4 class="subsubsection">7.1.1.2 <acronym>SHA224</acronym></h4>

<p>SHA224 is a variant of SHA256, with a different initial state, and with
the output truncated to 224 bits, or 28 octets. Nettle defines SHA224 in
<samp>&lt;nettle/sha2.h&gt;</samp> (and in <samp>&lt;nettle/sha.h&gt;</samp>, for backwards
compatibility).
</p>
<dl>
<dt id="index-struct-sha224_005fctx">Context struct: <strong>struct sha224_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA224_005fDIGEST_005fSIZE">Constant: <strong>SHA224_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA224 digest, i.e. 28.
</p></dd></dl>

<dl>
<dt id="index-SHA224_005fBLOCK_005fSIZE">Constant: <strong>SHA224_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA224. Useful for some special constructions,
in particular HMAC-SHA224.
</p></dd></dl>

<dl>
<dt id="index-sha224_005finit">Function: <em>void</em> <strong>sha224_init</strong> <em>(struct sha224_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA224 state.
</p></dd></dl>

<dl>
<dt id="index-sha224_005fupdate">Function: <em>void</em> <strong>sha224_update</strong> <em>(struct sha224_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha224_005fdigest">Function: <em>void</em> <strong>sha224_digest</strong> <em>(struct sha224_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA224_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>sha224_init</code>.
</p></dd></dl>

<span id="SHA512"></span><h4 class="subsubsection">7.1.1.3 <acronym>SHA512</acronym></h4>

<p>SHA512 is a larger sibling to SHA256, with a very similar structure but
with both the output and the internal variables of twice the size. The
internal variables are 64 bits rather than 32, making it significantly
slower on 32-bit computers. It outputs hash values of 512 bits, or 64
octets. Nettle defines SHA512 in <samp>&lt;nettle/sha2.h&gt;</samp> (and in
<samp>&lt;nettle/sha.h&gt;</samp>, for backwards compatibility).
</p>
<dl>
<dt id="index-struct-sha512_005fctx">Context struct: <strong>struct sha512_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA512_005fDIGEST_005fSIZE">Constant: <strong>SHA512_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA512 digest, i.e. 64.
</p></dd></dl>

<dl>
<dt id="index-SHA512_005fBLOCK_005fSIZE">Constant: <strong>SHA512_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA512, 128. Useful for some special
constructions, in particular HMAC-SHA512.
</p></dd></dl>

<dl>
<dt id="index-sha512_005finit">Function: <em>void</em> <strong>sha512_init</strong> <em>(struct sha512_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA512 state.
</p></dd></dl>

<dl>
<dt id="index-sha512_005fupdate">Function: <em>void</em> <strong>sha512_update</strong> <em>(struct sha512_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha512_005fdigest">Function: <em>void</em> <strong>sha512_digest</strong> <em>(struct sha512_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>sha512_init</code>.
</p></dd></dl>

<span id="SHA384-and-other-variants-of-SHA512"></span><h4 class="subsubsection">7.1.1.4 <acronym>SHA384 and other variants of SHA512</acronym></h4>

<p>Several variants of SHA512 have been defined, with a different initial
state, and with the output truncated to shorter length than 512 bits.
Naming is a bit confused, these algorithms are called SHA512-224,
SHA512-256 and SHA384, for output sizes of 224, 256 and 384 bits,
respectively. Nettle defines these in <samp>&lt;nettle/sha2.h&gt;</samp> (and in
<samp>&lt;nettle/sha.h&gt;</samp>, for backwards compatibility).
</p>
<dl>
<dt id="index-struct-sha512_005f224_005fctx">Context struct: <strong>struct sha512_224_ctx</strong></dt>
<dt id="index-struct-sha512_005f256_005fctx">Context struct: <strong>struct sha512_256_ctx</strong></dt>
<dt id="index-struct-sha384_005fctx">Context struct: <strong>struct sha384_ctx</strong></dt>
<dd><p>These context structs are all the same as sha512_ctx. They are defined as
simple preprocessor aliases, which may cause some problems if used as
identifiers for other purposes. So avoid doing that.
</p></dd></dl>

<dl>
<dt id="index-SHA512_005f224_005fDIGEST_005fSIZE">Constant: <strong>SHA512_224_DIGEST_SIZE</strong></dt>
<dt id="index-SHA512_005f256_005fDIGEST_005fSIZE">Constant: <strong>SHA512_256_DIGEST_SIZE</strong></dt>
<dt id="index-SHA384_005fDIGEST_005fSIZE">Constant: <strong>SHA384_DIGEST_SIZE</strong></dt>
<dd><p>The digest size for each variant, i.e., 28, 32, and 48, respectively.
</p></dd></dl>

<dl>
<dt id="index-SHA512_005f224_005fBLOCK_005fSIZE">Constant: <strong>SHA512_224_BLOCK_SIZE</strong></dt>
<dt id="index-SHA512_005f256_005fBLOCK_005fSIZE">Constant: <strong>SHA512_256_BLOCK_SIZE</strong></dt>
<dt id="index-SHA384_005fBLOCK_005fSIZE">Constant: <strong>SHA384_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size, same as SHA512_BLOCK_SIZE, i.e., 128. Useful for
some special constructions, in particular HMAC-SHA384.
</p></dd></dl>

<dl>
<dt id="index-sha512_005f224_005finit">Function: <em>void</em> <strong>sha512_224_init</strong> <em>(struct sha512_224_ctx *<var>ctx</var>)</em></dt>
<dt id="index-sha512_005f256_005finit">Function: <em>void</em> <strong>sha512_256_init</strong> <em>(struct sha512_256_ctx *<var>ctx</var>)</em></dt>
<dt id="index-sha384_005finit">Function: <em>void</em> <strong>sha384_init</strong> <em>(struct sha384_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the context struct.
</p></dd></dl>

<dl>
<dt id="index-sha512_005f224_005fupdate">Function: <em>void</em> <strong>sha512_224_update</strong> <em>(struct sha512_224_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-sha512_005f256_005fupdate">Function: <em>void</em> <strong>sha512_256_update</strong> <em>(struct sha512_256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-sha384_005fupdate">Function: <em>void</em> <strong>sha384_update</strong> <em>(struct sha384_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data. These are all aliases for sha512_update, which does
the same thing.
</p></dd></dl>

<dl>
<dt id="index-sha512_005f224_005fdigest">Function: <em>void</em> <strong>sha512_224_digest</strong> <em>(struct sha512_224_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-sha512_005f256_005fdigest">Function: <em>void</em> <strong>sha512_256_digest</strong> <em>(struct sha512_256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-sha384_005fdigest">Function: <em>void</em> <strong>sha384_digest</strong> <em>(struct sha384_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it to
<var>digest</var>. <var>length</var> may be smaller than the specified digest
size, in which case only the first <var>length</var> octets of the digest are
written.
</p>
<p>These function also reset the context in the same way as the
corresponding init function.
</p></dd></dl>

<span id="SHA3_002d224"></span><h4 class="subsubsection">7.1.1.5 <acronym>SHA3-224</acronym></h4>
<span id="index-SHA3"></span>

<p>The SHA3 hash functions were specified by NIST in response to weaknesses
in SHA1, and doubts about SHA2 hash functions which structurally are
very similar to SHA1. SHA3 is a result of a competition, where the
winner, also known as Keccak, was designed by Guido Bertoni, Joan
Daemen, MichaÃ«l Peeters and Gilles Van Assche. It is structurally very
different from all widely used earlier hash functions. Like SHA2, there
are several variants, with output sizes of 224, 256, 384 and 512 bits
(28, 32, 48 and 64 octets, respectively). In August 2015, it was
formally standardized by NIST, as FIPS 202,
<a href="https://dx.doi.org/10.6028/NIST.FIPS.202">https://dx.doi.org/10.6028/NIST.FIPS.202</a>.
</p>
<p>Note that the SHA3 implementation in earlier versions of Nettle was
based on the specification at the time Keccak was announced as the
winner of the competition, which is incompatible with the final standard
and hence with current versions of Nettle. The <samp>nette/sha3.h</samp>
defines a preprocessor symbol <code>NETTLE_SHA3_FIPS202</code> to indicate
conformance with the standard.
</p>
<dl>
<dt id="index-NETTLE_005fSHA3_005fFIPS202">Constant: <strong>NETTLE_SHA3_FIPS202</strong></dt>
<dd><p>Defined to 1 in Nettle versions supporting FIPS 202. Undefined in
earlier versions.
</p></dd></dl>

<p>Nettle defines SHA3-224 in <samp>&lt;nettle/sha3.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sha3_005f224_005fctx">Context struct: <strong>struct sha3_224_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA3_005f224_005fDIGEST_005fSIZE">Constant: <strong>SHA3_224_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA3_224 digest, i.e., 28.
</p></dd></dl>

<dl>
<dt id="index-SHA3_005f224_005fBLOCK_005fSIZE">Constant: <strong>SHA3_224_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA3_224.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f224_005finit">Function: <em>void</em> <strong>sha3_224_init</strong> <em>(struct sha3_224_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA3-224 state.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f224_005fupdate">Function: <em>void</em> <strong>sha3_224_update</strong> <em>(struct sha3_224_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f224_005fdigest">Function: <em>void</em> <strong>sha3_224_digest</strong> <em>(struct sha3_224_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA3_224_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context.
</p></dd></dl>

<span id="SHA3_002d256"></span><h4 class="subsubsection">7.1.1.6 <acronym>SHA3-256</acronym></h4>

<p>This is SHA3 with 256-bit output size, and possibly the most useful
of the SHA3 hash functions.
</p>
<p>Nettle defines SHA3-256 in <samp>&lt;nettle/sha3.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sha3_005f256_005fctx">Context struct: <strong>struct sha3_256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA3_005f256_005fDIGEST_005fSIZE">Constant: <strong>SHA3_256_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA3_256 digest, i.e., 32.
</p></dd></dl>

<dl>
<dt id="index-SHA3_005f256_005fBLOCK_005fSIZE">Constant: <strong>SHA3_256_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA3_256.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f256_005finit">Function: <em>void</em> <strong>sha3_256_init</strong> <em>(struct sha3_256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA3-256 state.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f256_005fupdate">Function: <em>void</em> <strong>sha3_256_update</strong> <em>(struct sha3_256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f256_005fdigest">Function: <em>void</em> <strong>sha3_256_digest</strong> <em>(struct sha3_256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA3_256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context.
</p></dd></dl>

<span id="SHA3_002d384"></span><h4 class="subsubsection">7.1.1.7 <acronym>SHA3-384</acronym></h4>

<p>This is SHA3 with 384-bit output size.
</p>
<p>Nettle defines SHA3-384 in <samp>&lt;nettle/sha3.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sha3_005f384_005fctx">Context struct: <strong>struct sha3_384_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA3_005f384_005fDIGEST_005fSIZE">Constant: <strong>SHA3_384_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA3_384 digest, i.e., 48.
</p></dd></dl>

<dl>
<dt id="index-SHA3_005f384_005fBLOCK_005fSIZE">Constant: <strong>SHA3_384_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA3_384.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f384_005finit">Function: <em>void</em> <strong>sha3_384_init</strong> <em>(struct sha3_384_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA3-384 state.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f384_005fupdate">Function: <em>void</em> <strong>sha3_384_update</strong> <em>(struct sha3_384_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f384_005fdigest">Function: <em>void</em> <strong>sha3_384_digest</strong> <em>(struct sha3_384_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA3_384_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context.
</p></dd></dl>

<span id="SHA3_002d512"></span><h4 class="subsubsection">7.1.1.8 <acronym>SHA3-512</acronym></h4>

<p>This is SHA3 with 512-bit output size.
</p>
<p>Nettle defines SHA3-512 in <samp>&lt;nettle/sha3.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sha3_005f512_005fctx">Context struct: <strong>struct sha3_512_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA3_005f512_005fDIGEST_005fSIZE">Constant: <strong>SHA3_512_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA3_512 digest, i.e. 64.
</p></dd></dl>

<dl>
<dt id="index-SHA3_005f512_005fBLOCK_005fSIZE">Constant: <strong>SHA3_512_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA3_512.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f512_005finit">Function: <em>void</em> <strong>sha3_512_init</strong> <em>(struct sha3_512_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA3-512 state.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f512_005fupdate">Function: <em>void</em> <strong>sha3_512_update</strong> <em>(struct sha3_512_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha3_005f512_005fdigest">Function: <em>void</em> <strong>sha3_512_digest</strong> <em>(struct sha3_512_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA3_512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context.
</p></dd></dl>

<span id="SHAKE_002d256"></span><h4 class="subsubsection">7.1.1.9 <acronym>SHAKE-256</acronym></h4>
<span id="index-SHAKE"></span>

<p>In addition to those SHA-3 hash functions, Nettle also provides a SHA-3
extendable-output function (XOF), SHAKE-256. Unlike SHA-3 hash functions,
SHAKE can produce an output digest of any desired length.
</p>
<p>To use SHAKE256, the context struct, init and update functions are the
same as for SHA3-256. To get a SHAKE256 digest, the following function
is used instead of <code>sha3_256_digest</code>. For an output size of
<code>SHA3_256_DIGEST_SIZE</code>, security is equivalent to SHA3-256 (but the
digest is different). Increasing output size further does not increase
security in terms of collision or preimage resistance. It can be seen as
a built in pseudorandomness generator.
</p>
<dl>
<dt id="index-sha3_005f256_005fshake">Function: <em>void</em> <strong>sha3_256_shake</strong> <em>(struct shake256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and produces a SHAKE256 digest, writing it
to <var>digest</var>. <var>length</var> can be of arbitrary size.
</p>
<p>This function also resets the context.
</p></dd></dl>

<hr>
<span id="Miscellaneous-hash-functions"></span><div class="header">
<p>
Next: <a href="#Legacy-hash-functions" accesskey="n" rel="next">Legacy hash functions</a>, Previous: <a href="#Recommended-hash-functions" accesskey="p" rel="prev">Recommended hash functions</a>, Up: <a href="#Hash-functions" accesskey="u" rel="up">Hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Miscellaneous-hash-functions-1"></span><h4 class="subsection">7.1.2 Miscellaneous hash functions</h4>

<span id="STREEBOG512"></span><h4 class="subsubsection">7.1.2.1 <acronym>STREEBOG512</acronym></h4>

<p>STREEBOG512 is a member of the Streebog (GOST R 34.11-2012) family.  It outputs
hash values of 512 bits, or 64 octets. Nettle defines STREEBOG512 in
<samp>&lt;nettle/streebog.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-streebog512_005fctx">Context struct: <strong>struct streebog512_ctx</strong></dt>
</dl>

<dl>
<dt id="index-STREEBOG512_005fDIGEST_005fSIZE">Constant: <strong>STREEBOG512_DIGEST_SIZE</strong></dt>
<dd><p>The size of a STREEBOG512 digest, i.e. 64.
</p></dd></dl>

<dl>
<dt id="index-STREEBOG512_005fBLOCK_005fSIZE">Constant: <strong>STREEBOG512_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of STREEBOG512. Useful for some special constructions,
in particular HMAC-STREEBOG512.
</p></dd></dl>

<dl>
<dt id="index-streebog512_005finit">Function: <em>void</em> <strong>streebog512_init</strong> <em>(struct streebog512_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the STREEBOG512 state.
</p></dd></dl>

<dl>
<dt id="index-streebog512_005fupdate">Function: <em>void</em> <strong>streebog512_update</strong> <em>(struct streebog512_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-streebog512_005fdigest">Function: <em>void</em> <strong>streebog512_digest</strong> <em>(struct streebog512_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>STREEBOG512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>streebog512_init</code>.
</p></dd></dl>

<span id="STREEBOG256"></span><h4 class="subsubsection">7.1.2.2 <acronym>STREEBOG256</acronym></h4>

<p>STREEBOG256 is a variant of STREEBOG512, with a different initial state, and with
the output truncated to 256 bits, or 32 octets. Nettle defines STREEBOG256 in
<samp>&lt;nettle/streebog.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-streebog256_005fctx">Context struct: <strong>struct streebog256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-STREEBOG256_005fDIGEST_005fSIZE">Constant: <strong>STREEBOG256_DIGEST_SIZE</strong></dt>
<dd><p>The size of a STREEBOG256 digest, i.e. 32.
</p></dd></dl>

<dl>
<dt id="index-STREEBOG256_005fBLOCK_005fSIZE">Constant: <strong>STREEBOG256_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of STREEBOG256. Useful for some special constructions,
in particular HMAC-STREEBOG256.
</p></dd></dl>

<dl>
<dt id="index-streebog256_005finit">Function: <em>void</em> <strong>streebog256_init</strong> <em>(struct streebog256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the STREEBOG256 state.
</p></dd></dl>

<dl>
<dt id="index-streebog256_005fupdate">Function: <em>void</em> <strong>streebog256_update</strong> <em>(struct streebog256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-streebog256_005fdigest">Function: <em>void</em> <strong>streebog256_digest</strong> <em>(struct streebog256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>STREEBOG256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>streebog256_init</code>.
</p></dd></dl>

<span id="SM3"></span><h4 class="subsubsection">7.1.2.3 <acronym>SM3</acronym></h4>

<p>SM3 is a cryptographic hash function standard adopted by the government of the
People&rsquo;s Republic of China, which was issued by the Cryptography Standardization
Technical Committee of China on December 17, 2010. The corresponding standard
is GM/T 0004-2012 &quot;SM3 Cryptographic Hash Algorithm&quot;.
</p>
<p>SM3 algorithm is a hash algorithm in ShangMi cryptosystems. SM3 is mainly used
for digital signature and verification, message authentication code generation
and verification, random number generation, and the RFC 8998 specification
defines the usage of ShangMi algorithm suite in TLS 1.3, etc. According to the
State Cryptography Administration of China, its security and efficiency are
equivalent to SHA-256.
</p>
<p>Nettle defines SM3 in <samp>&lt;nettle/sm3.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-sm3_005fctx">Context struct: <strong>struct sm3_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SM3_005fDIGEST_005fSIZE">Constant: <strong>SM3_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SM3 digest, i.e. 32.
</p></dd></dl>

<dl>
<dt id="index-SM3_005fBLOCK_005fSIZE">Constant: <strong>SM3_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SM3. Useful for some special constructions,
in particular HMAC-SM3.
</p></dd></dl>

<dl>
<dt id="index-sm3_005finit">Function: <em>void</em> <strong>sm3_init</strong> <em>(struct sm3_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SM3 state.
</p></dd></dl>

<dl>
<dt id="index-sm3_005fupdate">Function: <em>void</em> <strong>sm3_update</strong> <em>(struct sm3_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sm3_005fdigest">Function: <em>void</em> <strong>sm3_digest</strong> <em>(struct sm3_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SM3_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>sm3_init</code>.
</p></dd></dl>


<hr>
<span id="Legacy-hash-functions"></span><div class="header">
<p>
Next: <a href="#nettle_005fhash-abstraction" accesskey="n" rel="next">nettle_hash abstraction</a>, Previous: <a href="#Miscellaneous-hash-functions" accesskey="p" rel="prev">Miscellaneous hash functions</a>, Up: <a href="#Hash-functions" accesskey="u" rel="up">Hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Legacy-hash-functions-1"></span><h4 class="subsection">7.1.3 Legacy hash functions</h4>

<p>The hash functions in this section all have some known weaknesses, and
should be avoided for new applications. These hash functions are mainly
useful for compatibility with old applications and protocols. Some are
still considered safe as building blocks for particular constructions,
e.g., there seems to be no known attacks against HMAC-SHA1 or even
HMAC-MD5. In some important cases, use of a &ldquo;legacy&rdquo; hash function
does not in itself make the application insecure; if a known weakness is
relevant depends on how the hash function is used, and on the threat
model.
</p>
<span id="MD5"></span><h4 class="subsubsection">7.1.3.1 <acronym>MD5</acronym></h4>

<p>MD5 is a message digest function constructed by Ronald Rivest, and
described in <cite>RFC 1321</cite>. It outputs message digests of 128 bits, or
16 octets. Nettle defines MD5 in <samp>&lt;nettle/md5.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-md5_005fctx">Context struct: <strong>struct md5_ctx</strong></dt>
</dl>

<dl>
<dt id="index-MD5_005fDIGEST_005fSIZE">Constant: <strong>MD5_DIGEST_SIZE</strong></dt>
<dd><p>The size of an MD5 digest, i.e. 16.
</p></dd></dl>

<dl>
<dt id="index-MD5_005fBLOCK_005fSIZE">Constant: <strong>MD5_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of MD5. Useful for some special constructions,
in particular HMAC-MD5.
</p></dd></dl>

<dl>
<dt id="index-md5_005finit">Function: <em>void</em> <strong>md5_init</strong> <em>(struct md5_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the MD5 state.
</p></dd></dl>

<dl>
<dt id="index-md5_005fupdate">Function: <em>void</em> <strong>md5_update</strong> <em>(struct md5_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-md5_005fdigest">Function: <em>void</em> <strong>md5_digest</strong> <em>(struct md5_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD5_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>md5_init</code>.
</p></dd></dl>

<p>The normal way to use MD5 is to call the functions in order: First
<code>md5_init</code>, then <code>md5_update</code> zero or more times, and finally
<code>md5_digest</code>. After <code>md5_digest</code>, the context is reset to
its initial state, so you can start over calling <code>md5_update</code> to
hash new data.
</p>
<p>To start over, you can call <code>md5_init</code> at any time.
</p>
<span id="MD2"></span><h4 class="subsubsection">7.1.3.2 <acronym>MD2</acronym></h4>

<p>MD2 is another hash function of Ronald Rivest&rsquo;s, described in
<cite>RFC 1319</cite>. It outputs message digests of 128 bits, or 16 octets.
Nettle defines MD2 in <samp>&lt;nettle/md2.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-md2_005fctx">Context struct: <strong>struct md2_ctx</strong></dt>
</dl>

<dl>
<dt id="index-MD2_005fDIGEST_005fSIZE">Constant: <strong>MD2_DIGEST_SIZE</strong></dt>
<dd><p>The size of an MD2 digest, i.e. 16.
</p></dd></dl>

<dl>
<dt id="index-MD2_005fBLOCK_005fSIZE">Constant: <strong>MD2_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of MD2.
</p></dd></dl>

<dl>
<dt id="index-md2_005finit">Function: <em>void</em> <strong>md2_init</strong> <em>(struct md2_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the MD2 state.
</p></dd></dl>

<dl>
<dt id="index-md2_005fupdate">Function: <em>void</em> <strong>md2_update</strong> <em>(struct md2_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-md2_005fdigest">Function: <em>void</em> <strong>md2_digest</strong> <em>(struct md2_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD2_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>md2_init</code>.
</p></dd></dl>

<span id="MD4"></span><h4 class="subsubsection">7.1.3.3 <acronym>MD4</acronym></h4>

<p>MD4 is a predecessor of MD5, described in <cite>RFC 1320</cite>. Like MD5, it
is constructed by Ronald Rivest. It outputs message digests of 128 bits,
or 16 octets. Nettle defines MD4 in <samp>&lt;nettle/md4.h&gt;</samp>. Use of MD4 is
not recommended, but it is sometimes needed for compatibility with
existing applications and protocols.
</p>
<dl>
<dt id="index-struct-md4_005fctx">Context struct: <strong>struct md4_ctx</strong></dt>
</dl>

<dl>
<dt id="index-MD4_005fDIGEST_005fSIZE">Constant: <strong>MD4_DIGEST_SIZE</strong></dt>
<dd><p>The size of an MD4 digest, i.e. 16.
</p></dd></dl>

<dl>
<dt id="index-MD4_005fBLOCK_005fSIZE">Constant: <strong>MD4_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of MD4.
</p></dd></dl>

<dl>
<dt id="index-md4_005finit">Function: <em>void</em> <strong>md4_init</strong> <em>(struct md4_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the MD4 state.
</p></dd></dl>

<dl>
<dt id="index-md4_005fupdate">Function: <em>void</em> <strong>md4_update</strong> <em>(struct md4_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-md4_005fdigest">Function: <em>void</em> <strong>md4_digest</strong> <em>(struct md4_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD4_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>md4_init</code>.
</p></dd></dl>

<span id="RIPEMD160"></span><h4 class="subsubsection">7.1.3.4 <acronym>RIPEMD160</acronym></h4>

<p>RIPEMD160 is a hash function designed by Hans Dobbertin, Antoon
Bosselaers, and Bart Preneel, as a strengthened version of RIPEMD
(which, like MD4 and MD5, fails the collision-resistance requirement).
It produces message digests of 160 bits, or 20 octets. Nettle defined
RIPEMD160 in <samp>nettle/ripemd160.h</samp>.
</p>
<dl>
<dt id="index-struct-ripemd160_005fctx">Context struct: <strong>struct ripemd160_ctx</strong></dt>
</dl>

<dl>
<dt id="index-RIPEMD160_005fDIGEST_005fSIZE">Constant: <strong>RIPEMD160_DIGEST_SIZE</strong></dt>
<dd><p>The size of a RIPEMD160 digest, i.e. 20.
</p></dd></dl>

<dl>
<dt id="index-RIPEMD160_005fBLOCK_005fSIZE">Constant: <strong>RIPEMD160_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of RIPEMD160.
</p></dd></dl>

<dl>
<dt id="index-ripemd160_005finit">Function: <em>void</em> <strong>ripemd160_init</strong> <em>(struct ripemd160_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the RIPEMD160 state.
</p></dd></dl>

<dl>
<dt id="index-ripemd160_005fupdate">Function: <em>void</em> <strong>ripemd160_update</strong> <em>(struct ripemd160_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-ripemd160_005fdigest">Function: <em>void</em> <strong>ripemd160_digest</strong> <em>(struct ripemd160_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>RIPEMD160_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>ripemd160_init</code>.
</p></dd></dl>

<span id="SHA1"></span><h4 class="subsubsection">7.1.3.5 <acronym>SHA1</acronym></h4>

<p>SHA1 is a hash function specified by <em>NIST</em> (The U.S. National
Institute for Standards and Technology). It outputs hash values of 160
bits, or 20 octets. Nettle defines SHA1 in <samp>&lt;nettle/sha1.h&gt;</samp> (and
in <samp>&lt;nettle/sha.h&gt;</samp>, for backwards compatibility).
</p>
<dl>
<dt id="index-struct-sha1_005fctx">Context struct: <strong>struct sha1_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SHA1_005fDIGEST_005fSIZE">Constant: <strong>SHA1_DIGEST_SIZE</strong></dt>
<dd><p>The size of a SHA1 digest, i.e. 20.
</p></dd></dl>

<dl>
<dt id="index-SHA1_005fBLOCK_005fSIZE">Constant: <strong>SHA1_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of SHA1. Useful for some special constructions,
in particular HMAC-SHA1.
</p></dd></dl>

<dl>
<dt id="index-sha1_005finit">Function: <em>void</em> <strong>sha1_init</strong> <em>(struct sha1_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the SHA1 state.
</p></dd></dl>

<dl>
<dt id="index-sha1_005fupdate">Function: <em>void</em> <strong>sha1_update</strong> <em>(struct sha1_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-sha1_005fdigest">Function: <em>void</em> <strong>sha1_digest</strong> <em>(struct sha1_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA1_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>sha1_init</code>.
</p></dd></dl>


<span id="GOSTHASH94-and-GOSTHASH94CP"></span><h4 class="subsubsection">7.1.3.6 <acronym>GOSTHASH94 and GOSTHASH94CP</acronym></h4>
<span id="index-GOST-hash"></span>

<span id="GOSTHASH94CP"></span><p>The GOST94 or GOST R 34.11-94 hash algorithm is a Soviet-era algorithm 
used in Russian government standards (see <cite>RFC 4357</cite>).
It outputs message digests of 256 bits, or 32 octets. The standard itself
does not fix the S-box used by the hash algorith, so there are two popular
variants (the testing S-box from the standard itself and the S-box defined
by CryptoPro company, see RFC 4357). Nettle provides support for the former
S-box in the form of GOSTHASH94 hash algorithm and for the latter in the
form of GOSTHASH94CP hash algorithm.
Nettle defines GOSTHASH94 and GOSTHASH94CP in <samp>&lt;nettle/gosthash94.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-gosthash94_005fctx">Context struct: <strong>struct gosthash94_ctx</strong></dt>
</dl>

<dl>
<dt id="index-GOSTHASH94_005fDIGEST_005fSIZE">Constant: <strong>GOSTHASH94_DIGEST_SIZE</strong></dt>
<dd><p>The size of a GOSTHASH94 digest, i.e. 32.
</p></dd></dl>

<dl>
<dt id="index-GOSTHASH94_005fBLOCK_005fSIZE">Constant: <strong>GOSTHASH94_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of GOSTHASH94, i.e., 32.
</p></dd></dl>

<dl>
<dt id="index-gosthash94_005finit">Function: <em>void</em> <strong>gosthash94_init</strong> <em>(struct gosthash94_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the GOSTHASH94 state.
</p></dd></dl>

<dl>
<dt id="index-gosthash94_005fupdate">Function: <em>void</em> <strong>gosthash94_update</strong> <em>(struct gosthash94_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-gosthash94_005fdigest">Function: <em>void</em> <strong>gosthash94_digest</strong> <em>(struct gosthash94_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>GOSTHASH94_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>gosthash94_init</code>.
</p></dd></dl>

<dl>
<dt id="index-struct-gosthash94cp_005fctx">Context struct: <strong>struct gosthash94cp_ctx</strong></dt>
</dl>

<dl>
<dt id="index-GOSTHASH94CP_005fDIGEST_005fSIZE">Constant: <strong>GOSTHASH94CP_DIGEST_SIZE</strong></dt>
<dd><p>The size of a GOSTHASH94CP digest, i.e. 32.
</p></dd></dl>

<dl>
<dt id="index-GOSTHASH94CP_005fBLOCK_005fSIZE">Constant: <strong>GOSTHASH94CP_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of GOSTHASH94CP, i.e., 32.
</p></dd></dl>

<dl>
<dt id="index-gosthash94cp_005finit">Function: <em>void</em> <strong>gosthash94cp_init</strong> <em>(struct gosthash94cp_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initialize the GOSTHASH94CP state.
</p></dd></dl>

<dl>
<dt id="index-gosthash94cp_005fupdate">Function: <em>void</em> <strong>gosthash94cp_update</strong> <em>(struct gosthash94cp_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Hash some more data.
</p></dd></dl>

<dl>
<dt id="index-gosthash94cp_005fdigest">Function: <em>void</em> <strong>gosthash94cp_digest</strong> <em>(struct gosthash94cp_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>GOSTHASH94CP_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.
</p>
<p>This function also resets the context in the same way as
<code>gosthash94cp_init</code>.
</p></dd></dl>

<hr>
<span id="nettle_005fhash-abstraction"></span><div class="header">
<p>
Previous: <a href="#Legacy-hash-functions" accesskey="p" rel="prev">Legacy hash functions</a>, Up: <a href="#Hash-functions" accesskey="u" rel="up">Hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-struct-nettle_005fhash-abstraction"></span><h4 class="subsection">7.1.4 The <code>struct nettle_hash</code> abstraction</h4>
<span id="index-nettle_005fhash"></span>

<p>Nettle includes a struct including information about the supported hash
functions. It is defined in <samp>&lt;nettle/nettle-meta.h&gt;</samp>, and is used
by Nettle&rsquo;s implementation of <acronym>HMAC</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>).
</p>
<dl>
<dt id="index-struct-nettle_005fhash">Meta struct: <strong><code>struct nettle_hash</code></strong> <em>name context_size digest_size block_size init update digest</em></dt>
<dd><p>The last three attributes are function pointers, of types
<code>nettle_hash_init_func *</code>, <code>nettle_hash_update_func *</code>, and
<code>nettle_hash_digest_func *</code>. The first argument to these functions is
<code>void *</code> pointer to a context struct, which is of size
<code>context_size</code>.
</p></dd></dl>

<dl>
<dt id="index-nettle_005fmd2">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_md2</strong></dt>
<dt id="index-nettle_005fmd4">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_md4</strong></dt>
<dt id="index-nettle_005fmd5">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_md5</strong></dt>
<dt id="index-nettle_005fripemd160">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_ripemd160</strong></dt>
<dt id="index-nettle_005fsha1">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha1</strong></dt>
<dt id="index-nettle_005fsha224">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha224</strong></dt>
<dt id="index-nettle_005fsha256">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha256</strong></dt>
<dt id="index-nettle_005fsha384">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha384</strong></dt>
<dt id="index-nettle_005fsha512">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha512</strong></dt>
<dt id="index-nettle_005fsha3_005f256">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sha3_256</strong></dt>
<dt id="index-nettle_005fgosthash94">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_gosthash94</strong></dt>
<dt id="index-nettle_005fgosthash94cp">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_gosthash94cp</strong></dt>
<dt id="index-nettle_005fsm3">Constant Struct: <em>struct nettle_hash</em> <strong>nettle_sm3</strong></dt>
<dd><p>These are all the hash functions that Nettle implements.
</p></dd></dl>

<p>Nettle also exports a list of all these hashes.
</p>
<dl>
<dt id="index-nettle_005fget_005fhashes">Function: <em>const struct nettle_hash **</em> <strong>nettle_get_hashes</strong> <em>(void)</em></dt>
<dd><p>Returns a NULL-terminated list of pointers to supported hash functions.
This list can be used to dynamically enumerate or search the supported
algorithms.
</p></dd></dl>

<dl>
<dt id="index-nettle_005fhashes">Macro: <strong>nettle_hashes</strong></dt>
<dd><p>A macro expanding to a call to nettle_get_hashes, so that one could
write, e.g., <code>nettle_hashes[0]-&gt;name</code> for the name of the first
hash function on the list. In earlier versions, this was not a macro but
the actual array of pointers. However, referring directly to the array
makes the array size leak into the ABI in some cases.
</p></dd></dl>

<hr>
<span id="Cipher-functions"></span><div class="header">
<p>
Next: <a href="#Cipher-modes" accesskey="n" rel="next">Cipher modes</a>, Previous: <a href="#Hash-functions" accesskey="p" rel="prev">Hash functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cipher-functions-1"></span><h3 class="section">7.2 Cipher functions</h3>
<span id="index-Cipher"></span>

<p>A <em>cipher</em> is a function that takes a message or <em>plaintext</em>
and a secret <em>key</em> and transforms it to a <em>ciphertext</em>. Given
only the ciphertext, but not the key, it should be hard to find the
plaintext. Given matching pairs of plaintext and ciphertext, it should
be hard to find the key.
</p>
<span id="index-Block-Cipher"></span>
<span id="index-Stream-Cipher"></span>

<p>There are two main classes of ciphers: Block ciphers and stream ciphers.
</p>
<p>A block cipher can process data only in fixed size chunks, called
<em>blocks</em>. Typical block sizes are 8 or 16 octets. To encrypt
arbitrary messages, you usually have to pad it to an integral number of
blocks, split it into blocks, and then process each block. The simplest
way is to process one block at a time, independent of each other. That
mode of operation is called <em>ECB</em>, Electronic Code Book mode.
However, using <acronym>ECB</acronym> is usually a bad idea. For a start, plaintext blocks
that are equal are transformed to ciphertext blocks that are equal; that
leaks information about the plaintext. Usually you should apply the
cipher is some &ldquo;feedback mode&rdquo;, <em>CBC</em> (Cipher Block Chaining) and
<em>CTR</em> (Counter mode) being two of
of the most popular. See See <a href="#Cipher-modes">Cipher modes</a>, for information on
how to apply <acronym>CBC</acronym> and <acronym>CTR</acronym> with Nettle.
</p>
<p>A stream cipher can be used for messages of arbitrary length. A typical
stream cipher is a keyed pseudo-random generator. To encrypt a plaintext
message of <var>n</var> octets, you key the generator, generate <var>n</var>
octets of pseudo-random data, and XOR it with the plaintext. To decrypt,
regenerate the same stream using the key, XOR it to the ciphertext, and
the plaintext is recovered.
</p>
<p><strong>Caution:</strong> The first rule for this kind of cipher is the
same as for a One Time Pad: <em>never</em> ever use the same key twice.
</p>
<p>A common misconception is that encryption, by itself, implies
authentication. Say that you and a friend share a secret key, and you
receive an encrypted message. You apply the key, and get a plaintext
message that makes sense to you. Can you then be sure that it really was
your friend that wrote the message you&rsquo;re reading? The answer is no. For
example, if you were using a block cipher in ECB mode, an attacker may
pick up the message on its way, and reorder, delete or repeat some of
the blocks. Even if the attacker can&rsquo;t decrypt the message, he can
change it so that you are not reading the same message as your friend
wrote. If you are using a block cipher in <acronym>CBC</acronym> mode rather than
ECB, or are using a stream cipher, the possibilities for this sort of
attack are different, but the attacker can still make predictable
changes to the message.
</p>
<p>It is recommended to <em>always</em> use an authentication mechanism in
addition to encrypting the messages. Popular choices are Message
Authentication Codes like <acronym>HMAC-SHA1</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>), or digital signatures like <acronym>RSA</acronym>.
</p>
<p>Some ciphers have so called &ldquo;weak keys&rdquo;, keys that results in
undesirable structure after the key setup processing, and should be
avoided. In Nettle, most key setup functions have no return value, but
for ciphers with weak keys, the return value indicates whether or not
the given key is weak. For good keys, key setup returns 1, and for weak
keys, it returns 0. When possible, avoid algorithms that
have weak keys. There are several good ciphers that don&rsquo;t have any weak
keys.
</p>
<p>To encrypt a message, you first initialize a cipher context for
encryption or decryption with a particular key. You then use the context
to process plaintext or ciphertext messages. The initialization is known
as <em>key setup</em>. With Nettle, it is recommended to use each
context struct for only one direction, even if some of the ciphers use a
single key setup function that can be used for both encryption and
decryption.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#AES" accesskey="1">AES</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Arcfour" accesskey="2">Arcfour</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Arctwo" accesskey="3">Arctwo</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Blowfish" accesskey="4">Blowfish</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Camellia" accesskey="5">Camellia</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CAST128" accesskey="6">CAST128</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ChaCha" accesskey="7">ChaCha</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DES" accesskey="8">DES</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DES3" accesskey="9">DES3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Salsa20">Salsa20</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Serpent">Serpent</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Twofish">Twofish</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="AES"></span><div class="header">
<p>
Next: <a href="#Arcfour" accesskey="n" rel="next">Arcfour</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="AES-1"></span><h4 class="subsection">7.2.1 AES</h4>
<span id="index-AES"></span>

<p>AES is a block cipher, specified by NIST as a replacement for
the older DES standard. The standard is the result of a competition
between cipher designers. The winning design, also known as RIJNDAEL,
was constructed by Joan Daemen and Vincent Rijnmen.
</p>
<p>Like all the AES candidates, the winning design uses a block size of 128
bits, or 16 octets, and three possible key-size, 128, 192 and 256 bits
(16, 24 and 32 octets) being the allowed key sizes. It does not have any
weak keys. Nettle defines AES in <samp>&lt;nettle/aes.h&gt;</samp>, and there is one
context struct for each key size. (Earlier versions of Nettle used a
single context struct, <code>struct aes_ctx</code>, for all key sizes. This
interface kept for backwards compatibility).
</p> 
<dl>
<dt id="index-struct-aes128_005fctx">Context struct: <strong>struct aes128_ctx</strong></dt>
<dt id="index-struct-aes192_005fctx">Context struct: <strong>struct aes192_ctx</strong></dt>
<dt id="index-struct-aes256_005fctx">Context struct: <strong>struct aes256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-struct-aes_005fctx">Context struct: <strong>struct aes_ctx</strong></dt>
<dd><p>Alternative struct, for the old AES interface.
</p></dd></dl>

<dl>
<dt id="index-AES_005fBLOCK_005fSIZE">Constant: <strong>AES_BLOCK_SIZE</strong></dt>
<dd><p>The AES block-size, 16.
</p></dd></dl>

<dl>
<dt id="index-AES128_005fKEY_005fSIZE">Constant: <strong>AES128_KEY_SIZE</strong></dt>
<dt id="index-AES192_005fKEY_005fSIZE">Constant: <strong>AES192_KEY_SIZE</strong></dt>
<dt id="index-AES256_005fKEY_005fSIZE">Constant: <strong>AES256_KEY_SIZE</strong></dt>
<dt id="index-AES_005fMIN_005fKEY_005fSIZE">Constant: <strong>AES_MIN_KEY_SIZE</strong></dt>
<dt id="index-AES_005fMAX_005fKEY_005fSIZE">Constant: <strong>AES_MAX_KEY_SIZE</strong></dt>
</dl>

<dl>
<dt id="index-AES_005fKEY_005fSIZE">Constant: <strong>AES_KEY_SIZE</strong></dt>
<dd><p>Default AES key size, 32.
</p></dd></dl>

<dl>
<dt id="index-aes128_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>aes128_set_encrypt_key</strong> <em>(struct aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes128_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>aes128_set_decrypt_key</strong> <em>(struct aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes192_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>aes192_set_encrypt_key</strong> <em>(struct aes192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes192_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>aes192_set_decrypt_key</strong> <em>(struct aes192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes256_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>aes256_set_encrypt_key</strong> <em>(struct aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes256_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>aes256_set_decrypt_key</strong> <em>(struct aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>aes_set_encrypt_key</strong> <em>(struct aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-aes_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>aes_set_decrypt_key</strong> <em>(struct aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher, for encryption or decryption, respectively.
</p></dd></dl>

<dl>
<dt id="index-aes128_005finvert_005fkey">Function: <em>void</em> <strong>aes128_invert_key</strong> <em>(struct aes128_ctx *<var>dst</var>, const struct aes128_ctx *<var>src</var>)</em></dt>
<dt id="index-aes192_005finvert_005fkey">Function: <em>void</em> <strong>aes192_invert_key</strong> <em>(struct aes192_ctx *<var>dst</var>, const struct aes192_ctx *<var>src</var>)</em></dt>
<dt id="index-aes256_005finvert_005fkey">Function: <em>void</em> <strong>aes256_invert_key</strong> <em>(struct aes256_ctx *<var>dst</var>, const struct aes256_ctx *<var>src</var>)</em></dt>
<dt id="index-aes_005finvert_005fkey">Function: <em>void</em> <strong>aes_invert_key</strong> <em>(struct aes_ctx *<var>dst</var>, const struct aes_ctx *<var>src</var>)</em></dt>
<dd><p>Given a context <var>src</var> initialized for encryption, initializes the
context struct <var>dst</var> for decryption, using the same key. If the same
context struct is passed for both <code>src</code> and <code>dst</code>, it is
converted in place. These functions are mainly useful for applications
which needs to both encrypt and decrypt using the <em>same</em> key,
because calling, e.g., <code>aes128_set_encrypt_key</code> and
<code>aes128_invert_key</code>, is more efficient than calling
<code>aes128_set_encrypt_key</code> and <code>aes128_set_decrypt_key</code>.
</p></dd></dl>

<dl>
<dt id="index-aes128_005fencrypt">Function: <em>void</em> <strong>aes128_encrypt</strong> <em>(struct aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes192_005fencrypt">Function: <em>void</em> <strong>aes192_encrypt</strong> <em>(struct aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes256_005fencrypt">Function: <em>void</em> <strong>aes256_encrypt</strong> <em>(struct aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes_005fencrypt">Function: <em>void</em> <strong>aes_encrypt</strong> <em>(struct aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-aes128_005fdecrypt">Function: <em>void</em> <strong>aes128_decrypt</strong> <em>(struct aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes192_005fdecrypt">Function: <em>void</em> <strong>aes192_decrypt</strong> <em>(struct aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes256_005fdecrypt">Function: <em>void</em> <strong>aes256_decrypt</strong> <em>(struct aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-aes_005fdecrypt">Function: <em>void</em> <strong>aes_decrypt</strong> <em>(struct aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to the encryption functions above.
</p></dd></dl>

<hr>
<span id="Arcfour"></span><div class="header">
<p>
Next: <a href="#Arctwo" accesskey="n" rel="next">Arctwo</a>, Previous: <a href="#AES" accesskey="p" rel="prev">AES</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Arcfour-1"></span><h4 class="subsection">7.2.2 Arcfour</h4>
<span id="index-Arcfour"></span>
<span id="index-RC4"></span>

<p>ARCFOUR is a stream cipher, also known under the trade marked name RC4,
and it is one of the fastest ciphers around. A problem is that the key
setup of ARCFOUR is quite weak, you should never use keys with
structure, keys that are ordinary passwords, or sequences of keys like
&ldquo;secret:1&rdquo;, &ldquo;secret:2&rdquo;, <small class="enddots">...</small>. If you have keys that don&rsquo;t look
like random bit strings, and you want to use ARCFOUR, always hash the
key before feeding it to ARCFOUR. Furthermore, the initial bytes of the
generated key stream leak information about the key; for this reason, it
is recommended to discard the first 512 bytes of the key stream.
</p>
<div class="example">
<pre class="example">/* A more robust key setup function for ARCFOUR */
void
arcfour_set_key_hashed(struct arcfour_ctx *ctx,
                       size_t length, const uint8_t *key)
{
  struct sha256_ctx hash;
  uint8_t digest[SHA256_DIGEST_SIZE];
  uint8_t buffer[0x200];

  sha256_init(&amp;hash);
  sha256_update(&amp;hash, length, key);
  sha256_digest(&amp;hash, SHA256_DIGEST_SIZE, digest);

  arcfour_set_key(ctx, SHA256_DIGEST_SIZE, digest);
  arcfour_crypt(ctx, sizeof(buffer), buffer, buffer);
}
</pre></div>

<p>Nettle defines ARCFOUR in <samp>&lt;nettle/arcfour.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-arcfour_005fctx">Context struct: <strong>struct arcfour_ctx</strong></dt>
</dl>

<dl>
<dt id="index-ARCFOUR_005fMIN_005fKEY_005fSIZE">Constant: <strong>ARCFOUR_MIN_KEY_SIZE</strong></dt>
<dd><p>Minimum key size, 1.
</p></dd></dl>

<dl>
<dt id="index-ARCFOUR_005fMAX_005fKEY_005fSIZE">Constant: <strong>ARCFOUR_MAX_KEY_SIZE</strong></dt>
<dd><p>Maximum key size, 256.
</p></dd></dl>

<dl>
<dt id="index-ARCFOUR_005fKEY_005fSIZE">Constant: <strong>ARCFOUR_KEY_SIZE</strong></dt>
<dd><p>Default ARCFOUR key size, 16.
</p></dd></dl>

<dl>
<dt id="index-arcfour_005fset_005fkey">Function: <em>void</em> <strong>arcfour_set_key</strong> <em>(struct arcfour_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></dd></dl>

<dl>
<dt id="index-arcfour_005fcrypt">Function: <em>void</em> <strong>arcfour_crypt</strong> <em>(struct arcfour_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypt some data. The same function is used for both encryption and
decryption. Unlike the block ciphers, this function modifies the
context, so you can split the data into arbitrary chunks and encrypt
them one after another. The result is the same as if you had called
<code>arcfour_crypt</code> only once with all the data.
</p></dd></dl>

<hr>
<span id="Arctwo"></span><div class="header">
<p>
Next: <a href="#Blowfish" accesskey="n" rel="next">Blowfish</a>, Previous: <a href="#Arcfour" accesskey="p" rel="prev">Arcfour</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Arctwo-1"></span><h4 class="subsection">7.2.3 Arctwo</h4>
<span id="index-Arctwo"></span>
<span id="index-RC2"></span>

<p>ARCTWO (also known as the trade marked name RC2) is a block cipher
specified in RFC 2268. Nettle also include a variation of the ARCTWO
set key operation that lack one step, to be compatible with the
reverse engineered RC2 cipher description, as described in a Usenet
post to <code>sci.crypt</code> by Peter Gutmann.
</p>
<p>ARCTWO uses a block size of 64 bits, and variable key-size ranging
from 1 to 128 octets. Besides the key, ARCTWO also has a second
parameter to key setup, the number of effective key bits, <code>ekb</code>.
This parameter can be used to artificially reduce the key size. In
practice, <code>ekb</code> is usually set equal to the input key size.
Nettle defines ARCTWO in <samp>&lt;nettle/arctwo.h&gt;</samp>.
</p>
<p>We do not recommend the use of ARCTWO; the Nettle implementation is
provided primarily for interoperability with existing applications and
standards.
</p>
<dl>
<dt id="index-struct-arctwo_005fctx">Context struct: <strong>struct arctwo_ctx</strong></dt>
</dl>

<dl>
<dt id="index-ARCTWO_005fBLOCK_005fSIZE">Constant: <strong>ARCTWO_BLOCK_SIZE</strong></dt>
<dd><p>The ARCTWO block-size, 8.
</p></dd></dl>

<dl>
<dt id="index-ARCTWO_005fMIN_005fKEY_005fSIZE">Constant: <strong>ARCTWO_MIN_KEY_SIZE</strong></dt>
</dl>

<dl>
<dt id="index-ARCTWO_005fMAX_005fKEY_005fSIZE">Constant: <strong>ARCTWO_MAX_KEY_SIZE</strong></dt>
</dl>

<dl>
<dt id="index-ARCTWO_005fKEY_005fSIZE">Constant: <strong>ARCTWO_KEY_SIZE</strong></dt>
<dd><p>Default ARCTWO key size, 8.
</p></dd></dl>

<dl>
<dt id="index-arctwo_005fset_005fkey_005fekb">Function: <em>void</em> <strong>arctwo_set_key_ekb</strong> <em>(struct arctwo_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>, unsigned <var>ekb</var>)</em></dt>
<dt id="index-arctwo_005fset_005fkey">Function: <em>void</em> <strong>arctwo_set_key</strong> <em>(struct arctwo_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-arctwo_005fset_005fkey_005fgutmann">Function: <em>void</em> <strong>arctwo_set_key_gutmann</strong> <em>(struct arctwo_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption
and decryption. The first function is the most general one, which lets
you provide both the variable size key, and the desired effective key
size (in bits). The maximum value for <var>ekb</var> is 1024, and for
convenience, <code>ekb = 0</code> has the same effect as <code>ekb = 1024</code>.
</p>
<p><code>arctwo_set_key(ctx, length, key)</code> is equivalent to
<code>arctwo_set_key_ekb(ctx, length, key, 8*length)</code>, and
<code>arctwo_set_key_gutmann(ctx, length, key)</code> is equivalent to
<code>arctwo_set_key_ekb(ctx, length, key, 1024)</code>
</p></dd></dl>

<dl>
<dt id="index-arctwo_005fencrypt">Function: <em>void</em> <strong>arctwo_encrypt</strong> <em>(struct arctwo_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not
overlap in any other way.
</p></dd></dl>

<dl>
<dt id="index-arctwo_005fdecrypt">Function: <em>void</em> <strong>arctwo_decrypt</strong> <em>(struct arctwo_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>arctwo_encrypt</code>
</p></dd></dl>

<hr>
<span id="Blowfish"></span><div class="header">
<p>
Next: <a href="#Camellia" accesskey="n" rel="next">Camellia</a>, Previous: <a href="#Arctwo" accesskey="p" rel="prev">Arctwo</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Blowfish-1"></span><h4 class="subsection">7.2.4 Blowfish</h4>
<span id="index-Blowfish"></span>

<p>BLOWFISH is a block cipher designed by Bruce Schneier. It uses a block
size of 64 bits (8 octets), and a variable key size, up to 448 bits. It
has some weak keys. Nettle defines BLOWFISH in <samp>&lt;nettle/blowfish.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-blowfish_005fctx">Context struct: <strong>struct blowfish_ctx</strong></dt>
</dl>

<dl>
<dt id="index-BLOWFISH_005fBLOCK_005fSIZE">Constant: <strong>BLOWFISH_BLOCK_SIZE</strong></dt>
<dd><p>The BLOWFISH block-size, 8.
</p></dd></dl>

<dl>
<dt id="index-BLOWFISH_005fMIN_005fKEY_005fSIZE">Constant: <strong>BLOWFISH_MIN_KEY_SIZE</strong></dt>
<dd><p>Minimum BLOWFISH key size, 8.
</p></dd></dl>

<dl>
<dt id="index-BLOWFISH_005fMAX_005fKEY_005fSIZE">Constant: <strong>BLOWFISH_MAX_KEY_SIZE</strong></dt>
<dd><p>Maximum BLOWFISH key size, 56.
</p></dd></dl>

<dl>
<dt id="index-BLOWFISH_005fKEY_005fSIZE">Constant: <strong>BLOWFISH_KEY_SIZE</strong></dt>
<dd><p>Default BLOWFISH key size, 16.
</p></dd></dl>

<dl>
<dt id="index-blowfish_005fset_005fkey">Function: <em>int</em> <strong>blowfish_set_key</strong> <em>(struct blowfish_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. Checks for weak keys, returning 1
for good keys and 0 for weak keys. Applications that don&rsquo;t care about
weak keys can ignore the return value.
</p>
<p><code>blowfish_encrypt</code> or <code>blowfish_decrypt</code> with a weak key will
crash with an assert violation.
</p></dd></dl>

<dl>
<dt id="index-blowfish_005fencrypt">Function: <em>void</em> <strong>blowfish_encrypt</strong> <em>(struct blowfish_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-blowfish_005fdecrypt">Function: <em>void</em> <strong>blowfish_decrypt</strong> <em>(struct blowfish_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>blowfish_encrypt</code>
</p></dd></dl>

<dl>
<dt id="index-blowfish_005fbcrypt_005fhash">Function: <em>int</em> <strong>blowfish_bcrypt_hash</strong> <em>(char *<var>dst</var>, size_t <var>lenkey</var>, const char *<var>key</var>, size_t <var>lenscheme</var>, const char *<var>scheme</var>, int <var>log2rounds</var>, const uint8_t *<var>salt</var>)</em></dt>
<dd><p>Compute the bcrypt password hash.
The function will return <code>0</code> if the hash cannot be computed
due to invalid input.
The function will return <code>1</code> and store the computed hash
in the array pointed to by <var>dst</var>.  The hash is computed based
on the chosen <var>scheme</var>, number of rounds <var>log2rounds</var> and
specified <var>salt</var>.
</p>
<p><var>dst</var> must point to a character array of at least
 <code>BLOWFISH_BCRYPT_HASH_SIZE</code> bytes.
</p>
<p><var>key</var> contains the plaintext password string of size <var>lenkey</var>.
</p>
<p><var>scheme</var> is of size <var>lenscheme</var> and contains either just the
chosen scheme (valid schemes
are: <code>2a</code>, <code>2b</code>, <code>2x</code> or <code>2y</code>), or
(the prefix of) an existing hashed password (typically <code>$2b$10$...</code>).
</p>
<p><var>log2rounds</var> contains the log2 of the number of encryption rounds
that must be used to compute the hash.  If it is <code>-1</code> the value
will be extracted from <var>scheme</var>.
</p>
<p><var>salt</var> should point to an array of <code>BLOWFISH_BCRYPT_BINSALT_SIZE</code>
random bytes to be used to perturb the hash computation.  If it is <code>NULL</code>
the salt will be extracted from <var>scheme</var>.
</p>
<p>Sample code to generate a bcrypt hash:
</p><div class="example">
<pre class="example">char password[] = &quot;ExamplePassword&quot;;
char scheme[] = &quot;2b&quot;;
uint8_t salt[BLOWFISH_BCRYPT_BINSALT_SIZE];
&hellip;
/* Make sure that salt is filled with random bytes */
&hellip;
char hash[BLOWFISH_BCRYPT_HASH_SIZE];
int result = blowfish_bcrypt(hash,
                             sizeof(password) - 1, password,
                             sizeof(scheme) - 1, scheme, 10, salt);
if (result)
  printf(&quot;%s\n&quot;, hash);
</pre></div>
</dd></dl>

<dl>
<dt id="index-blowfish_005fbcrypt_005fverify">Function: <em>int</em> <strong>blowfish_bcrypt_verify</strong> <em>(size_t <var>lenkey</var>, const char *<var>key</var>, size_t <var>lenhashed</var>, const char *<var>hashed</var>)</em></dt>
<dd><p>Verifies the bcrypt password hash against the supplied plaintext password.
The function will return <code>0</code> if the password does not match.
The function will return <code>1</code> if the password matches.
</p>
<p><var>key</var> contains the plaintext password string of size <var>lenkey</var>.
</p>
<p><var>hashed</var> contains the hashed string of size <var>lenhashed</var> to compare with.
</p>
<p>Sample code to verify a bcrypt hash:
</p><div class="example">
<pre class="example">char password[] = &quot;ExamplePassword&quot;;
char hash[] =
  &quot;$2y$&quot;  /* Hash algorithm version */
  &quot;10&quot;   /* 2^10 hash rounds (strength) */
  &quot;$&quot;   /* separator */
  &quot;1b2lPgo4XumibnJGN3r3sO&quot; /* base64 encoded 16-byte salt */
  &quot;u7wE7xNfYDKlAxZffJDCJdVfFTAyevu&quot;; /* Hashedpart */
if (blowfish_bcrypt_verify(sizeof(password) - 1, password,
                           sizeof(hash) - 1, hash))
  printf(&quot;Password is correct.&quot;);
else
  printf(&quot;Password is incorrect.&quot;);
</pre></div>
</dd></dl>

<hr>
<span id="Camellia"></span><div class="header">
<p>
Next: <a href="#CAST128" accesskey="n" rel="next">CAST128</a>, Previous: <a href="#Blowfish" accesskey="p" rel="prev">Blowfish</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Camellia-1"></span><h4 class="subsection">7.2.5 Camellia</h4>
<span id="index-Camellia"></span>

<p>Camellia is a block cipher developed by Mitsubishi and Nippon Telegraph
and Telephone Corporation, described in <cite>RFC3713</cite>. It is
recommended by some Japanese and European authorities as an alternative
to AES, and it is one of the selected algorithms in the New European
Schemes for Signatures, Integrity and Encryption (NESSIE) project. The
algorithm is patented. The implementation in Nettle is derived from the
implementation released by NTT under the GNU LGPL (v2.1 or later), and
relies on the implicit patent license of the LGPL. There is also a
statement of royalty-free licensing for Camellia at
<a href="https://www.ntt.co.jp/news/news01e/0104/010417.html">https://www.ntt.co.jp/news/news01e/0104/010417.html</a>, but this
statement has some limitations which seem problematic for free software.
</p>
<p>Camellia uses a the same block size and key sizes as AES: The block size
is 128 bits (16 octets), and the supported key sizes are 128, 192, and
256 bits. The variants with 192 and 256 bit keys are identical, except
for the key setup. Nettle defines Camellia in
<samp>&lt;nettle/camellia.h&gt;</samp>, and there is one context struct for each key
size. (Earlier versions of Nettle used a single context struct,
<code>struct camellia_ctx</code>, for all key sizes. This interface kept for
backwards compatibility).
</p>
<dl>
<dt id="index-struct-camellia128_005fctx">Context struct: <strong>struct camellia128_ctx</strong></dt>
<dt id="index-struct-camellia192_005fctx">Context struct: <strong>struct camellia192_ctx</strong></dt>
<dt id="index-struct-camellia256_005fctx">Context struct: <strong>struct camellia256_ctx</strong></dt>
<dd><p>Contexts structs. Actually, <code>camellia192_ctx</code> is an alias for
<code>camellia256_ctx</code>.
</p></dd></dl>

<dl>
<dt id="index-struct-camellia_005fctx">Context struct: <strong>struct camellia_ctx</strong></dt>
<dd><p>Alternative struct, for the old Camellia interface.
</p></dd></dl>

<dl>
<dt id="index-CAMELLIA_005fBLOCK_005fSIZE">Constant: <strong>CAMELLIA_BLOCK_SIZE</strong></dt>
<dd><p>The CAMELLIA block-size, 16.
</p></dd></dl>

<dl>
<dt id="index-CAMELLIA128_005fKEY_005fSIZE">Constant: <strong>CAMELLIA128_KEY_SIZE</strong></dt>
<dt id="index-CAMELLIA192_005fKEY_005fSIZE">Constant: <strong>CAMELLIA192_KEY_SIZE</strong></dt>
<dt id="index-CAMELLIA256_005fKEY_005fSIZE">Constant: <strong>CAMELLIA256_KEY_SIZE</strong></dt>
<dt id="index-CAMELLIA_005fMIN_005fKEY_005fSIZE">Constant: <strong>CAMELLIA_MIN_KEY_SIZE</strong></dt>
<dt id="index-CAMELLIA_005fMAX_005fKEY_005fSIZE">Constant: <strong>CAMELLIA_MAX_KEY_SIZE</strong></dt>
</dl>

<dl>
<dt id="index-CAMELLIA_005fKEY_005fSIZE">Constant: <strong>CAMELLIA_KEY_SIZE</strong></dt>
<dd><p>Default CAMELLIA key size, 32.
</p></dd></dl>

<dl>
<dt id="index-camellia128_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>camellia128_set_encrypt_key</strong> <em>(struct camellia128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia128_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>camellia128_set_decrypt_key</strong> <em>(struct camellia128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia192_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>camellia192_set_encrypt_key</strong> <em>(struct camellia192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia192_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>camellia192_set_decrypt_key</strong> <em>(struct camellia192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia256_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>camellia256_set_encrypt_key</strong> <em>(struct camellia256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia256_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>camellia256_set_decrypt_key</strong> <em>(struct camellia256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>camellia_set_encrypt_key</strong> <em>(struct camellia_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-camellia_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>camellia_set_decrypt_key</strong> <em>(struct camellia_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher, for encryption or decryption, respectively.
</p></dd></dl>

<dl>
<dt id="index-camellia128_005finvert_005fkey">Function: <em>void</em> <strong>camellia128_invert_key</strong> <em>(struct camellia128_ctx *<var>dst</var>, const struct camellia128_ctx *<var>src</var>)</em></dt>
<dt id="index-camellia192_005finvert_005fkey">Function: <em>void</em> <strong>camellia192_invert_key</strong> <em>(struct camellia192_ctx *<var>dst</var>, const struct camellia192_ctx *<var>src</var>)</em></dt>
<dt id="index-camellia256_005finvert_005fkey">Function: <em>void</em> <strong>camellia256_invert_key</strong> <em>(struct camellia256_ctx *<var>dst</var>, const struct camellia256_ctx *<var>src</var>)</em></dt>
<dt id="index-camellia_005finvert_005fkey">Function: <em>void</em> <strong>camellia_invert_key</strong> <em>(struct camellia_ctx *<var>dst</var>, const struct camellia_ctx *<var>src</var>)</em></dt>
<dd><p>Given a context <var>src</var> initialized for encryption, initializes the
context struct <var>dst</var> for decryption, using the same key. If the same
context struct is passed for both <code>src</code> and <code>dst</code>, it is
converted in place. These functions are mainly useful for applications
which needs to both encrypt and decrypt using the <em>same</em> key.
</p></dd></dl>

<dl>
<dt id="index-camellia128_005fcrypt">Function: <em>void</em> <strong>camellia128_crypt</strong> <em>(struct camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-camellia192_005fcrypt">Function: <em>void</em> <strong>camellia192_crypt</strong> <em>(struct camellia192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-camellia256_005fcrypt">Function: <em>void</em> <strong>camellia256_crypt</strong> <em>(struct camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-camellia_005fcrypt">Function: <em>void</em> <strong>camellia_crypt</strong> <em>(struct camellia_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>The same function is used for both encryption and decryption.
<var>length</var> must be an integral multiple of the block size. If it is
more than one block, the data is processed in ECB mode. <code>src</code> and
<code>dst</code> may be equal, but they must not overlap in any other way.
</p></dd></dl>

<hr>
<span id="CAST128"></span><div class="header">
<p>
Next: <a href="#ChaCha" accesskey="n" rel="next">ChaCha</a>, Previous: <a href="#Camellia" accesskey="p" rel="prev">Camellia</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="CAST128-1"></span><h4 class="subsection">7.2.6 CAST128</h4>
<span id="index-CAST"></span>

<p>CAST-128 is a block cipher, specified in <cite>RFC 2144</cite>. It uses a 64
bit (8 octets) block size, and a key size of 128 bits. It is possible,
but discouraged, to use the same algorithm with shorter keys. Nettle
refers to the variant with variable key size as CAST-5. Keys for CAST-5
are zero padded to 128 bits, and with very short keys, less than 80
bits, encryption also uses fewer rounds than CAST128. Nettle defines
cast128 in <samp>&lt;nettle/cast128.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-cast128_005fctx">Context struct: <strong>struct cast128_ctx</strong></dt>
</dl>

<dl>
<dt id="index-CAST128_005fBLOCK_005fSIZE">Constant: <strong>CAST128_BLOCK_SIZE</strong></dt>
<dd><p>The CAST128 block-size, 8.
</p></dd></dl>

<dl>
<dt id="index-CAST128_005fKEY_005fSIZE">Constant: <strong>CAST128_KEY_SIZE</strong></dt>
<dd><p>The CAST128 key size, 16.
</p></dd></dl>

<dl>
<dt id="index-CAST5_005fMIN_005fKEY_005fSIZE">Constant: <strong>CAST5_MIN_KEY_SIZE</strong></dt>
<dd><p>Minimum CAST5 key size, 5.
</p></dd></dl>

<dl>
<dt id="index-CAST5_005fMAX_005fKEY_005fSIZE">Constant: <strong>CAST5_MAX_KEY_SIZE</strong></dt>
<dd><p>Maximum CAST5 key size, 16. With 16 octets key (128 bits), CAST-5 is the
same as CAST-128.
</p></dd></dl>

<dl>
<dt id="index-cast128_005fset_005fkey">Function: <em>void</em> <strong>cast128_set_key</strong> <em>(struct cast128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></dd></dl>

<dl>
<dt id="index-cast128_005fencrypt">Function: <em>void</em> <strong>cast128_encrypt</strong> <em>(struct cast128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-cast128_005fdecrypt">Function: <em>void</em> <strong>cast128_decrypt</strong> <em>(struct cast128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>cast128_encrypt</code>
</p></dd></dl>

<dl>
<dt id="index-cast5_005fset_005fkey">Function: <em>void</em> <strong>cast5_set_key</strong> <em>(struct cast128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. This variant of the key setup takes the key size
as argument. The same function is used for both encryption and
decryption.
</p></dd></dl>

<hr>
<span id="ChaCha"></span><div class="header">
<p>
Next: <a href="#DES" accesskey="n" rel="next">DES</a>, Previous: <a href="#CAST128" accesskey="p" rel="prev">CAST128</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="ChaCha-1"></span><h4 class="subsection">7.2.7 ChaCha</h4>
<span id="index-ChaCha"></span>

<p>ChaCha is a variant of the stream cipher Salsa20 (see <a href="#Salsa20">Salsa20</a>),
below, also designed by D. J. Bernstein. Nettle defines ChaCha in
<samp>&lt;nettle/chacha.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-chacha_005fctx">Context struct: <strong>struct chacha_ctx</strong></dt>
</dl>

<dl>
<dt id="index-CHACHA_005fKEY_005fSIZE">Constant: <strong>CHACHA_KEY_SIZE</strong></dt>
<dd><p>ChaCha key size, 32.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fBLOCK_005fSIZE">Constant: <strong>CHACHA_BLOCK_SIZE</strong></dt>
<dd><p>ChaCha block size, 64.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fNONCE_005fSIZE">Constant: <strong>CHACHA_NONCE_SIZE</strong></dt>
<dd><p>Size of the nonce, 8.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fCOUNTER_005fSIZE">Constant: <strong>CHACHA_COUNTER_SIZE</strong></dt>
<dd><p>Size of the counter, 8.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fset_005fkey">Function: <em>void</em> <strong>chacha_set_key</strong> <em>(struct chacha_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. Before using the cipher,
you <em>must</em> also call <code>chacha_set_nonce</code>, see below.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fset_005fnonce">Function: <em>void</em> <strong>chacha_set_nonce</strong> <em>(struct chacha_ctx *<var>ctx</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Sets the nonce. It is always of size <code>CHACHA_NONCE_SIZE</code>, 8
octets. This function also initializes the block counter, setting it to
zero.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fset_005fcounter">Function: <em>void</em> <strong>chacha_set_counter</strong> <em>(struct chacha_ctx *<var>ctx</var>, const uint8_t *<var>counter</var>)</em></dt>
<dd><p>Sets the block counter. It is always of size <code>CHACHA_COUNTER_SIZE</code>,
8 octets. This is rarely needed since <code>chacha_set_nonce</code>
initializes the block counter to zero. When it is still necessary, this
function must be called after <code>chacha_set_nonce</code>.
</p>
</dd></dl>

<dl>
<dt id="index-chacha_005fcrypt">Function: <em>void</em> <strong>chacha_crypt</strong> <em>(struct chacha_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message, using ChaCha. When a
message is encrypted using a sequence of calls to <code>chacha_crypt</code>,
all but the last call <em>must</em> use a length that is a multiple of
<code>CHACHA_BLOCK_SIZE</code>.
</p></dd></dl>

<span id="g_t32_002dbit-counter-variant"></span><h4 class="subsubsection">7.2.7.1 32-bit counter variant</h4>

<p>While the original paper uses 64-bit counter value, the variant defined
in <cite>RFC 8439</cite> uses 32-bit counter value. This variant is
particularly useful for see <a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a> AEAD construction, which
supports 12-octet nonces.
</p>
<dl>
<dt id="index-CHACHA_005fNONCE96_005fSIZE">Constant: <strong>CHACHA_NONCE96_SIZE</strong></dt>
<dd><p>Size of the nonce, 12.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fCOUNTER32_005fSIZE">Constant: <strong>CHACHA_COUNTER32_SIZE</strong></dt>
<dd><p>Size of the counter, 4.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fset_005fnonce96">Function: <em>void</em> <strong>chacha_set_nonce96</strong> <em>(struct chacha_ctx *<var>ctx</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Sets the nonce. This is similar to the above <code>chacha_set_nonce</code>,
but the input is always of size <code>CHACHA_NONCE96_SIZE</code>, 12 octets.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fset_005fcounter32">Function: <em>void</em> <strong>chacha_set_counter32</strong> <em>(struct chacha_ctx *<var>ctx</var>, const uint8_t *<var>counter</var>)</em></dt>
<dd><p>Sets the block counter. This is similar to the above <code>chacha_set_counter</code>,
but the input is always of size <code>CHACHA_COUNTER32_SIZE</code>, 4 octets.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fcrypt32">Function: <em>void</em> <strong>chacha_crypt32</strong> <em>(struct chacha_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message, using ChaCha. This is similar to the
above <code>chacha_crypt</code>, but it assumes the internal counter value is 32-bit
long and the nonce is 96-bit long.
</p></dd></dl>

<hr>
<span id="DES"></span><div class="header">
<p>
Next: <a href="#DES3" accesskey="n" rel="next">DES3</a>, Previous: <a href="#ChaCha" accesskey="p" rel="prev">ChaCha</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DES-1"></span><h4 class="subsection">7.2.8 DES</h4>
<span id="index-DES"></span>

<p>DES is the old Data Encryption Standard, specified by NIST. It uses a
block size of 64 bits (8 octets), and a key size of 56 bits. However,
the key bits are distributed over 8 octets, where the least significant
bit of each octet may be used for parity. A common way to use DES is to
generate 8 random octets in some way, then set the least significant bit
of each octet to get odd parity, and initialize DES with the resulting
key.
</p>
<p>The key size of DES is so small that keys can be found by brute force,
using specialized hardware or lots of ordinary work stations in
parallel. One shouldn&rsquo;t be using plain DES at all today, if one uses
DES at all one should be using &ldquo;triple DES&rdquo;, see DES3 below.
</p>
<p>DES also has some weak keys. Nettle defines DES in <samp>&lt;nettle/des.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-des_005fctx">Context struct: <strong>struct des_ctx</strong></dt>
</dl>

<dl>
<dt id="index-DES_005fBLOCK_005fSIZE">Constant: <strong>DES_BLOCK_SIZE</strong></dt>
<dd><p>The DES block-size, 8.
</p></dd></dl>

<dl>
<dt id="index-DES_005fKEY_005fSIZE">Constant: <strong>DES_KEY_SIZE</strong></dt>
<dd><p>DES key size, 8.
</p></dd></dl>

<dl>
<dt id="index-des_005fset_005fkey">Function: <em>int</em> <strong>des_set_key</strong> <em>(struct des_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. Parity bits are ignored. Checks for weak keys, returning 1
for good keys and 0 for weak keys. Applications that don&rsquo;t care about
weak keys can ignore the return value.
</p></dd></dl>

<dl>
<dt id="index-des_005fencrypt">Function: <em>void</em> <strong>des_encrypt</strong> <em>(struct des_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-des_005fdecrypt">Function: <em>void</em> <strong>des_decrypt</strong> <em>(struct des_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>des_encrypt</code>
</p></dd></dl>

<dl>
<dt id="index-des_005fcheck_005fparity">Function: <em>int</em> <strong>des_check_parity</strong> <em>(size_t <var>length</var>, const uint8_t *<var>key</var>);</em></dt>
<dd><p>Checks that the given key has correct, odd, parity. Returns 1 for
correct parity, and 0 for bad parity.
</p></dd></dl>

<dl>
<dt id="index-des_005ffix_005fparity">Function: <em>void</em> <strong>des_fix_parity</strong> <em>(size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Adjusts the parity bits to match DES&rsquo;s requirements. You need this
function if you have created a random-looking string by a key agreement
protocol, and want to use it as a DES key. <var>dst</var> and <var>src</var> may
be equal.
</p></dd></dl>

<hr>
<span id="DES3"></span><div class="header">
<p>
Next: <a href="#Salsa20" accesskey="n" rel="next">Salsa20</a>, Previous: <a href="#DES" accesskey="p" rel="prev">DES</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DES3-1"></span><h4 class="subsection">7.2.9 DES3</h4>
<span id="index-DES3"></span>
<span id="index-3DES"></span>
<span id="index-Triple_002dDES"></span>

<p>The inadequate key size of DES has already been mentioned. One way to
increase the key size is to pipe together several DES boxes with
independent keys. It turns out that using two DES ciphers is not as
secure as one might think, even if the key size of the combination is a
respectable 112 bits.
</p>
<p>The standard way to increase DES&rsquo;s key size is to use three DES boxes.
The mode of operation is a little peculiar: the middle DES box is wired
in the reverse direction. To encrypt a block with DES3, you encrypt it
using the first 56 bits of the key, then <em>decrypt</em> it using the
middle 56 bits of the key, and finally encrypt it again using the last
56 bits of the key. This is known as &ldquo;ede&rdquo; triple-DES, for
&ldquo;encrypt-decrypt-encrypt&rdquo;.
</p>
<p>The &ldquo;ede&rdquo; construction provides some backward compatibility, as you get
plain single DES simply by feeding the same key to all three boxes. That
should help keeping down the gate count, and the price, of hardware
circuits implementing both plain DES and DES3.
</p>
<p>DES3 has a key size of 168 bits, but just like plain DES, useless parity
bits are inserted, so that keys are represented as 24 octets (192 bits).
As a 112 bit key is large enough to make brute force attacks
impractical, some applications uses a &ldquo;two-key&rdquo; variant of triple-DES.
In this mode, the same key bits are used for the first and the last DES
box in the pipe, while the middle box is keyed independently. The
two-key variant is believed to be secure, i.e. there are no known
attacks significantly better than brute force.
</p>
<p>Naturally, it&rsquo;s simple to implement triple-DES on top of Nettle&rsquo;s DES
functions. Nettle includes an implementation of three-key &ldquo;ede&rdquo;
triple-DES, it is defined in the same place as plain DES,
<samp>&lt;nettle/des.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-des3_005fctx">Context struct: <strong>struct des3_ctx</strong></dt>
</dl>

<dl>
<dt id="index-DES3_005fBLOCK_005fSIZE">Constant: <strong>DES3_BLOCK_SIZE</strong></dt>
<dd><p>The DES3 block-size is the same as DES_BLOCK_SIZE, 8.
</p></dd></dl>

<dl>
<dt id="index-DES3_005fKEY_005fSIZE">Constant: <strong>DES3_KEY_SIZE</strong></dt>
<dd><p>DES key size, 24.
</p></dd></dl>

<dl>
<dt id="index-des3_005fset_005fkey">Function: <em>int</em> <strong>des3_set_key</strong> <em>(struct des3_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. Parity bits are ignored. Checks for weak keys, returning 1
if all three keys are good keys, and 0 if one or more key is weak.
Applications that don&rsquo;t care about weak keys can ignore the return
value.
</p></dd></dl>

<p>For random-looking strings, you can use <code>des_fix_parity</code> to adjust
the parity bits before calling <code>des3_set_key</code>.
</p>
<dl>
<dt id="index-des3_005fencrypt">Function: <em>void</em> <strong>des3_encrypt</strong> <em>(struct des3_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-des3_005fdecrypt">Function: <em>void</em> <strong>des3_decrypt</strong> <em>(struct des3_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>des_encrypt</code>
</p></dd></dl>

<hr>
<span id="Salsa20"></span><div class="header">
<p>
Next: <a href="#Serpent" accesskey="n" rel="next">Serpent</a>, Previous: <a href="#DES3" accesskey="p" rel="prev">DES3</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Salsa20-1"></span><h4 class="subsection">7.2.10 Salsa20</h4>
<span id="index-Salsa20"></span>

<p>Salsa20 is a fairly recent stream cipher designed by D. J. Bernstein. It
is built on the observation that a cryptographic hash function can be
used for encryption: Form the hash input from the secret key and a
counter, xor the hash output and the first block of the plaintext, then
increment the counter to process the next block (similar to CTR mode,
see <a href="#CTR">CTR</a>). Bernstein defined an encryption algorithm, Snuffle,
in this way to ridicule United States export restrictions which treated hash
functions as nice and harmless, but ciphers as dangerous munitions.
</p>
<p>Salsa20 uses the same idea, but with a new specialized hash function to
mix key, block counter, and a couple of constants. It&rsquo;s also designed
for speed; on x86_64, it is currently the fastest cipher offered by
nettle. It uses a block size of 512 bits (64 octets) and there are two
specified key sizes, 128 and 256 bits (16 and 32 octets).
</p>
<p><strong>Caution:</strong> The hash function used in Salsa20 is <em>not</em>
directly applicable for use as a general hash function. It&rsquo;s <em>not</em>
collision resistant if arbitrary inputs are allowed, and furthermore,
the input and output is of fixed size.
</p>
<p>When using Salsa20 to process a message, one specifies both a key and a
<em>nonce</em>, the latter playing a similar rÃ´le to the initialization
vector (<acronym>IV</acronym>) used with <acronym>CBC</acronym> or <acronym>CTR</acronym> mode. One
can use the same key for several messages, provided one uses a unique
random <acronym>iv</acronym> for each message. The <acronym>iv</acronym> is 64 bits (8
octets). The block counter is initialized to zero for each message, and
is also 64 bits (8 octets). Nettle defines Salsa20 in
<samp>&lt;nettle/salsa20.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-salsa20_005fctx">Context struct: <strong>struct salsa20_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SALSA20_005f128_005fKEY_005fSIZE">Constant: <strong>SALSA20_128_KEY_SIZE</strong></dt>
<dt id="index-SALSA20_005f256_005fKEY_005fSIZE">Constant: <strong>SALSA20_256_KEY_SIZE</strong></dt>
<dd><p>The two supported key sizes, 16 and 32 octets.
</p></dd></dl>

<dl>
<dt id="index-SALSA20_005fKEY_005fSIZE">Constant: <strong>SALSA20_KEY_SIZE</strong></dt>
<dd><p>Recommended key size, 32.
</p></dd></dl>

<dl>
<dt id="index-SALSA20_005fBLOCK_005fSIZE">Constant: <strong>SALSA20_BLOCK_SIZE</strong></dt>
<dd><p>Salsa20 block size, 64.
</p></dd></dl>

<dl>
<dt id="index-SALSA20_005fNONCE_005fSIZE">Constant: <strong>SALSA20_NONCE_SIZE</strong></dt>
<dd><p>Size of the nonce, 8.
</p></dd></dl>

<dl>
<dt id="index-salsa20_005f128_005fset_005fkey">Function: <em>void</em> <strong>salsa20_128_set_key</strong> <em>(struct salsa20_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-salsa20_005f256_005fset_005fkey">Function: <em>void</em> <strong>salsa20_256_set_key</strong> <em>(struct salsa20_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-salsa20_005fset_005fkey">Function: <em>void</em> <strong>salsa20_set_key</strong> <em>(struct salsa20_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. <code>salsa20_128_set_key</code> and <code>salsa20_128_set_key</code>
use a fix key size each, 16 and 32 octets, respectively. The function
<code>salsa20_set_key</code> is provided for backwards compatibility, and the
<var>length</var> argument must be either 16 or 32. Before using the cipher,
you <em>must</em> also call <code>salsa20_set_nonce</code>, see below.
</p></dd></dl>

<dl>
<dt id="index-salsa20_005fset_005fnonce">Function: <em>void</em> <strong>salsa20_set_nonce</strong> <em>(struct salsa20_ctx *<var>ctx</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Sets the nonce. It is always of size <code>SALSA20_NONCE_SIZE</code>, 8
octets. This function also initializes the block counter, setting it to
zero.
</p></dd></dl>

<dl>
<dt id="index-salsa20_005fcrypt">Function: <em>void</em> <strong>salsa20_crypt</strong> <em>(struct salsa20_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message, using salsa20. When a
message is encrypted using a sequence of calls to <code>salsa20_crypt</code>,
all but the last call <em>must</em> use a length that is a multiple of
<code>SALSA20_BLOCK_SIZE</code>.
</p></dd></dl>

<p>The full salsa20 cipher uses 20 rounds of mixing. Variants of Salsa20
with fewer rounds are possible, and the 12-round variant is specified by
eSTREAM, see <a href="https://www.ecrypt.eu.org/stream/finallist.html">https://www.ecrypt.eu.org/stream/finallist.html</a>.
Nettle calls this variant <code>salsa20r12</code>. It uses the same context
struct and key setup as the full salsa20 cipher, but a separate function
for encryption and decryption.
</p>
<dl>
<dt id="index-salsa20r12_005fcrypt">Function: <em>void</em> <strong>salsa20r12_crypt</strong> <em>(struct salsa20_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message, using salsa20 reduced to 12
rounds.
</p></dd></dl>

<hr>
<span id="Serpent"></span><div class="header">
<p>
Next: <a href="#Twofish" accesskey="n" rel="next">Twofish</a>, Previous: <a href="#Salsa20" accesskey="p" rel="prev">Salsa20</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Serpent-1"></span><h4 class="subsection">7.2.11 Serpent</h4>
<span id="index-Serpent"></span>

<p>SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
Biham and Lars Knudsen. Thus, the interface and properties are similar
to AES&rsquo;. One peculiarity is that it is quite pointless to use it with
anything but the maximum key size, smaller keys are just padded to
larger ones. Nettle defines SERPENT in <samp>&lt;nettle/serpent.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-serpent_005fctx">Context struct: <strong>struct serpent_ctx</strong></dt>
</dl>

<dl>
<dt id="index-SERPENT_005fBLOCK_005fSIZE">Constant: <strong>SERPENT_BLOCK_SIZE</strong></dt>
<dd><p>The SERPENT block-size, 16.
</p></dd></dl>

<dl>
<dt id="index-SERPENT_005fMIN_005fKEY_005fSIZE">Constant: <strong>SERPENT_MIN_KEY_SIZE</strong></dt>
<dd><p>Minimum SERPENT key size, 16.
</p></dd></dl>

<dl>
<dt id="index-SERPENT_005fMAX_005fKEY_005fSIZE">Constant: <strong>SERPENT_MAX_KEY_SIZE</strong></dt>
<dd><p>Maximum SERPENT key size, 32.
</p></dd></dl>

<dl>
<dt id="index-SERPENT_005fKEY_005fSIZE">Constant: <strong>SERPENT_KEY_SIZE</strong></dt>
<dd><p>Default SERPENT key size, 32.
</p></dd></dl>

<dl>
<dt id="index-serpent_005fset_005fkey">Function: <em>void</em> <strong>serpent_set_key</strong> <em>(struct serpent_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></dd></dl>

<dl>
<dt id="index-serpent_005fencrypt">Function: <em>void</em> <strong>serpent_encrypt</strong> <em>(struct serpent_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-serpent_005fdecrypt">Function: <em>void</em> <strong>serpent_decrypt</strong> <em>(struct serpent_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>serpent_encrypt</code>
</p></dd></dl>

<hr>
<span id="Twofish"></span><div class="header">
<p>
Next: <a href="#nettle_005fcipher-abstraction" accesskey="n" rel="next">nettle_cipher abstraction</a>, Previous: <a href="#Serpent" accesskey="p" rel="prev">Serpent</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Twofish-1"></span><h4 class="subsection">7.2.12 Twofish</h4>
<span id="index-Twofish"></span>

<p>Another AES finalist, this one designed by Bruce Schneier and others.
Nettle defines it in <samp>&lt;nettle/twofish.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-twofish_005fctx">Context struct: <strong>struct twofish_ctx</strong></dt>
</dl>

<dl>
<dt id="index-TWOFISH_005fBLOCK_005fSIZE">Constant: <strong>TWOFISH_BLOCK_SIZE</strong></dt>
<dd><p>The TWOFISH block-size, 16.
</p></dd></dl>

<dl>
<dt id="index-TWOFISH_005fMIN_005fKEY_005fSIZE">Constant: <strong>TWOFISH_MIN_KEY_SIZE</strong></dt>
<dd><p>Minimum TWOFISH key size, 16.
</p></dd></dl>

<dl>
<dt id="index-TWOFISH_005fMAX_005fKEY_005fSIZE">Constant: <strong>TWOFISH_MAX_KEY_SIZE</strong></dt>
<dd><p>Maximum TWOFISH key size, 32.
</p></dd></dl>

<dl>
<dt id="index-TWOFISH_005fKEY_005fSIZE">Constant: <strong>TWOFISH_KEY_SIZE</strong></dt>
<dd><p>Default TWOFISH key size, 32.
</p></dd></dl>

<dl>
<dt id="index-twofish_005fset_005fkey">Function: <em>void</em> <strong>twofish_set_key</strong> <em>(struct twofish_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></dd></dl>

<dl>
<dt id="index-twofish_005fencrypt">Function: <em>void</em> <strong>twofish_encrypt</strong> <em>(struct twofish_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way.
</p></dd></dl>

<dl>
<dt id="index-twofish_005fdecrypt">Function: <em>void</em> <strong>twofish_decrypt</strong> <em>(struct twofish_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Analogous to <code>twofish_encrypt</code>
</p></dd></dl>

<hr>
<span id="nettle_005fcipher-abstraction"></span><div class="header">
<p>
Previous: <a href="#Twofish" accesskey="p" rel="prev">Twofish</a>, Up: <a href="#Cipher-functions" accesskey="u" rel="up">Cipher functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-struct-nettle_005fcipher-abstraction"></span><h4 class="subsection">7.2.13 The <code>struct nettle_cipher</code> abstraction</h4>
<span id="index-nettle_005fcipher"></span>

<p>Nettle includes a struct including information about some of the more
regular cipher functions. It can be useful for applications that need a
simple way to handle various algorithms. Nettle defines these structs in
<samp>&lt;nettle/nettle-meta.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-nettle_005fcipher">Meta struct: <strong><code>struct nettle_cipher</code></strong> <em>name context_size block_size key_size set_encrypt_key set_decrypt_key encrypt decrypt</em></dt>
<dd><p>The last four attributes are function pointers, of types
<code>nettle_set_key_func *</code> and <code>nettle_cipher_func *</code>. The first
argument to these functions is a <code>const void *</code> pointer to a context
struct, which is of size <code>context_size</code>.
</p></dd></dl>

<dl>
<dt id="index-nettle_005faes128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_aes128</strong></dt>
<dt id="index-nettle_005faes192">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_aes192</strong></dt>
<dt id="index-nettle_005faes256">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_aes256</strong></dt>
<dt id="index-nettle_005farctwo40">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_arctwo40</strong></dt>
<dt id="index-nettle_005farctwo64">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_arctwo64</strong></dt>
<dt id="index-nettle_005farctwo128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_arctwo128</strong></dt>
<dt id="index-nettle_005farctwo_005fgutmann128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_arctwo_gutmann128</strong></dt>
<dt id="index-nettle_005farcfour128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_arcfour128</strong></dt>
<dt id="index-nettle_005fcamellia128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_camellia128</strong></dt>
<dt id="index-nettle_005fcamellia192">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_camellia192</strong></dt>
<dt id="index-nettle_005fcamellia256">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_camellia256</strong></dt>
<dt id="index-nettle_005fcast128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_cast128</strong></dt>
<dt id="index-nettle_005fserpent128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_serpent128</strong></dt>
<dt id="index-nettle_005fserpent192">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_serpent192</strong></dt>
<dt id="index-nettle_005fserpent256">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_serpent256</strong></dt>
<dt id="index-nettle_005ftwofish128">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_twofish128</strong></dt>
<dt id="index-nettle_005ftwofish192">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_twofish192</strong></dt>
<dt id="index-nettle_005ftwofish256">Constant Struct: <em>struct nettle_cipher</em> <strong>nettle_twofish256</strong></dt>
<dd><p>Nettle includes such structs for all the <em>regular</em> ciphers, i.e.
ones without weak keys or other oddities.
</p></dd></dl>

<p>Nettle also exports a list of all these ciphers without weak keys or
other oddities.
</p>
<dl>
<dt id="index-nettle_005fget_005fciphers">Function: <em>const struct nettle_cipher **</em> <strong>nettle_get_ciphers</strong> <em>(void)</em></dt>
<dd><p>Returns a NULL-terminated list of pointers to supported block ciphers.
This list can be used to dynamically enumerate or search the supported
algorithms.
</p></dd></dl>

<dl>
<dt id="index-nettle_005fciphers">Macro: <strong>nettle_ciphers</strong></dt>
<dd><p>A macro expanding to a call to nettle_get_ciphers. In earlier versions,
this was not a macro but the actual array of pointers.
</p></dd></dl>

<hr>
<span id="Cipher-modes"></span><div class="header">
<p>
Next: <a href="#Authenticated-encryption" accesskey="n" rel="next">Authenticated encryption</a>, Previous: <a href="#Cipher-functions" accesskey="p" rel="prev">Cipher functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cipher-modes-1"></span><h3 class="section">7.3 Cipher modes</h3>

<p>Cipher modes of operation specifies the procedure to use when encrypting
a message that is larger than the cipher&rsquo;s block size. As explained in
See <a href="#Cipher-functions">Cipher functions</a>, splitting the message into blocks and
processing them independently with the block cipher (Electronic Code
Book mode, <acronym>ECB</acronym>), leaks information.
</p>
<p>Besides <acronym>ECB</acronym>, Nettle provides several other modes of operation:
Cipher Block Chaining (<acronym>CBC</acronym>), Counter mode (<acronym>CTR</acronym>), Cipher
Feedback (<acronym>CFB</acronym> and <acronym>CFB8</acronym>), XEX-based tweaked-codebook mode
with ciphertext stealing (<acronym>XTS</acronym>) and a couple of <acronym>AEAD</acronym>
modes (see <a href="#Authenticated-encryption">Authenticated encryption</a>).  <acronym>CBC</acronym> is widely used, but
there are a few subtle issues of information leakage, see, e.g.,
<a href="https://www.kb.cert.org/vuls/id/958563"><acronym>SSH</acronym> <acronym>CBC</acronym>
vulnerability</a>. Today, <acronym>CTR</acronym> is usually preferred over <acronym>CBC</acronym>.
</p>
<p>Modes like <acronym>CBC</acronym>, <acronym>CTR</acronym>, <acronym>CFB</acronym> and <acronym>CFB8</acronym>
provide <em>no</em> message authentication, and should always be used together
with a <acronym>MAC</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>) or signature to
authenticate the message.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#CBC" accesskey="1">CBC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CTR" accesskey="2">CTR</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CFB-and-CFB8" accesskey="3">CFB and CFB8</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#XTS" accesskey="4">XTS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="CBC"></span><div class="header">
<p>
Next: <a href="#CTR" accesskey="n" rel="next">CTR</a>, Up: <a href="#Cipher-modes" accesskey="u" rel="up">Cipher modes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cipher-Block-Chaining"></span><h4 class="subsection">7.3.1 Cipher Block Chaining</h4>

<span id="index-Cipher-Block-Chaining"></span>
<span id="index-CBC-Mode"></span>

<p>When using <acronym>CBC</acronym> mode, plaintext blocks are not encrypted
independently of each other, like in Electronic Cook Book mode. Instead,
when encrypting a block in <acronym>CBC</acronym> mode, the previous ciphertext
block is XORed with the plaintext before it is fed to the block cipher.
When encrypting the first block, a random block called an <em>IV</em>, or
Initialization Vector, is used as the &ldquo;previous ciphertext block&rdquo;. The
IV should be chosen randomly, but it need not be kept secret, and can
even be transmitted in the clear together with the encrypted data.
</p>
<p>In symbols, if <code>E_k</code> is the encryption function of a block cipher,
and <code>IV</code> is the initialization vector, then <code>n</code> plaintext blocks
<code>M_1</code>,&hellip; <code>M_n</code> are transformed into <code>n</code> ciphertext blocks
<code>C_1</code>,&hellip; <code>C_n</code> as follows:
</p>
<div class="example">
<pre class="example">C_1 = E_k(IV  XOR M_1)
C_2 = E_k(C_1 XOR M_2)

&hellip;

C_n = E_k(C_(n-1) XOR M_n)
</pre></div>

<p>Nettle provides two main functions for applying a block cipher in
Cipher Block Chaining (<acronym>CBC</acronym>) mode, one for encryption and one
for decryption. These functions uses <code>const void *</code> to pass cipher
contexts around. The <acronym>CBC</acronym> interface is defined in
<samp>&lt;nettle/cbc.h&gt;</samp>.
</p>
<dl>
<dt id="index-cbc_005fencrypt">Function: <em>void</em> <strong>cbc_encrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-cbc_005fdecrypt">Function: <em>void</em> <strong>cbc_decrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd>
<p>Applies the encryption or decryption function <var>f</var> in <acronym>CBC</acronym>
mode. The final ciphertext block processed is copied into <var>iv</var>
before returning, so that a large message can be processed by a sequence of
calls to <code>cbc_encrypt</code>. The function <var>f</var> is of type
</p>
<p><code>void <var>f</var> (const void *<var>ctx</var>, size_t <var>length</var>, uint8_t <var>dst</var>,
const uint8_t *<var>src</var>)</code>,
</p>
<p>and the <code>cbc_encrypt</code> and <code>cbc_decrypt</code> functions pass their
argument <var>ctx</var> on to <var>f</var>.
</p></dd></dl>

<span id="Utility-macros"></span><h4 class="subsubsection">7.3.1.1 Utility macros</h4>

<p>There are also some macros to help use these functions correctly.
</p>
<dl>
<dt id="index-CBC_005fCTX">Macro: <strong>CBC_CTX</strong> <em>(<var>context_type</var>, <var>block_size</var>)</em></dt>
<dd><p>Expands to
</p><div class="example">
<pre class="example">{
   context_type ctx;
   uint8_t iv[block_size];
}
</pre></div>
</dd></dl>

<p>It can be used to define a <acronym>CBC</acronym> context struct, either directly,
</p>
<div class="example">
<pre class="example">struct CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE) ctx;
</pre></div>

<p>or to give it a struct tag,
</p>
<div class="example">
<pre class="example">struct aes_cbc_ctx CBC_CTX (struct aes_ctx, AES_BLOCK_SIZE);
</pre></div>

<dl>
<dt id="index-CBC_005fSET_005fIV">Macro: <strong>CBC_SET_IV</strong> <em>(<var>ctx</var>, <var>iv</var>)</em></dt>
<dd><p>First argument is a pointer to a context struct as defined by <code>CBC_CTX</code>,
and the second is a pointer to an Initialization Vector (IV) that is
copied into that context.
</p></dd></dl>

<dl>
<dt id="index-CBC_005fENCRYPT">Macro: <strong>CBC_ENCRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dt id="index-CBC_005fDECRYPT">Macro: <strong>CBC_DECRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>cbc_encrypt</code> and <code>cbc_decrypt</code>. The
first argument is a pointer to a context struct as defined by
<code>CBC_CTX</code>, and the second argument is an encryption or decryption
function following Nettle&rsquo;s conventions. The last three arguments define
the source and destination area for the operation.
</p></dd></dl>

<p>These macros use some tricks to make the compiler display a warning if
the types of <var>f</var> and <var>ctx</var> don&rsquo;t match, e.g. if you try to use
an <code>struct aes_ctx</code> context with the <code>des_encrypt</code> function.
</p>
<span id="Cipher_002dspecific-functions"></span><h4 class="subsubsection">7.3.1.2 Cipher-specific functions</h4>

<p>Encryption in <acronym>CBC</acronym> mode (but not decryption!) is inherently
serial. It can pass only one block at a time to the block cipher&rsquo;s
encrypt function. Optimizations to process several blocks in parallel
can&rsquo;t be applied, and on platforms where the underlying cipher is fast,
per-function-call overhead, e.g., loading subkeys from memory into
registers, can be significant. Depending on platform and cipher used,
<code>cbc_encrypt</code> can be considerably slower than both
<code>cbc_decrypt</code> and <acronym>CTR</acronym> mode. The second reason for poor
performance can be addressed by having a combined <acronym>CBC</acronym> and
encrypt function, for ciphers where the overhead is significant.
</p>
<p>Nettle currently includes such special functions only for AES.
</p>
<dl>
<dt id="index-cbc_005faes128_005fencrypt">Function: <em>void</em> <strong>cbc_aes128_encrypt</strong> <em>(const struct aes128_ctx *<var>ctx</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-cbc_005faes192_005fencrypt">Function: <em>void</em> <strong>cbc_aes192_encrypt</strong> <em>(const struct aes192_ctx *<var>ctx</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-cbc_005faes256_005fencrypt">Function: <em>void</em> <strong>cbc_aes256_encrypt</strong> <em>(const struct aes256_ctx *<var>ctx</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Calling <code>cbc_aes128_encrypt(ctx, iv, length, dst, src)</code> does the
same thing as calling <code>cbc_encrypt(ctx, aes128_encrypt,
AES_BLOCK_SIZE, iv, length, dst, src)</code>, but is more efficient on certain
platforms.
</p></dd></dl>

<hr>
<span id="CTR"></span><div class="header">
<p>
Next: <a href="#CFB-and-CFB8" accesskey="n" rel="next">CFB and CFB8</a>, Previous: <a href="#CBC" accesskey="p" rel="prev">CBC</a>, Up: <a href="#Cipher-modes" accesskey="u" rel="up">Cipher modes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Counter-mode"></span><h4 class="subsection">7.3.2 Counter mode</h4>

<span id="index-Counter-Mode"></span>
<span id="index-CTR-Mode"></span>

<p>Counter mode (<acronym>CTR</acronym>) uses the block cipher as a keyed
pseudo-random generator. The output of the generator is XORed with the
data to be encrypted. It can be understood as a way to transform a block
cipher to a stream cipher.
</p>
<p>The message is divided into <code>n</code> blocks <code>M_1</code>,&hellip;
<code>M_n</code>, where <code>M_n</code> is of size <code>m</code> which may be smaller
than the block size. Except for the last block, all the message blocks
must be of size equal to the cipher&rsquo;s block size.
</p>
<p>If <code>E_k</code> is the encryption function of a block cipher, <code>IC</code> is
the initial counter, then the <code>n</code> plaintext blocks are
transformed into <code>n</code> ciphertext blocks <code>C_1</code>,&hellip;
<code>C_n</code> as follows:
</p>
<div class="example">
<pre class="example">C_1 = E_k(IC) XOR M_1
C_2 = E_k(IC + 1) XOR M_2

&hellip;

C_(n-1) = E_k(IC + n - 2) XOR M_(n-1)
C_n = E_k(IC + n - 1) [1..m] XOR M_n
</pre></div>

<p>The <acronym>IC</acronym> is the initial value for the counter, it plays a
similar rÃ´le as the <acronym>IV</acronym> for <acronym>CBC</acronym>. When adding,
<code>IC + x</code>, <acronym>IC</acronym> is interpreted as an integer, in network
byte order. For the last block, <code>E_k(IC + n - 1) [1..m]</code> means that
the cipher output is truncated to <code>m</code> bytes.
</p>
<dl>
<dt id="index-ctr_005fcrypt">Function: <em>void</em> <strong>ctr_crypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>ctr</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd>
<p>Applies the encryption function <var>f</var> in <acronym>CTR</acronym> mode. Note that
for <acronym>CTR</acronym> mode, encryption and decryption is the same operation,
and hence <var>f</var> should always be the encryption function for the
underlying block cipher.
</p>
<p>When a message is encrypted using a sequence of calls to
<code>ctr_crypt</code>, all but the last call <em>must</em> use a length that is
a multiple of the block size.
</p></dd></dl>

<p>Like for <acronym>CBC</acronym>, there are also a couple of helper macros.
</p>
<dl>
<dt id="index-CTR_005fCTX">Macro: <strong>CTR_CTX</strong> <em>(<var>context_type</var>, <var>block_size</var>)</em></dt>
<dd><p>Expands to
</p><div class="example">
<pre class="example">{
   context_type ctx;
   uint8_t ctr[block_size];
}
</pre></div>
</dd></dl>

<dl>
<dt id="index-CTR_005fSET_005fCOUNTER">Macro: <strong>CTR_SET_COUNTER</strong> <em>(<var>ctx</var>, <var>iv</var>)</em></dt>
<dd><p>First argument is a pointer to a context struct as defined by
<code>CTR_CTX</code>, and the second is a pointer to an initial counter that
is copied into that context.
</p></dd></dl>

<dl>
<dt id="index-CTR_005fCRYPT">Macro: <strong>CTR_CRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>ctr_crypt</code>. The first argument is a
pointer to a context struct as defined by <code>CTR_CTX</code>, and the second
argument is an encryption function following Nettle&rsquo;s conventions. The
last three arguments define the source and destination area for the
operation.
</p></dd></dl>

<hr>
<span id="CFB-and-CFB8"></span><div class="header">
<p>
Next: <a href="#XTS" accesskey="n" rel="next">XTS</a>, Previous: <a href="#CTR" accesskey="p" rel="prev">CTR</a>, Up: <a href="#Cipher-modes" accesskey="u" rel="up">Cipher modes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cipher-Feedback-mode"></span><h4 class="subsection">7.3.3 Cipher Feedback mode</h4>

<span id="index-Cipher-Feedback-Mode"></span>
<span id="index-Cipher-Feedback-8_002dbit-Mode"></span>
<span id="index-CFB-Modes"></span>
<span id="index-CFB8-Mode"></span>


<p>Cipher Feedback mode (<acronym>CFB</acronym>) and Cipher Feedback 8-bit mode
(<acronym>CFB8</acronym>) being close relatives to both <acronym>CBC</acronym> mode and
<acronym>CTR</acronym> mode borrow some characteristics from stream ciphers.
</p>
<p>For CFB the message is divided into <code>n</code> blocks <code>M_1</code>,&hellip;
<code>M_n</code>, where <code>M_n</code> is of size <code>m</code> which may be smaller
than the block size. Except for the last block, all the message blocks
must be of size equal to the cipher&rsquo;s block size.
</p>
<p>If <code>E_k</code> is the encryption function of a block cipher, <code>IV</code> is
the initialization vector, then the <code>n</code> plaintext blocks are
transformed into <code>n</code> ciphertext blocks <code>C_1</code>,&hellip;
<code>C_n</code> as follows:
</p>
<div class="example">
<pre class="example">C_1 = E_k(IV) XOR M_1
C_2 = E_k(C_1) XOR M_2

&hellip;

C_(n-1) = E_k(C_(n - 2)) XOR M_(n-1)
C_n = E_k(C_(n - 1)) [1..m] XOR M_n
</pre></div>

<p>Cipher Feedback 8-bit mode (<acronym>CFB8</acronym>) transforms block cipher into a stream
cipher. The message is encrypted byte after byte, not requiring any padding.
</p>
<p>If <code>E_k</code> is the encryption function of a block cipher, <code>b</code> is
<code>E_k</code> block size, <code>IV</code> is the initialization vector, then the
<code>n</code> plaintext bytes are transformed into <code>n</code> ciphertext bytes
<code>C_1</code>,&hellip; <code>C_n</code> as follows:
</p>
<div class="example">
<pre class="example">I_1 = IV
C_1 = E_k(I_1) [1..8] XOR M_1
I_2 = I_1 [9..b] &lt;&lt; 8 | C_1
C_2 = E_k(I_2) [1..8] XOR M_2

&hellip;

I_(n-1) = I_(n-2) [9..b] &lt;&lt; 8 | C_(n-2)
C_(n-1) = E_k(I_(n-1)) [1..8] XOR M_(n-1)
I_n = I_(n-1) [9..b] &lt;&lt; 8 | C_(n-1)
C_n = E_k(I_n) [1..8] XOR M_n
</pre></div>

<p>Nettle&rsquo;s includes functions for applying a block cipher in Cipher
Feedback (<acronym>CFB</acronym>) and Cipher Feedback 8-bit (<acronym>CFB8</acronym>)
modes. These functions uses <code>void *</code> to pass cipher contexts around.
</p>
<dl>
<dt id="index-cfb_005fencrypt">Function: <em>void</em> <strong>cfb_encrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-cfb_005fdecrypt">Function: <em>void</em> <strong>cfb_decrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd>
<p>Applies the encryption or decryption function <var>f</var> in <acronym>CFB</acronym>
mode. The final ciphertext block processed is copied into <var>iv</var>
before returning, so that a large message can be processed by a sequence
of calls to <code>cfb_encrypt</code>. Note that for <acronym>CFB</acronym> mode
internally uses encryption only function and hence <var>f</var> should always
be the encryption function for the underlying block cipher.
</p>
<p>When a message is encrypted using a sequence of calls to
<code>cfb_encrypt</code>, all but the last call <em>must</em> use a length that
is a multiple of the block size.
</p></dd></dl>

<dl>
<dt id="index-cfb8_005fencrypt">Function: <em>void</em> <strong>cfb8_encrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-cfb8_005fdecrypt">Function: <em>void</em> <strong>cfb8_decrypt</strong> <em>(const void *<var>ctx</var>, nettle_cipher_func *<var>f</var>, size_t <var>block_size</var>, uint8_t *<var>iv</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd>
<p>Applies the encryption or decryption function <var>f</var> in <acronym>CFB8</acronym>
mode. The final IV block processed is copied into <var>iv</var>
before returning, so that a large message can be processed by a sequence of
calls to <code>cfb8_encrypt</code>. Note that for <acronym>CFB8</acronym> mode internally
uses encryption only function and hence <var>f</var> should always be the
encryption function for the underlying block cipher.
</p>
</dd></dl>

<p>Like for <acronym>CBC</acronym>, there are also a couple of helper macros.
</p>
<dl>
<dt id="index-CFB_005fCTX">Macro: <strong>CFB_CTX</strong> <em>(<var>context_type</var>, <var>block_size</var>)</em></dt>
<dd><p>Expands to
</p><div class="example">
<pre class="example">{
   context_type ctx;
   uint8_t iv[block_size];
}
</pre></div>
</dd></dl>

<dl>
<dt id="index-CFB_005fSET_005fIV_0028ctx_002c">Macro: <strong>CFB_SET_IV(<var>ctx</var>,</strong> <em><var>iv</var>)</em></dt>
<dd><p>First argument is a pointer to a context struct as defined by
<code>CFB_CTX</code>, and the second is a pointer to an initialization vector
that is copied into that context.
</p></dd></dl>

<dl>
<dt id="index-CFB_005fENCRYPT">Macro: <strong>CFB_ENCRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>cfb_encrypt</code>. The first argument is a
pointer to a context struct as defined by <code>CFB_CTX</code>, and the second
argument is an encryption function following Nettle&rsquo;s conventions. The
last three arguments define the source and destination area for the
operation.
</p></dd></dl>

<dl>
<dt id="index-CFB_005fDECRYPT">Macro: <strong>CFB_DECRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>cfb_decrypt</code>. The first argument is a
pointer to a context struct as defined by <code>CFB_CTX</code>, and the second
argument is an encryption function following Nettle&rsquo;s conventions. The
last three arguments define the source and destination area for the
operation.
</p></dd></dl>

<dl>
<dt id="index-CFB8_005fCTX">Macro: <strong>CFB8_CTX</strong> <em>(<var>context_type</var>, <var>block_size</var>)</em></dt>
<dd><p>Expands to
</p><div class="example">
<pre class="example">{
   context_type ctx;
   uint8_t iv[block_size];
}
</pre></div>
</dd></dl>

<dl>
<dt id="index-CFB8_005fSET_005fIV">Macro: <strong>CFB8_SET_IV</strong> <em>(<var>ctx</var>, <var>iv</var>)</em></dt>
<dd><p>First argument is a pointer to a context struct as defined by
<code>CFB8_CTX</code>, and the second is a pointer to an initialization vector
that is copied into that context.
</p></dd></dl>

<dl>
<dt id="index-CFB8_005fENCRYPT">Macro: <strong>CFB8_ENCRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>cfb8_encrypt</code>. The first argument is a
pointer to a context struct as defined by <code>CFB8_CTX</code>, and the
second argument is an encryption function following Nettle&rsquo;s
conventions. The last three arguments define the source and destination
area for the operation.
</p></dd></dl>

<dl>
<dt id="index-CFB8_005fDECRYPT">Macro: <strong>CFB8_DECRYPT</strong> <em>(<var>ctx</var>, <var>f</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>A simpler way to invoke <code>cfb8_decrypt</code>. The first argument is a
pointer to a context struct as defined by <code>CFB8_CTX</code>, and the
second argument is an encryption function following Nettle&rsquo;s
conventions. The last three arguments define the source and destination
area for the operation.
</p></dd></dl>

<hr>
<span id="XTS"></span><div class="header">
<p>
Previous: <a href="#CFB-and-CFB8" accesskey="p" rel="prev">CFB and CFB8</a>, Up: <a href="#Cipher-modes" accesskey="u" rel="up">Cipher modes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="XEX_002dbased-tweaked_002dcodebook-mode-with-ciphertext-stealing"></span><h4 class="subsection">7.3.4 XEX-based tweaked-codebook mode with ciphertext stealing</h4>

<span id="index-XEX_002dbased-tweaked_002dcodebook-mode-with-ciphertext-stealing"></span>
<span id="index-XTS-Mode"></span>


<p>XEX-based tweaked-codebook mode with ciphertext stealing (<acronym>XTS</acronym>) is
a block mode like (<acronym>CBC</acronym>) but tweaked to be able to encrypt partial
blocks via a technique called ciphertext stealing, where the last complete
block of ciphertext is split and part returned as the last block and part
used as plaintext for the second to last block.
This mode is principally used to encrypt data at rest where it is not possible
to store additional metadata or blocks larger than the plain text. The most
common usage is for disk encryption. Due to the fact that ciphertext expansion
is not possible, data is not authenticated. This mode should not be used where
authentication is critical.
</p>
<p>The message is divided into <code>n</code> blocks <code>M_1</code>,&hellip; <code>M_n</code>,
where <code>M_n</code> is of size <code>m</code> which may be smaller than the block size.
XTS always uses a fixed blocksize of 128 bit (16 bytes) length.
</p>
<p>Unlike other modes, the key is double the size of that for the used cipher mode
(for example 256bit for AES-128 and 512bit for AES-256).
</p>
<p><acronym>XTS</acronym> encryption mode operates given:
</p><ul>
<li> A multiplication by a primitive element alpha.
<code>MUL a^j</code> here represents the multiplication, where <code>j</code> is the power
of alpha, and the input value is converted into a 16 bytes array
<code>a_0[k], k = 0,1,..,15</code>. The multiplication is calculated as
<code>a_(j+1)[0] = (2(a_j[0] mod 128)) XOR (135 * floor(a_j[15]/128)</code>
<code>a_(j+1)[k] = (2(a_j[k] mod 128)) XOR (floor(a_j[k-1]/128), k = 1,2,..15</code>
Note that this operation is practically a 1 bit left shift operation with carry
propagating from one byte to the next, and if the last bit shift results in a
carry the decimal value 135 is XORed into the first byte.

</li><li> The encryption key is provided as the <code>Key = K1 | K2</code>, where <code>|</code>
denotes string concatenation.
<code>E_k1</code> is the encryption function of the block cipher using <code>K1</code> as
the key, and <code>E_k2</code> is the same encryption function using <code>K2</code>

</li><li> A 128 bit tweak value is provided as input and is denoted as <code>IV</code>
</li></ul>

<p>The <code>n</code> plaintext blocks are transformed into <code>n</code> ciphertext blocks
<code>C_1</code>,&hellip; <code>C_n</code> as follows.
</p>
<p>For a plaintext length that is a perfect multiple of the XTS block size:
</p><div class="example">
<pre class="example">T_1 = E_k2(IV)
C_1 = E_k1(P_1 XOR T_1) XOR T_1

&hellip;

T_n = T_(n-1) MUL a
C_n = E_k1(P_n XOR T_n) XOR T_n
</pre></div>

<p>For any other plaintext lengths:
</p><div class="example">
<pre class="example">T_1 = E_k2(IV)
C_1 = E_k1(P_1 XOR T_1) XOR T_1

&hellip;

T_(n-2) = T_(n-3) MUL a
C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)

T_(n-1) = T_(n-2) MUL a
CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)

T_n = T_(n-1) MUL a
PP = [1..m]Pn | [m+1..128]CC_(n-1)
C_(n-1) = E_k1(PP XOR T_n) XOR T_n

C_n = [1..m]CC_(n-1)
</pre></div>

<span id="General-_0028XTS_0029-interface_002e"></span><h4 class="subsubsection">7.3.4.1 General (<acronym>XTS</acronym>) interface.</h4>

<p>The two general functions to encrypt and decrypt using the <acronym>XTS</acronym> block
cipher mode are the following:
</p>
<dl>
<dt id="index-xts_005fencrypt_005fmessage">Function: <em>void</em> <strong>xts_encrypt_message</strong> <em>(const void *<var>enc_ctx</var>, const void *<var>twk_ctx</var>, nettle_cipher_func *<var>encf</var>, const uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-xts_005fdecrypt_005fmessage">Function: <em>void</em> <strong>xts_decrypt_message</strong> <em>(const void *<var>dec_ctx</var>, const void *<var>twk_ctx</var>, nettle_cipher_func *<var>decf</var>, nettle_cipher_func *<var>encf</var>, const uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd>
<p>Applies the encryption function <var>encf</var> or the decryption function
<var>decf</var> in <acronym>XTS</acronym> mode. At least one block (16 bytes) worth
of data must be available therefore specifying a length less than 16
bytes is illegal.
</p>
<p>The functions <var>encf</var> <var>decf</var> are of type
</p>
<p><code>void f (const void *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>,
const uint8_t *<var>src</var>)</code>,
</p>
<p>and the <code>xts_encrypt_message</code> and <code>xts_decrypt_message</code>
functions pass their arguments <var>enc_ctx</var>, <var>twk_ctx</var> and <var>dec_ctx</var>
to the functions <var>encf</var>, <var>decf</var> as <var>ctx</var>.
</p></dd></dl>

<span id="XTS_002dAES-interface"></span><h4 class="subsubsection">7.3.4.2 <acronym>XTS</acronym>-<acronym>AES</acronym> interface</h4>

<p>The <acronym>AES</acronym> <acronym>XTS</acronym> functions provide an API for using the
<acronym>XTS</acronym> mode with the <acronym>AES</acronym> block ciphers. The parameters
all have the same meaning as the general interface, except that the
<var>enc_ctx</var>, <var>dec_ctx</var>, <var>twk_ctx</var>, <var>encf</var> and <var>decf</var> are
replaced with an <acronym>AES</acronym> context structure called <var>ctx</var>, and a
appropriate set-key function must be called before using any of the encryption
or decryption functions in this interface.
</p>
<dl>
<dt id="index-struct-xts_005faes128_005fkey">Context struct: <strong>struct xts_aes128_key</strong></dt>
<dd><p>Holds state corresponding to the AES-128 block cipher.
</p></dd></dl>

<dl>
<dt id="index-struct-xts_005faes256_005fkey">Context struct: <strong>struct xts_aes256_key</strong></dt>
<dd><p>Holds state corresponding to the AES-256 block cipher.
</p></dd></dl>

<dl>
<dt id="index-xts_005faes128_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>xts_aes128_set_encrypt_key</strong> <em>(struct xts_aes128_key *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-xts_005faes256_005fset_005fencrypt_005fkey">Function: <em>void</em> <strong>xts_aes256_set_encrypt_key</strong> <em>(struct xts_aes256_key *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-xts_005faes128_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>xts_aes128_set_decrypt_key</strong> <em>(struct xts_aes128_key *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-xts_005faes256_005fset_005fdecrypt_005fkey">Function: <em>void</em> <strong>xts_aes256_set_decrypt_key</strong> <em>(struct xts_aes256_key *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the encryption or decryption key for the AES block cipher. The
length of the key must be double the size of the key for the corresponding
cipher (256 bits for AES-128 and 512 bits for AES-256). One of
these functions must be called before any of the other functions.
</p></dd></dl>

<dl>
<dt id="index-xts_005faes128_005fencrypt_005fmessage_0028struct">Function: <em>void</em> <strong>xts_aes128_encrypt_message(struct</strong> <em>xts_aes128_key *<var>ctx</var>, uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-xts_005faes256_005fencrypt_005fmessage_0028struct">Function: <em>void</em> <strong>xts_aes256_encrypt_message(struct</strong> <em>xts_aes256_key *<var>ctx</var>, uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-xts_005faes128_005fdecrypt_005fmessage_0028struct">Function: <em>void</em> <strong>xts_aes128_decrypt_message(struct</strong> <em>xts_aes128_key *<var>ctx</var>, uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-xts_005faes256_005fdecrypt_005fmessage_0028struct">Function: <em>void</em> <strong>xts_aes256_decrypt_message(struct</strong> <em>xts_aes256_key *<var>ctx</var>, uint8_t *<var>tweak</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>These are identical to <code>xts_encrypt_message</code> and
<code>xts_decrypt_message</code>, except that <var>enc_ctx</var>, <var>dec_ctx</var>,
<var>twk_ctx</var>, <var>encf</var> and <var>decf</var> are replaced by the <var>ctx</var> context
structure.
</p></dd></dl>

<hr>
<span id="Authenticated-encryption"></span><div class="header">
<p>
Next: <a href="#Keyed-hash-functions" accesskey="n" rel="next">Keyed hash functions</a>, Previous: <a href="#Cipher-modes" accesskey="p" rel="prev">Cipher modes</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Authenticated-encryption-with-associated-data"></span><h3 class="section">7.4 Authenticated encryption with associated data</h3>
<span id="index-AEAD"></span>
<span id="index-Authenticated-encryption"></span>

<p>Since there are some subtle design choices to be made when combining a
block cipher mode with out authentication with a <acronym>MAC</acronym>. In
recent years, several constructions that combine encryption and
authentication have been defined. These constructions typically also
have an additional input, the &ldquo;associated data&rdquo;, which is
authenticated but not included with the message. A simple example is an
implicit message number which is available at both sender and receiver,
and which needs authentication in order to detect deletions or replay of
messages. This family of building blocks are therefore called
<acronym>AEAD</acronym>, Authenticated encryption with associated data.
</p>
<p>The aim is to provide building blocks that it is easier for designers of
protocols and applications to use correctly. There is also some
potential for improved performance, if encryption and authentication can
be done in a single step, although that potential is not realized for
the constructions currently supported by Nettle.
</p>
<p>For encryption, the inputs are:
</p>
<ul>
<li> The key, which can be used for many messages.
</li><li> A nonce, which must be unique for each message using the same key.
</li><li> Additional associated data to be authenticated, but not included in the
message.
</li><li> The cleartext message to be encrypted.
</li></ul>

<p>The outputs are:
</p>
<ul>
<li> The ciphertext, of the same size as the cleartext.
</li><li> A digest or &ldquo;authentication tag&rdquo;.
</li></ul>

<p>Decryption works the same, but with cleartext and ciphertext
interchanged. All currently supported <acronym>AEAD</acronym> algorithms always
use the encryption function of the underlying block cipher, for both
encryption and decryption.
</p>
<p>Usually, the authentication tag should be appended at the end of the
ciphertext, producing an encrypted message which is slightly longer than
the cleartext. However, Nettle&rsquo;s low level <acronym>AEAD</acronym> functions
produce the authentication tag as a separate output for both encryption
and decryption.
</p>
<p>Both associated data and the message data (cleartext or ciphertext) can
be processed incrementally. In general, all associated data must be
processed before the message data, and all calls but the last one must
use a length that is a multiple of the block size, although some
<acronym>AEAD</acronym> may implement more liberal conventions. The <acronym>CCM</acronym>
mode is a bit special in that it requires the message lengths up front,
other <acronym>AEAD</acronym> constructions don&rsquo;t have this restriction.
</p>
<p>The supported <acronym>AEAD</acronym> constructions are Galois/Counter mode
(<acronym>GCM</acronym>), <acronym>EAX</acronym>, ChaCha-Poly1305, and Counter with
<acronym>CBC</acronym>-<acronym>MAC</acronym> (<acronym>CCM</acronym>). There are some weaknesses
in <acronym>GCM</acronym> authentication, see
<a href="https://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf">https://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf</a>.
<acronym>CCM</acronym> and <acronym>EAX</acronym> use the same building blocks, but the
<acronym>EAX</acronym> design is cleaner and avoids a couple of inconveniences of
<acronym>CCM</acronym>. Therefore, <acronym>EAX</acronym> seems like a good conservative
choice. The more recent ChaCha-Poly1305 may also be an attractive but
more adventurous alternative, in particular if performance is important.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#EAX" accesskey="1">EAX</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GCM" accesskey="2">GCM</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CCM" accesskey="3">CCM</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ChaCha_002dPoly1305" accesskey="4">ChaCha-Poly1305</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SIV_002dCMAC" accesskey="5">SIV-CMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#nettle_005faead-abstraction" accesskey="6">nettle_aead abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="EAX"></span><div class="header">
<p>
Next: <a href="#GCM" accesskey="n" rel="next">GCM</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="EAX-1"></span><h4 class="subsection">7.4.1 EAX</h4>

<p>The <acronym>EAX</acronym> mode is an <acronym>AEAD</acronym> mode which combines
<acronym>CTR</acronym> mode encryption, See <a href="#CTR">CTR</a>, with a message authentication
based on <acronym>CBC</acronym>, See <a href="#CBC">CBC</a>. The implementation in Nettle is
restricted to ciphers with a block size of 128 bits (16 octets).
<acronym>EAX</acronym> was defined as a reaction to the <acronym>CCM</acronym> mode,
See <a href="#CCM">CCM</a>, which uses the same primitives but has some undesirable and
inelegant properties.
</p>
<p><acronym>EAX</acronym> supports arbitrary nonce size; it&rsquo;s even possible to use
an empty nonce in case only a single message is encrypted for each key. 
</p>
<p>Nettle&rsquo;s support for <acronym>EAX</acronym> consists of a low-level general
interface, some convenience macros, and specific functions for
<acronym>EAX</acronym> using <acronym>AES</acronym>-128 as the underlying cipher. These
interfaces are defined in <samp>&lt;nettle/eax.h&gt;</samp>
</p>
<span id="General-EAX-interface"></span><h4 class="subsubsection">7.4.1.1 General <acronym>EAX</acronym> interface</h4>

<dl>
<dt id="index-struct-eax_005fkey">Context struct: <strong>struct eax_key</strong></dt>
<dd><p><acronym>EAX</acronym> state which depends only on the key, but not on the nonce
or the message.
</p></dd></dl>

<dl>
<dt id="index-struct-eax_005fctx">Context struct: <strong>struct eax_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fBLOCK_005fSIZE">Constant: <strong>EAX_BLOCK_SIZE</strong></dt>
<dd><p><acronym>EAX</acronym>&rsquo;s block size, 16.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fDIGEST_005fSIZE">Constant: <strong>EAX_DIGEST_SIZE</strong></dt>
<dd><p>Size of the <acronym>EAX</acronym> digest, also 16.
</p></dd></dl>

<dl>
<dt id="index-eax_005fset_005fkey">Function: <em>void</em> <strong>eax_set_key</strong> <em>(struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>)</em></dt>
<dd><p>Initializes <var>key</var>. <var>cipher</var> gives a context struct for the
underlying cipher, which must have been previously initialized for
encryption, and <var>f</var> is the encryption function.
</p></dd></dl>

<dl>
<dt id="index-eax_005fset_005fnonce">Function: <em>void</em> <strong>eax_set_nonce</strong> <em>(struct eax_ctx *<var>eax</var>, const struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>nonce_length</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> for processing a new message, using the given
nonce.
</p></dd></dl>

<dl>
<dt id="index-eax_005fupdate">Function: <em>void</em> <strong>eax_update</strong> <em>(struct eax_ctx *<var>eax</var>, const struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>data_length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process associated data for authentication. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size. Unlike many other <acronym>AEAD</acronym> constructions, for <acronym>EAX</acronym>
it&rsquo;s not necessary to complete the processing of all associated data
before encrypting or decrypting the message data.
</p></dd></dl>

<dl>
<dt id="index-eax_005fencrypt">Function: <em>void</em> <strong>eax_encrypt</strong> <em>(struct eax_ctx *<var>eax</var>, const struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-eax_005fdecrypt">Function: <em>void</em> <strong>eax_decrypt</strong> <em>(struct eax_ctx *<var>eax</var>, const struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. <var>cipher</var> is the context
struct for the underlying cipher and <var>f</var> is the encryption function.
All but the last call for each message <em>must</em> use a length that is
a multiple of the block size.
</p></dd></dl>

<dl>
<dt id="index-eax_005fdigest">Function: <em>void</em> <strong>eax_digest</strong> <em>(struct eax_ctx *<var>eax</var>, const struct eax_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>digest</var>);</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. If <var>length</var> is
smaller than <code>EAX_DIGEST_SIZE</code>, only the first <var>length</var> octets
of the digest are written.
</p></dd></dl>


<span id="EAX-helper-macros"></span><h4 class="subsubsection">7.4.1.2 <acronym>EAX</acronym> helper macros</h4>

<p>The following macros are defined.
</p>
<dl>
<dt id="index-EAX_005fCTX">Macro: <strong>EAX_CTX</strong> <em>(<var>context_type</var>)</em></dt>
<dd><p>This defines an all-in-one context struct, including the context of the
underlying cipher and all <acronym>EAX</acronym> state. It expands
to
</p><div class="example">
<pre class="example">{
   struct eax_key key;
   struct eax_ctx eax;
   context_type cipher;
}
</pre></div>
</dd></dl>

<p>For all these macros, <var>ctx</var>, is a context struct as defined by
<code>EAX_CTX</code>, and <var>encrypt</var> is the encryption function of the
underlying cipher.
</p>
<dl>
<dt id="index-EAX_005fSET_005fKEY">Macro: <strong>EAX_SET_KEY</strong> <em>(<var>ctx</var>, <var>set_key</var>, <var>encrypt</var>, <var>key</var>)</em></dt>
<dd><p><var>set_key</var> is the function for setting the encryption key for the
underlying cipher, and <var>key</var> is the key.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fSET_005fNONCE">Macro: <strong>EAX_SET_NONCE</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>nonce</var>)</em></dt>
<dd><p>Sets the nonce to be used for the message.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fUPDATE">Macro: <strong>EAX_UPDATE</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>data</var>)</em></dt>
<dd><p>Process associated data for authentication.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fENCRYPT">Macro: <strong>EAX_ENCRYPT</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dt id="index-EAX_005fDECRYPT">Macro: <strong>EAX_DECRYPT</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dd><p>Process message data for encryption or decryption.
</p></dd></dl>

<dl>
<dt id="index-EAX_005fDIGEST">Macro: <strong>EAX_DIGEST</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>digest</var>)</em></dt>
<dd><p>Extract the authentication tag for the message.
</p></dd></dl>


<span id="EAX_002dAES128-interface"></span><h4 class="subsubsection">7.4.1.3 <acronym>EAX</acronym>-<acronym>AES</acronym>128 interface</h4>

<p>The following functions implement <acronym>EAX</acronym> using <acronym>AES</acronym>-128
as the underlying cipher.
</p>
<dl>
<dt id="index-struct-eax_005faes128_005fctx">Context struct: <strong>struct eax_aes128_ctx</strong></dt>
<dd><p>The context struct, defined using <code>EAX_CTX</code>.
</p></dd></dl>

<dl>
<dt id="index-eax_005faes128_005fset_005fkey">Function: <em>void</em> <strong>eax_aes128_set_key</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given key.
</p></dd></dl>

<dl>
<dt id="index-eax_005faes128_005fset_005fnonce">Function: <em>void</em> <strong>eax_aes128_set_nonce</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dd><p>Initializes the per-message state, using the given nonce.
</p></dd></dl>

<dl>
<dt id="index-eax_005faes128_005fupdate">Function: <em>void</em> <strong>eax_aes128_update</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process associated data for authentication. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.
</p></dd></dl>

<dl>
<dt id="index-eax_005faes128_005fencrypt">Function: <em>void</em> <strong>eax_aes128_encrypt</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-eax_005faes128_005fdecrypt">Function: <em>void</em> <strong>eax_aes128_decrypt</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.
</p></dd></dl>

<dl>
<dt id="index-eax_005faes128_005fdigest">Function: <em>void</em> <strong>eax_aes128_digest</strong> <em>(struct eax_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>);</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. If <var>length</var> is
smaller than <code>EAX_DIGEST_SIZE</code>, only the first <var>length</var> octets
of the digest are written.
</p></dd></dl>

<hr>
<span id="GCM"></span><div class="header">
<p>
Next: <a href="#CCM" accesskey="n" rel="next">CCM</a>, Previous: <a href="#EAX" accesskey="p" rel="prev">EAX</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Galois-counter-mode"></span><h4 class="subsection">7.4.2 Galois counter mode</h4>

<span id="index-Galois-Counter-Mode"></span>
<span id="index-GCM"></span>

<p>Galois counter mode is an <acronym>AEAD</acronym> constructions combining counter
mode with message authentication based on universal hashing. The main
objective of the design is to provide high performance for hardware
implementations, where other popular <acronym>MAC</acronym> algorithms
(see <a href="#Keyed-hash-functions">Keyed hash functions</a>) become a bottleneck for high-speed
hardware implementations. It was proposed by David A. McGrew and John
Viega in 2005, and recommended by NIST in 2007,
<a href="https://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">NIST Special Publication 800-38D</a>. It is constructed on top of a block
cipher which must have a block size of 128 bits.
</p>
<p>The authentication in <acronym>GCM</acronym> has some known weaknesses, see
<a href="https://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf">https://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf</a>.
In particular, don&rsquo;t use <acronym>GCM</acronym> with short authentication tags.
</p>
<p>Nettle&rsquo;s support for <acronym>GCM</acronym> consists of a low-level general
interface, some convenience macros, and specific functions for
<acronym>GCM</acronym> using <acronym>AES</acronym> or Camellia as the underlying cipher.
These interfaces are defined in <samp>&lt;nettle/gcm.h&gt;</samp>
</p>
<span id="General-GCM-interface"></span><h4 class="subsubsection">7.4.2.1 General <acronym>GCM</acronym> interface</h4>

<dl>
<dt id="index-struct-gcm_005fkey">Context struct: <strong>struct gcm_key</strong></dt>
<dd><p>Message independent hash sub-key, and related tables.
</p></dd></dl>

<dl>
<dt id="index-struct-gcm_005fctx">Context struct: <strong>struct gcm_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message.
</p></dd></dl>

<dl>
<dt id="index-GCM_005fBLOCK_005fSIZE">Constant: <strong>GCM_BLOCK_SIZE</strong></dt>
<dd><p><acronym>GCM</acronym>&rsquo;s block size, 16.
</p></dd></dl>

<dl>
<dt id="index-GCM_005fDIGEST_005fSIZE">Constant: <strong>GCM_DIGEST_SIZE</strong></dt>
<dd><p>Size of the <acronym>GCM</acronym> digest, also 16.
</p></dd></dl>

<dl>
<dt id="index-GCM_005fIV_005fSIZE">Constant: <strong>GCM_IV_SIZE</strong></dt>
<dd><p>Recommended size of the <acronym>IV</acronym>, 12. Arbitrary sizes are allowed.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fset_005fkey">Function: <em>void</em> <strong>gcm_set_key</strong> <em>(struct gcm_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>)</em></dt>
<dd><p>Initializes <var>key</var>. <var>cipher</var> gives a context struct for the
underlying cipher, which must have been previously initialized for
encryption, and <var>f</var> is the encryption function.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fset_005fiv">Function: <em>void</em> <strong>gcm_set_iv</strong> <em>(struct gcm_ctx *<var>ctx</var>, const struct gcm_key *<var>key</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given <acronym>IV</acronym>. The <var>key</var>
argument is actually needed only if <var>length</var> differs from
<code>GCM_IV_SIZE</code>.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fupdate">Function: <em>void</em> <strong>gcm_update</strong> <em>(struct gcm_ctx *<var>ctx</var>, const struct gcm_key *<var>key</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Provides associated data to be authenticated. If used, must be called
before <code>gcm_encrypt</code> or <code>gcm_decrypt</code>. All but the last call
for each message <em>must</em> use a length that is a multiple of the
block size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fencrypt">Function: <em>void</em> <strong>gcm_encrypt</strong> <em>(struct gcm_ctx *<var>ctx</var>, const struct gcm_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005fdecrypt">Function: <em>void</em> <strong>gcm_decrypt</strong> <em>(struct gcm_ctx *<var>ctx</var>, const struct gcm_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. <var>cipher</var> is the context
struct for the underlying cipher and <var>f</var> is the encryption function.
All but the last call for each message <em>must</em> use a length that is
a multiple of the block size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fdigest">Function: <em>void</em> <strong>gcm_digest</strong> <em>(struct gcm_ctx *<var>ctx</var>, const struct gcm_key *<var>key</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. It&rsquo;s strongly recommended
that <var>length</var> is <code>GCM_DIGEST_SIZE</code>, but if you provide a smaller
value, only the first <var>length</var> octets of the digest are written.
</p></dd></dl>

<p>To encrypt a message using <acronym>GCM</acronym>, first initialize a context for
the underlying block cipher with a key to use for encryption. Then call
the above functions in the following order: <code>gcm_set_key</code>,
<code>gcm_set_iv</code>, <code>gcm_update</code>, <code>gcm_encrypt</code>,
<code>gcm_digest</code>. The decryption procedure is analogous, just calling
<code>gcm_decrypt</code> instead of <code>gcm_encrypt</code> (note that
<acronym>GCM</acronym> decryption still uses the encryption function of the
underlying block cipher). To process a new message, using the same key,
call <code>gcm_set_iv</code> with a new <acronym>iv</acronym>.
</p>
<span id="GCM-helper-macros"></span><h4 class="subsubsection">7.4.2.2 <acronym>GCM</acronym> helper macros</h4>

<p>The following macros are defined.
</p>
<dl>
<dt id="index-GCM_005fCTX">Macro: <strong>GCM_CTX</strong> <em>(<var>context_type</var>)</em></dt>
<dd><p>This defines an all-in-one context struct, including the context of the
underlying cipher, the hash sub-key, and the per-message state. It expands
to
</p><div class="example">
<pre class="example">{
   struct gcm_key key; 
   struct gcm_ctx gcm;
   context_type cipher;
}
</pre></div>
</dd></dl>

<p>Example use:
</p><div class="example">
<pre class="example">struct gcm_aes128_ctx GCM_CTX(struct aes128_ctx);
</pre></div>

<p>The following macros operate on context structs of this form.
</p>
<dl>
<dt id="index-GCM_005fSET_005fKEY">Macro: <strong>GCM_SET_KEY</strong> <em>(<var>ctx</var>, <var>set_key</var>, <var>encrypt</var>, <var>key</var>)</em></dt>
<dd><p>First argument, <var>ctx</var>, is a context struct as defined
by <code>GCM_CTX</code>. <var>set_key</var> and <var>encrypt</var> are functions for
setting the encryption key and for encrypting data using the underlying
cipher.
</p></dd></dl>

<dl>
<dt id="index-GCM_005fSET_005fIV">Macro: <strong>GCM_SET_IV</strong> <em>(<var>ctx</var>, <var>length</var>, <var>data</var>)</em></dt>
<dd><p>First argument is a context struct as defined by
<code>GCM_CTX</code>. <var>length</var> and <var>data</var> give the initialization
vector (<acronym>IV</acronym>).
</p></dd></dl>

<dl>
<dt id="index-GCM_005fUPDATE">Macro: <strong>GCM_UPDATE</strong> <em>(<var>ctx</var>, <var>length</var>, <var>data</var>)</em></dt>
<dd><p>Simpler way to call <code>gcm_update</code>. First argument is a context
struct as defined by <code>GCM_CTX</code>
</p></dd></dl>

<dl>
<dt id="index-GCM_005fENCRYPT">Macro: <strong>GCM_ENCRYPT</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dt id="index-GCM_005fDECRYPT">Macro: <strong>GCM_DECRYPT</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>dst</var>, <var>src</var>)</em></dt>
<dt id="index-GCM_005fDIGEST">Macro: <strong>GCM_DIGEST</strong> <em>(<var>ctx</var>, <var>encrypt</var>, <var>length</var>, <var>digest</var>)</em></dt>
<dd><p>Simpler way to call <code>gcm_encrypt</code>, <code>gcm_decrypt</code> or
<code>gcm_digest</code>. First argument is a context struct as defined by
<code>GCM_CTX</code>. Second argument, <var>encrypt</var>, is the encryption
function of the underlying cipher.
</p></dd></dl>

<span id="GCM_002dAES-interface"></span><h4 class="subsubsection">7.4.2.3 <acronym>GCM</acronym>-<acronym>AES</acronym> interface</h4>

<p>The following functions implement the common case of <acronym>GCM</acronym> using
<acronym>AES</acronym> as the underlying cipher. The variants with a specific
<acronym>AES</acronym> flavor are recommended, while the fucntinos using
<code>struct gcm_aes_ctx</code> are kept for compatibility with older versiosn
of Nettle.
</p>
<dl>
<dt id="index-struct-gcm_005faes128_005fctx">Context struct: <strong>struct gcm_aes128_ctx</strong></dt>
<dt id="index-struct-gcm_005faes192_005fctx">Context struct: <strong>struct gcm_aes192_ctx</strong></dt>
<dt id="index-struct-gcm_005faes256_005fctx">Context struct: <strong>struct gcm_aes256_ctx</strong></dt>
<dd><p>Context structs, defined using <code>GCM_CTX</code>.
</p></dd></dl>

<dl>
<dt id="index-struct-gcm_005faes_005fctx">Context struct: <strong>struct gcm_aes_ctx</strong></dt>
<dd><p>Alternative context struct, using the old <acronym>AES</acronym> interface.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes128_005fset_005fkey">Function: <em>void</em> <strong>gcm_aes128_set_key</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-gcm_005faes192_005fset_005fkey">Function: <em>void</em> <strong>gcm_aes192_set_key</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-gcm_005faes256_005fset_005fkey">Function: <em>void</em> <strong>gcm_aes256_set_key</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given key.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes_005fset_005fkey">Function: <em>void</em> <strong>gcm_aes_set_key</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Corresponding function, using the old <acronym>AES</acronym> interface. All valid
<acronym>AES</acronym> key sizes can be used.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes128_005fset_005fiv">Function: <em>void</em> <strong>gcm_aes128_set_iv</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dt id="index-gcm_005faes192_005fset_005fiv">Function: <em>void</em> <strong>gcm_aes192_set_iv</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dt id="index-gcm_005faes256_005fset_005fiv">Function: <em>void</em> <strong>gcm_aes256_set_iv</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dt id="index-gcm_005faes_005fset_005fiv">Function: <em>void</em> <strong>gcm_aes_set_iv</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dd><p>Initializes the per-message state, using the given <acronym>IV</acronym>.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes128_005fupdate">Function: <em>void</em> <strong>gcm_aes128_update</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-gcm_005faes192_005fupdate">Function: <em>void</em> <strong>gcm_aes192_update</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-gcm_005faes256_005fupdate">Function: <em>void</em> <strong>gcm_aes256_update</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-gcm_005faes_005fupdate">Function: <em>void</em> <strong>gcm_aes_update</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Provides associated data to be authenticated. If used, must be called
before <code>gcm_aes_encrypt</code> or <code>gcm_aes_decrypt</code>. All but the
last call for each message <em>must</em> use a length that is a multiple
of the block size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes128_005fencrypt">Function: <em>void</em> <strong>gcm_aes128_encrypt</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes192_005fencrypt">Function: <em>void</em> <strong>gcm_aes192_encrypt</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes256_005fencrypt">Function: <em>void</em> <strong>gcm_aes256_encrypt</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes_005fencrypt">Function: <em>void</em> <strong>gcm_aes_encrypt</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes128_005fdecrypt">Function: <em>void</em> <strong>gcm_aes128_decrypt</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes192_005fdecrypt">Function: <em>void</em> <strong>gcm_aes192_decrypt</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes256_005fdecrypt">Function: <em>void</em> <strong>gcm_aes256_decrypt</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005faes_005fdecrypt">Function: <em>void</em> <strong>gcm_aes_decrypt</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005faes128_005fdigest">Function: <em>void</em> <strong>gcm_aes128_digest</strong> <em>(struct gcm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005faes192_005fdigest">Function: <em>void</em> <strong>gcm_aes192_digest</strong> <em>(struct gcm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005faes256_005fdigest">Function: <em>void</em> <strong>gcm_aes256_digest</strong> <em>(struct gcm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005faes_005fdigest">Function: <em>void</em> <strong>gcm_aes_digest</strong> <em>(struct gcm_aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. It&rsquo;s strongly recommended
that <var>length</var> is <code>GCM_DIGEST_SIZE</code>, but if you provide a smaller
value, only the first <var>length</var> octets of the digest are written.
</p></dd></dl>

<span id="GCM_002dCamellia-interface"></span><h4 class="subsubsection">7.4.2.4 <acronym>GCM</acronym>-Camellia interface</h4>

<p>The following functions implement the case of <acronym>GCM</acronym> using
Camellia as the underlying cipher.
</p>
<dl>
<dt id="index-struct-gcm_005fcamellia128_005fctx">Context struct: <strong>struct gcm_camellia128_ctx</strong></dt>
<dt id="index-struct-gcm_005fcamellia256_005fctx">Context struct: <strong>struct gcm_camellia256_ctx</strong></dt>
<dd><p>Context structs, defined using <code>GCM_CTX</code>.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fcamellia128_005fset_005fkey">Function: <em>void</em> <strong>gcm_camellia128_set_key</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fset_005fkey">Function: <em>void</em> <strong>gcm_camellia256_set_key</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given key.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fcamellia128_005fset_005fiv">Function: <em>void</em> <strong>gcm_camellia128_set_iv</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fset_005fiv">Function: <em>void</em> <strong>gcm_camellia256_set_iv</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>iv</var>)</em></dt>
<dd><p>Initializes the per-message state, using the given <acronym>IV</acronym>.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fcamellia128_005fupdate">Function: <em>void</em> <strong>gcm_camellia128_update</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fupdate">Function: <em>void</em> <strong>gcm_camellia256_update</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Provides associated data to be authenticated. If used, must be called
before <code>gcm_camellia_encrypt</code> or <code>gcm_camellia_decrypt</code>. All but the
last call for each message <em>must</em> use a length that is a multiple
of the block size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fcamellia128_005fencrypt">Function: <em>void</em> <strong>gcm_camellia128_encrypt</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fencrypt">Function: <em>void</em> <strong>gcm_camellia256_encrypt</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005fcamellia128_005fdecrypt">Function: <em>void</em> <strong>gcm_camellia128_decrypt</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fdecrypt">Function: <em>void</em> <strong>gcm_camellia256_decrypt</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.
</p></dd></dl>

<dl>
<dt id="index-gcm_005fcamellia128_005fdigest">Function: <em>void</em> <strong>gcm_camellia128_digest</strong> <em>(struct gcm_camellia128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005fcamellia192_005fdigest">Function: <em>void</em> <strong>gcm_camellia192_digest</strong> <em>(struct gcm_camellia192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005fcamellia256_005fdigest">Function: <em>void</em> <strong>gcm_camellia256_digest</strong> <em>(struct gcm_camellia256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-gcm_005fcamellia_005fdigest">Function: <em>void</em> <strong>gcm_camellia_digest</strong> <em>(struct gcm_camellia_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. It&rsquo;s strongly recommended
that <var>length</var> is <code>GCM_DIGEST_SIZE</code>, but if you provide a smaller
value, only the first <var>length</var> octets of the digest are written.
</p></dd></dl>

<hr>
<span id="CCM"></span><div class="header">
<p>
Next: <a href="#ChaCha_002dPoly1305" accesskey="n" rel="next">ChaCha-Poly1305</a>, Previous: <a href="#GCM" accesskey="p" rel="prev">GCM</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Counter-with-CBC_002dMAC-mode"></span><h4 class="subsection">7.4.3 Counter with CBC-MAC mode</h4>

<span id="index-Counter-with-CBC_002dMAC-Mode"></span>
<span id="index-CCM-Mode"></span>

<p><acronym>CCM</acronym> mode is a combination of counter mode with message
authentication based on cipher block chaining, the same building blocks
as <acronym>EAX</acronym>, see <a href="#EAX">EAX</a>. It is constructed on top of a block cipher
which must have a block size of 128 bits. <acronym>CCM</acronym> mode is
recommended by NIST in
<a href="https://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf">NIST Special Publication 800-38C</a>. Nettle&rsquo;s support for CCM consists of
a low-level general interface, a message encryption and authentication
interface, and specific functions for CCM using AES as the underlying
block cipher. These interfaces are defined in <samp>&lt;nettle/ccm.h&gt;</samp>.
</p>
<p>In <acronym>CCM</acronym>, the length of the message must be known before
processing. The maximum message size depends on the size of the nonce,
since the message size is encoded in a field which must fit in a single
block, together with the nonce and a flag byte. E.g., with a nonce size
of 12 octets, there are three octets left for encoding the message
length, the maximum message length is <em>2^24 - 1</em> octets.
</p>
<p><acronym>CCM</acronym> mode encryption operates as follows:
</p><ul>
<li> The nonce and message length are concatenated to create
<code>B_0 = flags | nonce | mlength</code>

</li><li> The authenticated data and plaintext is formatted into the string
<code>B = L(adata) | adata | padding | plaintext | padding</code> with
<code>padding</code> being the shortest string of zero bytes such that the
length of the string is a multiple of the block size, and
<code>L(adata)</code> is an encoding of the length of <code>adata</code>.

</li><li> The string <code>B</code> is separated into blocks <code>B_1</code> ...
<code>B_n</code>
</li><li> The authentication tag <code>T</code> is calculated as
<code>T=0, for i=0 to n, do T = E_k(B_i XOR T)</code>

</li><li> An initial counter is then initialized from the nonce to create
<code>IC = flags | nonce | padding</code>, where <code>padding</code> is the
shortest string of zero bytes such that <code>IC</code> is exactly one block
in length.

</li><li> The authentication tag is encrypted using using <acronym>CTR</acronym> mode:
<code>MAC = E_k(IC) XOR T</code>

</li><li> The plaintext is then encrypted using <acronym>CTR</acronym> mode with an
initial counter of <code>IC+1</code>.
</li></ul>

<p><acronym>CCM</acronym> mode decryption operates similarly, except that the
ciphertext and <acronym>MAC</acronym> are first decrypted using CTR mode to
retrieve the plaintext and authentication tag. The authentication tag
can then be recalculated from the authenticated data and plaintext, and
compared to the value in the message to check for authenticity.
</p>
<span id="General-CCM-interface"></span><h4 class="subsubsection">7.4.3.1 General <acronym>CCM</acronym> interface</h4>

<p>For all of the functions in the <acronym>CCM</acronym> interface, <var>cipher</var> is
the context struct for the underlying cipher and <var>f</var> is the
encryption function. The cipher&rsquo;s encryption key must be set before
calling any of the <acronym>CCM</acronym> functions. The cipher&rsquo;s decryption
function and key are never used.
</p>
<dl>
<dt id="index-struct-ccm_005fctx">Context struct: <strong>struct ccm_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message.
</p></dd></dl>

<dl>
<dt id="index-CCM_005fBLOCK_005fSIZE">Constant: <strong>CCM_BLOCK_SIZE</strong></dt>
<dd><p><acronym>CCM</acronym>&rsquo;s block size, 16.
</p></dd></dl>

<dl>
<dt id="index-CCM_005fDIGEST_005fSIZE">Constant: <strong>CCM_DIGEST_SIZE</strong></dt>
<dd><p>Size of the <acronym>CCM</acronym> digest, 16.
</p></dd></dl>

<dl>
<dt id="index-CCM_005fMIN_005fNONCE_005fSIZE">Constant: <strong>CCM_MIN_NONCE_SIZE</strong></dt>
<dt id="index-CCM_005fMAX_005fNONCE_005fSIZE">Constant: <strong>CCM_MAX_NONCE_SIZE</strong></dt>
<dd><p>The the minimum and maximum sizes for an <acronym>CCM</acronym> nonce, 7 and 14,
respectively.
</p></dd></dl>

<dl>
<dt id="index-CCM_005fMAX_005fMSG_005fSIZE">Macro: <strong>CCM_MAX_MSG_SIZE</strong> <em>(<var>nonce_size</var>)</em></dt>
<dd><p>The largest allowed plaintext length, when using <acronym>CCM</acronym> with a
nonce of the given size.
</p></dd></dl>

<dl>
<dt id="index-ccm_005fset_005fnonce">Function: <em>void</em> <strong>ccm_set_nonce</strong> <em>(struct ccm_ctx *<var>ctx</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>noncelen</var>, const uint8_t *<var>nonce</var>, size_t <var>authlen</var>, size_t <var>msglen</var>, size_t <var>taglen</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given nonce and the sizes of the
authenticated data, message, and <acronym>MAC</acronym> to be processed.
</p></dd></dl>

<dl>
<dt id="index-ccm_005fupdate">Function: <em>void</em> <strong>ccm_update</strong> <em>(struct ccm_ctx *<var>ctx</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Provides associated data to be authenticated. Must be called after
<code>ccm_set_nonce</code>, and before <code>ccm_encrypt</code>, <code>ccm_decrypt</code>, or
<code>ccm_digest</code>.
</p></dd></dl>

<dl>
<dt id="index-ccm_005fencrypt">Function: <em>void</em> <strong>ccm_encrypt</strong> <em>(struct ccm_ctx *<var>ctx</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005fdecrypt">Function: <em>void</em> <strong>ccm_decrypt</strong> <em>(struct ccm_ctx *<var>ctx</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the message data. Must be called after
<code>ccm_set_nonce</code> and before <code>ccm_digest</code>. All but the last call
for each message <em>must</em> use a length that is a multiple of the
block size.
</p></dd></dl>

<dl>
<dt id="index-ccm_005fdigest">Function: <em>void</em> <strong>ccm_digest</strong> <em>(struct ccm_ctx *<var>ctx</var>, const void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. <var>length</var> is usually
equal to the <var>taglen</var> parameter supplied to <code>ccm_set_nonce</code>,
but if you provide a smaller value, only the first <var>length</var> octets
of the digest are written.
</p></dd></dl>

<p>To encrypt a message using the general <acronym>CCM</acronym> interface, set the
message nonce and length using <code>ccm_set_nonce</code> and then call
<code>ccm_update</code> to generate the digest of any authenticated data.
After all of the authenticated data has been digested use
<code>ccm_encrypt</code> to encrypt the plaintext. Finally, use
<code>ccm_digest</code> to return the encrypted <acronym>MAC</acronym>.
</p>
<p>To decrypt a message, use <code>ccm_set_nonce</code> and <code>ccm_update</code> the
same as you would for encryption, and then call <code>ccm_decrypt</code> to
decrypt the ciphertext. After decrypting the ciphertext
<code>ccm_digest</code> will return the encrypted <acronym>MAC</acronym> which should
be identical to the <acronym>MAC</acronym> in the received message.
</p>
<span id="CCM-message-interface"></span><h4 class="subsubsection">7.4.3.2 <acronym>CCM</acronym> message interface</h4>

<p>The <acronym>CCM</acronym> message fuctions provides a simple interface that will
perform authentication and message encryption in a single function call.
The length of the cleartext is given by <var>mlength</var> and the length of
the ciphertext is given by <var>clength</var>, always exactly <var>tlength</var>
bytes longer than the corresponding plaintext. The length argument
passed to a function is always the size for the result, <var>clength</var>
for the encryption functions, and <var>mlength</var> for the decryption
functions.
</p>
<dl>
<dt id="index-ccm_005fencrypt_005fmessage">Function: <em>void</em> <strong>ccm_encrypt_message</strong> <em>(void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Computes the message digest from the <var>adata</var> and <var>src</var>
parameters, encrypts the plaintext from <var>src</var>, appends the encrypted
<acronym>MAC</acronym> to ciphertext and outputs it to <var>dst</var>.
</p></dd></dl>

<dl>
<dt id="index-ccm_005fdecrypt_005fmessage">Function: <em>int</em> <strong>ccm_decrypt_message</strong> <em>(void *<var>cipher</var>, nettle_cipher_func *<var>f</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Decrypts the ciphertext from <var>src</var>, outputs the plaintext to
<var>dst</var>, recalculates the <acronym>MAC</acronym> from <var>adata</var> and the
plaintext, and compares it to the final <var>tlength</var> bytes of
<var>src</var>. If the values of the received and calculated <acronym>MAC</acronym>s
are equal, this will return 1 indicating a valid and authenticated
message. Otherwise, this function will return zero.
</p></dd></dl>

<span id="CCM_002dAES-interface"></span><h4 class="subsubsection">7.4.3.3 <acronym>CCM</acronym>-<acronym>AES</acronym> interface</h4>

<p>The <acronym>AES</acronym> <acronym>CCM</acronym> functions provide an API for using
<acronym>CCM</acronym> mode with the <acronym>AES</acronym> block ciphers. The parameters
all have the same meaning as the general and message interfaces, except
that the <var>cipher</var>, <var>f</var>, and <var>ctx</var> parameters are replaced
with an <acronym>AES</acronym> context structure, and a set-key function must be
called before using any of the other functions in this interface.
</p>
<dl>
<dt id="index-struct-ccm_005faes128_005fctx">Context struct: <strong>struct ccm_aes128_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message encrypted using the
AES-128 block cipher.
</p></dd></dl>

<dl>
<dt id="index-struct-ccm_005faes192_005fctx">Context struct: <strong>struct ccm_aes192_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message encrypted using the
AES-192 block cipher.
</p></dd></dl>

<dl>
<dt id="index-struct-ccm_005faes256_005fctx">Context struct: <strong>struct ccm_aes256_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message encrypted using the
AES-256 block cipher.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fset_005fkey">Function: <em>void</em> <strong>ccm_aes128_set_key</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-ccm_005faes192_005fset_005fkey">Function: <em>void</em> <strong>ccm_aes192_set_key</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-ccm_005faes256_005fset_005fkey">Function: <em>void</em> <strong>ccm_aes256_set_key</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the encryption key for the AES block cipher. One of these
functions must be called before any of the other functions in the
<acronym>AES</acronym> <acronym>CCM</acronym> interface.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fset_005fnonce">Function: <em>void</em> <strong>ccm_aes128_set_nonce</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>noncelen</var>, const uint8_t *<var>nonce</var>, size_t <var>authlen</var>, size_t <var>msglen</var>, size_t <var>taglen</var>)</em></dt>
<dt id="index-ccm_005faes192_005fset_005fnonce">Function: <em>void</em> <strong>ccm_aes192_set_nonce</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>noncelen</var>, const uint8_t *<var>nonce</var>, size_t <var>authlen</var>, size_t <var>msglen</var>, size_t <var>taglen</var>)</em></dt>
<dt id="index-ccm_005faes256_005fset_005fnonce">Function: <em>void</em> <strong>ccm_aes256_set_nonce</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>noncelen</var>, const uint8_t *<var>nonce</var>, size_t <var>authlen</var>, size_t <var>msglen</var>, size_t <var>taglen</var>)</em></dt>
<dd><p>These are identical to <code>ccm_set_nonce</code>, except that <var>cipher</var>,
<var>f</var>, and <var>ctx</var> are replaced with a context structure.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fupdate">Function: <em>void</em> <strong>ccm_aes128_update</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-ccm_005faes192_005fupdate">Function: <em>void</em> <strong>ccm_aes192_update</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-ccm_005faes256_005fupdate">Function: <em>void</em> <strong>ccm_aes256_update</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>These are identical to <code>ccm_set_update</code>, except that <var>cipher</var>,
<var>f</var>, and <var>ctx</var> are replaced with a context structure.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fencrypt">Function: <em>void</em> <strong>ccm_aes128_encrypt</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes192_005fencrypt">Function: <em>void</em> <strong>ccm_aes192_encrypt</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes256_005fencrypt">Function: <em>void</em> <strong>ccm_aes256_encrypt</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes128_005fdecrypt">Function: <em>void</em> <strong>ccm_aes128_decrypt</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes192_005fdecrypt">Function: <em>void</em> <strong>ccm_aes192_decrypt</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes256_005fdecrypt">Function: <em>void</em> <strong>ccm_aes256_decrypt</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>These are identical to <code>ccm_set_encrypt</code> and <code>ccm_set_decrypt</code>, except
that <var>cipher</var>, <var>f</var>, and <var>ctx</var> are replaced with a context structure.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fdigest">Function: <em>void</em> <strong>ccm_aes128_digest</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-ccm_005faes192_005fdigest">Function: <em>void</em> <strong>ccm_aes192_digest</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-ccm_005faes256_005fdigest">Function: <em>void</em> <strong>ccm_aes256_digest</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>These are identical to <code>ccm_set_digest</code>, except that <var>cipher</var>,
<var>f</var>, and <var>ctx</var> are replaced with a context structure.
</p></dd></dl>

<dl>
<dt id="index-ccm_005faes128_005fencrypt_005fmessage">Function: <em>void</em> <strong>ccm_aes128_encrypt_message</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes192_005fencrypt_005fmessage">Function: <em>void</em> <strong>ccm_aes192_encrypt_message</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes256_005fencrypt_005fmessage">Function: <em>void</em> <strong>ccm_aes256_encrypt_message</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes128_005fdecrypt_005fmessage">Function: <em>int</em> <strong>ccm_aes128_decrypt_message</strong> <em>(struct ccm_aes128_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes192_005fdecrypt_005fmessage">Function: <em>int</em> <strong>ccm_aes192_decrypt_message</strong> <em>(struct ccm_aes192_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-ccm_005faes192_005fdecrypt_005fmessage-1">Function: <em>int</em> <strong>ccm_aes192_decrypt_message</strong> <em>(struct ccm_aes256_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>tlength</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>These are identical to <code>ccm_encrypt_message</code> and <code>ccm_decrypt_message</code>
except that <var>cipher</var> and <var>f</var> are replaced with a context structure.
</p></dd></dl>

<hr>
<span id="ChaCha_002dPoly1305"></span><div class="header">
<p>
Next: <a href="#SIV_002dCMAC" accesskey="n" rel="next">SIV-CMAC</a>, Previous: <a href="#CCM" accesskey="p" rel="prev">CCM</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="ChaCha_002dPoly1305-1"></span><h4 class="subsection">7.4.4 ChaCha-Poly1305</h4>

<p>ChaCha-Poly1305 is a combination of the ChaCha stream cipher and the
poly1305 message authentication code (see <a href="#Poly1305">Poly1305</a>). It originates
from the NaCl cryptographic library by D. J. Bernstein et al, which
defines a similar construction but with Salsa20 instead of ChaCha.
</p>
<p>Nettle&rsquo;s implementation of ChaCha-Poly1305 follows <cite>RFC 8439</cite>,
where the ChaCha cipher is initialized with a 12-byte nonce and a 4-byte
block counter. This allows up to 256 gigabytes of data to be encrypted
using the same key and nonce.
</p>
<p>For ChaCha-Poly1305, the ChaCha cipher is initialized with a key, of 256
bits, and a per-message nonce. The first block of the key stream
(counter all zero) is set aside for the authentication subkeys. Of this
64-octet block, the first 16 octets specify the poly1305 evaluation
point, and the next 16 bytes specify the value to add in for the final
digest. The final 32 bytes of this block are unused. Note that unlike
poly1305-aes, the evaluation point depends on the nonce. This is
preferable, because it leaks less information in case the attacker for
some reason is lucky enough to forge a valid authentication tag, and
observe (from the receiver&rsquo;s behaviour) that the forgery succeeded.
</p>
<p>The ChaCha key stream, starting with counter value 1, is then used to
encrypt the message. For authentication, poly1305 is applied to the
concatenation of the associated data, the cryptotext, and the lengths of
the associated data and the message, each a 64-bit number (eight octets,
little-endian). Nettle defines ChaCha-Poly1305 in
<samp>&lt;nettle/chacha-poly1305.h&gt;</samp>.
</p>
<dl>
<dt id="index-CHACHA_005fPOLY1305_005fBLOCK_005fSIZE">Constant: <strong>CHACHA_POLY1305_BLOCK_SIZE</strong></dt>
<dd><p>Same as the ChaCha block size, 64.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fPOLY1305_005fKEY_005fSIZE">Constant: <strong>CHACHA_POLY1305_KEY_SIZE</strong></dt>
<dd><p>ChaCha-Poly1305 key size, 32.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fPOLY1305_005fNONCE_005fSIZE">Constant: <strong>CHACHA_POLY1305_NONCE_SIZE</strong></dt>
<dd><p>ChaCha-Poly1305 nonce size, 12.
</p></dd></dl>

<dl>
<dt id="index-CHACHA_005fPOLY1305_005fDIGEST_005fSIZE">Constant: <strong>CHACHA_POLY1305_DIGEST_SIZE</strong></dt>
<dd><p>Digest size, 16.
</p></dd></dl>

<dl>
<dt id="index-struct-chacha_005fpoly1305_005fctx">Context struct: <strong>struct chacha_poly1305_ctx</strong></dt>
</dl>

<dl>
<dt id="index-chacha_005fpoly1305_005fset_005fkey">Function: <em>void</em> <strong>chacha_poly1305_set_key</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes <var>ctx</var> using the given key. Before using the context, you
<em>must</em> also call <code>chacha_poly1305_set_nonce</code>, see below.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fpoly1305_005fset_005fnonce">Function: <em>void</em> <strong>chacha_poly1305_set_nonce</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Initializes the per-message state, using the given nonce.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fpoly1305_005fupdate">Function: <em>void</em> <strong>chacha_poly1305_update</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process associated data for authentication.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fpoly1305_005fencrypt">Function: <em>void</em> <strong>chacha_poly1305_encrypt</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-chacha_005fpoly1305_005fdecrypt">Function: <em>void</em> <strong>chacha_poly1305_decrypt</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Encrypts or decrypts the data of a message. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.
</p></dd></dl>

<dl>
<dt id="index-chacha_005fpoly1305_005fdigest">Function: <em>void</em> <strong>chacha_poly1305_digest</strong> <em>(struct chacha_poly1305_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. If <var>length</var> is
smaller than <code>CHACHA_POLY1305_DIGEST_SIZE</code>, only the first
<var>length</var> octets of the digest are written.
</p></dd></dl>

<hr>
<span id="SIV_002dCMAC"></span><div class="header">
<p>
Next: <a href="#nettle_005faead-abstraction" accesskey="n" rel="next">nettle_aead abstraction</a>, Previous: <a href="#ChaCha_002dPoly1305" accesskey="p" rel="prev">ChaCha-Poly1305</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Synthetic-Initialization-Vector-AEAD"></span><h4 class="subsection">7.4.5 Synthetic Initialization Vector AEAD</h4>

<span id="index-SIV-mode"></span>
<span id="index-SIV_002dCMAC-mode"></span>

<p><acronym>SIV-CMAC</acronym> mode is a combination of counter mode with message
authentication based on <acronym>CMAC</acronym>. Unlike other counter <acronym>AEAD</acronym>
modes, it provides protection against accidental nonce misuse, making it
a good choice for stateless-servers that cannot ensure nonce uniqueness.
It is constructed on top of a block cipher which must have a block size of
128 bits. Nettle&rsquo;s support for <acronym>SIV-CMAC</acronym> consists of
a message encryption and authentication interface, for
<acronym>SIV-CMAC</acronym> using AES as the underlying block cipher.
When a nonce is re-used with this mode, message authenticity is retained
however an attacker can determine whether the same plaintext was protected
with the two messages sharing the nonce.
These interfaces are defined in <samp>&lt;nettle/siv-cmac.h&gt;</samp>.
</p>
<p>Unlike other <acronym>AEAD</acronym> mode in <acronym>SIV-CMAC</acronym> the initialization
vector serves as the tag. That means that in the generated ciphertext
the tag precedes the ciphertext.
</p>
<p>Note also, that the <acronym>SIV-CMAC</acronym> algorithm, as specified in
<cite>RFC 5297</cite>, introduces the notion of authenticated data which
consist of multiple components. For example with <acronym>SIV-CMAC</acronym> the
authentication tag of data <code>X</code> followed by <code>Y</code>, is different
than the concatenated data <code>X || Y</code>. The interfaces described below
follow the <acronym>AEAD</acronym> paradigm and do not allow access to this
feature and also require the use of a non-empty nonce. In the
terminology of the RFC, the input to the S2V function is always a vector
of three elements, where S1 is the authenticated data, S2 is the nonce,
and S3 is the plaintext.
</p>

<span id="General-interface"></span><h4 class="subsubsection">7.4.5.1 General interface</h4>

<dl>
<dt id="index-SIV_005fBLOCK_005fSIZE">Constant: <strong>SIV_BLOCK_SIZE</strong></dt>
<dd><p><acronym>SIV-CMAC</acronym>&rsquo;s block size, 16.
</p></dd></dl>

<dl>
<dt id="index-SIV_005fDIGEST_005fSIZE">Constant: <strong>SIV_DIGEST_SIZE</strong></dt>
<dd><p>Size of the <acronym>SIV-CMAC</acronym> digest or initialization vector, 16.
</p></dd></dl>

<dl>
<dt id="index-SIV_005fMIN_005fNONCE_005fSIZE">Constant: <strong>SIV_MIN_NONCE_SIZE</strong></dt>
<dd><p>The the minimum size for an <acronym>SIV-CMAC</acronym> nonce, 1.
</p></dd></dl>

<span id="SIV_002dCMAC_002dAES-interface"></span><h4 class="subsubsection">7.4.5.2 <acronym>SIV-CMAC</acronym>-<acronym>AES</acronym> interface</h4>

<p>The <acronym>AES</acronym> <acronym>SIV-CMAC</acronym> functions provide an API for using
<acronym>SIV-CMAC</acronym> mode with the <acronym>AES</acronym> block ciphers. The parameters
all have the same meaning as the general and message interfaces, except
that the <var>cipher</var>, <var>f</var>, and <var>ctx</var> parameters are replaced
with an <acronym>AES</acronym> context structure, and a set-key function must be
called before using any of the other functions in this interface.
</p>
<dl>
<dt id="index-struct-siv_005fcmac_005faes128_005fctx">Context struct: <strong>struct siv_cmac_aes128_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message encrypted using the
AES-128 block cipher.
</p></dd></dl>

<dl>
<dt id="index-struct-siv_005fcmac_005faes256_005fctx">Context struct: <strong>struct siv_cmac_aes256_ctx</strong></dt>
<dd><p>Holds state corresponding to a particular message encrypted using the
AES-256 block cipher.
</p></dd></dl>

<dl>
<dt id="index-siv_005fcmac_005faes128_005fset_005fkey">Function: <em>void</em> <strong>siv_cmac_aes128_set_key</strong> <em>(struct siv_cmac_aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-siv_005fcmac_005faes256_005fset_005fkey">Function: <em>void</em> <strong>siv_cmac_aes256_set_key</strong> <em>(struct siv_cmac_aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the encryption key for the AES block cipher. One of these
functions must be called before any of the other functions in the
<acronym>AES</acronym> <acronym>SIV-CMAC</acronym> interface.
</p></dd></dl>

<dl>
<dt id="index-siv_005fcmac_005faes128_005fencrypt_005fmessage">Function: <em>void</em> <strong>siv_cmac_aes128_encrypt_message</strong> <em>(struct siv_cmac_aes128_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-siv_005fcmac_005faes256_005fencrypt_005fmessage">Function: <em>void</em> <strong>siv_cmac_aes256_encrypt_message</strong> <em>(struct siv_cmac_aes256_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>clength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Computes the message digest from the <var>adata</var> and <var>src</var>
parameters, encrypts the plaintext from <var>src</var>, prepends the
initialization vector to the ciphertext and outputs it to <var>dst</var>.
The <var>clength</var> variable must be equal to the length of <var>src</var>
plus <code>SIV_DIGEST_SIZE</code>.
</p>
</dd></dl>

<dl>
<dt id="index-siv_005fcmac_005faes128_005fdecrypt_005fmessage">Function: <em>int</em> <strong>siv_cmac_aes128_decrypt_message</strong> <em>(struct siv_cmac_aes128_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dt id="index-siv_005fcmac_005faes256_005fdecrypt_005fmessage">Function: <em>int</em> <strong>siv_cmac_aes256_decrypt_message</strong> <em>(struct siv_cmac_aes128_ctx *<var>ctx</var>, size_t <var>nlength</var>, const uint8_t *<var>nonce</var>, size_t <var>alength</var>, const uint8_t *<var>adata</var>, size_t <var>mlength</var>, uint8_t *<var>dst</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Decrypts the ciphertext from <var>src</var>, outputs the plaintext to
<var>dst</var>, recalculates the initialization vector from <var>adata</var> and the
plaintext. If the values of the received and calculated initialization vector
are equal, this will return 1 indicating a valid and authenticated
message. Otherwise, this function will return zero.
</p></dd></dl>

<hr>
<span id="nettle_005faead-abstraction"></span><div class="header">
<p>
Previous: <a href="#SIV_002dCMAC" accesskey="p" rel="prev">SIV-CMAC</a>, Up: <a href="#Authenticated-encryption" accesskey="u" rel="up">Authenticated encryption</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-struct-nettle_005faead-abstraction"></span><h4 class="subsection">7.4.6 The <code>struct nettle_aead</code> abstraction</h4>
<span id="index-nettle_005faead"></span>

<p>Nettle includes a struct including information about the supported hash
functions. It is defined in <samp>&lt;nettle/nettle-meta.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-nettle_005faead">Meta struct: <strong><code>struct nettle_aead</code></strong> <em>name context_size block_size key_size nonce_size digest_size set_encrypt_key set_decrypt_key set_nonce update encrypt decrypt digest</em></dt>
<dd><p>The last seven attributes are function pointers.
</p></dd></dl>

<dl>
<dt id="index-nettle_005fgcm_005faes128">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_gcm_aes128</strong></dt>
<dt id="index-nettle_005fgcm_005faes192">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_gcm_aes192</strong></dt>
<dt id="index-nettle_005fgcm_005faes256">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_gcm_aes256</strong></dt>
<dt id="index-nettle_005fgcm_005fcamellia128">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_gcm_camellia128</strong></dt>
<dt id="index-nettle_005fgcm_005fcamellia256">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_gcm_camellia256</strong></dt>
<dt id="index-nettle_005feax_005faes128">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_eax_aes128</strong></dt>
<dt id="index-nettle_005fchacha_005fpoly1305">Constant Struct: <em>struct nettle_aead</em> <strong>nettle_chacha_poly1305</strong></dt>
<dd><p>These are most of the <acronym>AEAD</acronym> constructions that Nettle
implements. Note that <acronym>CCM</acronym> is missing; it requirement that the
message size is specified in advance makes it incompatible with the
<code>nettle_aead</code> abstraction.
</p></dd></dl>

<p>Nettle also exports a list of all these constructions.
</p>
<dl>
<dt id="index-nettle_005fget_005faeads">Function: <em>const struct nettle_aead **</em> <strong>nettle_get_aeads</strong> <em>(void)</em></dt>
<dd><p>Returns a NULL-terminated list of pointers to supported algorithms.This
list can be used to dynamically enumerate or search the supported
algorithms.
</p></dd></dl>

<dl>
<dt id="index-nettle_005faeads">Macro: <strong>nettle_aeads</strong></dt>
<dd><p>A macro expanding to a call to nettle_get_aeads. In earlier versions,
this was not a macro but the actual array of pointers.
</p></dd></dl>

<hr>
<span id="Keyed-hash-functions"></span><div class="header">
<p>
Next: <a href="#Key-derivation-functions" accesskey="n" rel="next">Key derivation functions</a>, Previous: <a href="#Authenticated-encryption" accesskey="p" rel="prev">Authenticated encryption</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Keyed-Hash-Functions"></span><h3 class="section">7.5 Keyed Hash Functions</h3>

<span id="index-Keyed-Hash-Function"></span>
<span id="index-Message-Authentication-Code"></span>
<span id="index-MAC"></span>

<p>A <em>keyed hash function</em>, or <em>Message Authentication Code</em>
(<acronym>MAC</acronym>) is a function that takes a key and a message, and
produces fixed size <acronym>MAC</acronym>. It should be hard to compute a
message and a matching <acronym>MAC</acronym> without knowledge of the key. It
should also be hard to compute the key given only messages and
corresponding <acronym>MAC</acronym>s.
</p>
<p>Keyed hash functions are useful primarily for message authentication,
when Alice and Bob shares a secret: The sender, Alice, computes the
<acronym>MAC</acronym> and attaches it to the message. The receiver, Bob, also computes
the <acronym>MAC</acronym> of the message, using the same key, and compares that
to Alice&rsquo;s value. If they match, Bob can be assured that
the message has not been modified on its way from Alice.
</p>
<p>However, unlike digital signatures, this assurance is not transferable.
Bob can&rsquo;t show the message and the <acronym>MAC</acronym> to a third party and
prove that Alice sent that message. Not even if he gives away the key to
the third party. The reason is that the <em>same</em> key is used on both
sides, and anyone knowing the key can create a correct <acronym>MAC</acronym> for
any message. If Bob believes that only he and Alice knows the key, and
he knows that he didn&rsquo;t attach a <acronym>MAC</acronym> to a particular message,
he knows it must be Alice who did it. However, the third party can&rsquo;t
distinguish between a <acronym>MAC</acronym> created by Alice and one created by
Bob.
</p>
<p>Keyed hash functions are typically a lot faster than digital signatures
as well.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#HMAC" accesskey="1">HMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UMAC" accesskey="2">UMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CMAC" accesskey="3">CMAC</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Poly1305" accesskey="4">Poly1305</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="HMAC"></span><div class="header">
<p>
Next: <a href="#UMAC" accesskey="n" rel="next">UMAC</a>, Up: <a href="#Keyed-hash-functions" accesskey="u" rel="up">Keyed hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="HMAC-1"></span><h4 class="subsection">7.5.1 <acronym>HMAC</acronym></h4>
<span id="index-HMAC"></span>

<p>One can build keyed hash functions from ordinary hash functions. Older
constructions simply concatenate secret key and message and hashes that, but
such constructions have weaknesses. A better construction is
<acronym>HMAC</acronym>, described in <cite>RFC 2104</cite>.
</p>
<p>For an underlying hash function <code>H</code>, with digest size <code>l</code> and
internal block size <code>b</code>, <acronym>HMAC-H</acronym> is constructed as
follows: From a given key <code>k</code>, two distinct subkeys <code>k_i</code> and
<code>k_o</code> are constructed, both of length <code>b</code>. The
<acronym>HMAC-H</acronym> of a message <code>m</code> is then computed as <code>H(k_o |
H(k_i | m))</code>, where <code>|</code> denotes string concatenation.
</p>
<p><acronym>HMAC</acronym> keys can be of any length, but it is recommended to use
keys of length <code>l</code>, the digest size of the underlying hash function
<code>H</code>. Keys that are longer than <code>b</code> are shortened to length
<code>l</code> by hashing with <code>H</code>, so arbitrarily long keys aren&rsquo;t
very useful. 
</p>
<p>Nettle&rsquo;s <acronym>HMAC</acronym> functions are defined in <samp>&lt;nettle/hmac.h&gt;</samp>.
There are abstract functions that use a pointer to a <code>struct
nettle_hash</code> to represent the underlying hash function and <code>void *</code>
pointers that point to three different context structs for that hash
function. There are also concrete functions for <acronym>HMAC-MD5</acronym>,
<acronym>HMAC-RIPEMD160</acronym> <acronym>HMAC-SHA1</acronym>, <acronym>HMAC-SHA256</acronym>,
<acronym>HMAC-SHA512</acronym>, and <acronym>HMAC-SM3</acronym>. First, the abstract functions:
</p>
<dl>
<dt id="index-hmac_005fset_005fkey">Function: <em>void</em> <strong>hmac_set_key</strong> <em>(void *<var>outer</var>, void *<var>inner</var>, void *<var>state</var>, const struct nettle_hash *<var>H</var>, size_t <var>length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the three context structs from the key. The <var>outer</var> and
<var>inner</var> contexts corresponds to the subkeys <code>k_o</code> and
<code>k_i</code>. <var>state</var> is used for hashing the message, and is
initialized as a copy of the <var>inner</var> context.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fupdate">Function: <em>void</em> <strong>hmac_update</strong> <em>(void *<var>state</var>, const struct nettle_hash *<var>H</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>This function is called zero or more times to process the message.
Actually, <code>hmac_update(state, H, length, data)</code> is equivalent to
<code>H-&gt;update(state, length, data)</code>, so if you wish you can use the
ordinary update function of the underlying hash function instead.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fdigest">Function: <em>void</em> <strong>hmac_digest</strong> <em>(const void *<var>outer</var>, const void *<var>inner</var>, void *<var>state</var>, const struct nettle_hash *<var>H</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>.
<var>outer</var> and <var>inner</var> are not modified. <var>length</var> is usually
equal to <code>H-&gt;digest_size</code>, but if you provide a smaller value,
only the first <var>length</var> octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the <var>state</var> context so that you can start
over processing a new message (with the same key).
</p></dd></dl>

<p>Like for <acronym>CBC</acronym>, there are some macros to help use these
functions correctly.
</p>
<dl>
<dt id="index-HMAC_005fCTX">Macro: <strong>HMAC_CTX</strong> <em>(<var>type</var>)</em></dt>
<dd><p>Expands to
</p><div class="example">
<pre class="example">{
   type outer;
   type inner;
   type state;
}
</pre></div>
</dd></dl>

<p>It can be used to define a <acronym>HMAC</acronym> context struct, either
directly,
</p>
<div class="example">
<pre class="example">struct HMAC_CTX(struct md5_ctx) ctx;
</pre></div>

<p>or to give it a struct tag,
</p>
<div class="example">
<pre class="example">struct hmac_md5_ctx HMAC_CTX (struct md5_ctx);
</pre></div>

<dl>
<dt id="index-HMAC_005fSET_005fKEY">Macro: <strong>HMAC_SET_KEY</strong> <em>(<var>ctx</var>, <var>H</var>, <var>length</var>, <var>key</var>)</em></dt>
<dd><p><var>ctx</var> is a pointer to a context struct as defined by
<code>HMAC_CTX</code>, <var>H</var> is a pointer to a <code>const struct
nettle_hash</code> describing the underlying hash function (so it must match
the type of the components of <var>ctx</var>). The last two arguments specify
the secret key.
</p></dd></dl>

<dl>
<dt id="index-HMAC_005fDIGEST">Macro: <strong>HMAC_DIGEST</strong> <em>(<var>ctx</var>, <var>H</var>, <var>length</var>, <var>digest</var>)</em></dt>
<dd><p><var>ctx</var> is a pointer to a context struct as defined by
<code>HMAC_CTX</code>, <var>H</var> is a pointer to a <code>const struct
nettle_hash</code> describing the underlying hash function. The last two
arguments specify where the digest is written.
</p></dd></dl>

<p>Note that there is no <code>HMAC_UPDATE</code> macro; simply call
<code>hmac_update</code> function directly, or the update function of the
underlying hash function.
</p>
<p>Now we come to the specialized <acronym>HMAC</acronym> functions, which are
easier to use than the general <acronym>HMAC</acronym> functions.
</p>
<span id="HMAC_002dMD5"></span><h4 class="subsubsection">7.5.1.1 <acronym>HMAC-MD5</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fmd5_005fctx">Context struct: <strong>struct hmac_md5_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fmd5_005fset_005fkey">Function: <em>void</em> <strong>hmac_md5_set_key</strong> <em>(struct hmac_md5_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fmd5_005fupdate">Function: <em>void</em> <strong>hmac_md5_update</strong> <em>(struct hmac_md5_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fmd5_005fdigest">Function: <em>void</em> <strong>hmac_md5_digest</strong> <em>(struct hmac_md5_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>MD5_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>

<span id="HMAC_002dRIPEMD160"></span><h4 class="subsubsection">7.5.1.2 <acronym>HMAC-RIPEMD160</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fripemd160_005fctx">Context struct: <strong>struct hmac_ripemd160_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fripemd160_005fset_005fkey">Function: <em>void</em> <strong>hmac_ripemd160_set_key</strong> <em>(struct hmac_ripemd160_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fripemd160_005fupdate">Function: <em>void</em> <strong>hmac_ripemd160_update</strong> <em>(struct hmac_ripemd160_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fripemd160_005fdigest">Function: <em>void</em> <strong>hmac_ripemd160_digest</strong> <em>(struct hmac_ripemd160_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>RIPEMD160_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>

<span id="HMAC_002dSHA1"></span><h4 class="subsubsection">7.5.1.3 <acronym>HMAC-SHA1</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fsha1_005fctx">Context struct: <strong>struct hmac_sha1_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fsha1_005fset_005fkey">Function: <em>void</em> <strong>hmac_sha1_set_key</strong> <em>(struct hmac_sha1_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha1_005fupdate">Function: <em>void</em> <strong>hmac_sha1_update</strong> <em>(struct hmac_sha1_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha1_005fdigest">Function: <em>void</em> <strong>hmac_sha1_digest</strong> <em>(struct hmac_sha1_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA1_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>


<span id="HMAC_002dSHA256"></span><h4 class="subsubsection">7.5.1.4 <acronym>HMAC-SHA256</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fsha256_005fctx">Context struct: <strong>struct hmac_sha256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fsha256_005fset_005fkey">Function: <em>void</em> <strong>hmac_sha256_set_key</strong> <em>(struct hmac_sha256_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha256_005fupdate">Function: <em>void</em> <strong>hmac_sha256_update</strong> <em>(struct hmac_sha256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha256_005fdigest">Function: <em>void</em> <strong>hmac_sha256_digest</strong> <em>(struct hmac_sha256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>


<span id="HMAC_002dSHA512"></span><h4 class="subsubsection">7.5.1.5 <acronym>HMAC-SHA512</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fsha512_005fctx">Context struct: <strong>struct hmac_sha512_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fsha512_005fset_005fkey">Function: <em>void</em> <strong>hmac_sha512_set_key</strong> <em>(struct hmac_sha512_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha512_005fupdate">Function: <em>void</em> <strong>hmac_sha512_update</strong> <em>(struct hmac_sha512_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsha512_005fdigest">Function: <em>void</em> <strong>hmac_sha512_digest</strong> <em>(struct hmac_sha512_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>


<span id="HMAC_002dSM3"></span><h4 class="subsubsection">7.5.1.6 <acronym>HMAC-SM3</acronym></h4>

<dl>
<dt id="index-struct-hmac_005fsm3_005fctx">Context struct: <strong>struct hmac_sm3_ctx</strong></dt>
</dl>

<dl>
<dt id="index-hmac_005fsm3_005fset_005fkey">Function: <em>void</em> <strong>hmac_sm3_set_key</strong> <em>(struct hmac_sm3_ctx *<var>ctx</var>, size_t <var>key_length</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initializes the context with the key.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsm3_005fupdate">Function: <em>void</em> <strong>hmac_sm3_update</strong> <em>(struct hmac_sm3_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process some more data.
</p></dd></dl>

<dl>
<dt id="index-hmac_005fsm3_005fdigest">Function: <em>void</em> <strong>hmac_sm3_digest</strong> <em>(struct hmac_sm3_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SM3_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.
</p>
<p>This function also resets the context for processing new messages, with
the same key.
</p></dd></dl>

<hr>
<span id="UMAC"></span><div class="header">
<p>
Next: <a href="#CMAC" accesskey="n" rel="next">CMAC</a>, Previous: <a href="#HMAC" accesskey="p" rel="prev">HMAC</a>, Up: <a href="#Keyed-hash-functions" accesskey="u" rel="up">Keyed hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="UMAC-1"></span><h4 class="subsection">7.5.2 <acronym>UMAC</acronym></h4>
<span id="index-UMAC"></span>

<p><acronym>UMAC</acronym> is a message authentication code based on universal
hashing, and designed for high performance on modern processors (in
contrast to GCM, See <a href="#GCM">GCM</a>, which is designed primarily for hardware
performance). On processors with good integer multiplication
performance, it can be 10 times faster than SHA256 and SHA512.
<acronym>UMAC</acronym> is specified in <cite>RFC 4418</cite>.
</p>
<p>The secret key is always 128 bits (16 octets). The key is used as an
encryption key for the <acronym>AES</acronym> block cipher. This cipher is used
in counter mode to generate various internal subkeys needed in
<acronym>UMAC</acronym>. Messages are of arbitrary size, and for each message,
<acronym>UMAC</acronym> also needs a unique nonce. Nonce values must not be
reused for two messages with the same key, but they need not be kept
secret.
</p>
<p>The nonce must be at least one octet, and at most 16; nonces shorter
than 16 octets are zero-padded. Nettle&rsquo;s implementation of
<acronym>UMAC</acronym> increments the nonce automatically for each message, so
explicitly setting the nonce for each message is optional. This
auto-increment uses network byte order and it takes the length of the
nonce into account. E.g., if the initial nonce is &ldquo;abc&rdquo; (3 octets),
this value is zero-padded to 16 octets for the first message. For the
next message, the nonce is incremented to &ldquo;abd&rdquo;, and this incremented
value is zero-padded to 16 octets.
</p>
<p><acronym>UMAC</acronym> is defined in four variants, for different output sizes:
32 bits (4 octets), 64 bits (8 octets), 96 bits (12 octets) and 128 bits
(16 octets), corresponding to different trade-offs between speed and
security. Using a shorter output size sometimes (but not always!) gives
the same result as using a longer output size and truncating the result.
So it is important to use the right variant. For consistency with other
hash and <acronym>MAC</acronym> functions, Nettle&rsquo;s <code>_digest</code> functions for
<acronym>UMAC</acronym> accept a length parameter so that the output can be
truncated to any desired size, but it is recommended to stick to the
specified output size and select the <acronym>umac</acronym> variant
corresponding to the desired size.
</p>
<p>The internal block size of <acronym>UMAC</acronym> is 1024 octets, and it also
generates more than 1024 bytes of subkeys. This makes the size of the
context struct quite a bit larger than other hash functions and
<acronym>MAC</acronym> algorithms in Nettle.
</p>
<p>Nettle defines <acronym>UMAC</acronym> in <samp>&lt;nettle/umac.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-umac32_005fctx">Context struct: <strong>struct umac32_ctx</strong></dt>
<dt id="index-struct-umac64_005fctx">Context struct: <strong>struct umac64_ctx</strong></dt>
<dt id="index-struct-umac96_005fctx">Context struct: <strong>struct umac96_ctx</strong></dt>
<dt id="index-struct-umac128_005fctx">Context struct: <strong>struct umac128_ctx</strong></dt>
<dd><p>Each <acronym>UMAC</acronym> variant uses its own context struct.
</p></dd></dl>

<dl>
<dt id="index-UMAC_005fKEY_005fSIZE">Constant: <strong>UMAC_KEY_SIZE</strong></dt>
<dd><p>The UMAC key size, 16.
</p></dd></dl>
<dl>
<dt id="index-UMAC_005fMIN_005fNONCE_005fSIZE">Constant: <strong>UMAC_MIN_NONCE_SIZE</strong></dt>
<dt id="index-UMAC_005fMAX_005fNONCE_005fSIZE">Constant: <strong>UMAC_MAX_NONCE_SIZE</strong></dt>
<dd><p>The the minimum and maximum sizes for an UMAC nonce, 1 and 16,
respectively.
</p></dd></dl>
<dl>
<dt id="index-UMAC32_005fDIGEST_005fSIZE">Constant: <strong>UMAC32_DIGEST_SIZE</strong></dt>
<dd><p>The size of an UMAC32 digest, 4.
</p></dd></dl>
<dl>
<dt id="index-UMAC64_005fDIGEST_005fSIZE">Constant: <strong>UMAC64_DIGEST_SIZE</strong></dt>
<dd><p>The size of an UMAC64 digest, 8.
</p></dd></dl>
<dl>
<dt id="index-UMAC96_005fDIGEST_005fSIZE">Constant: <strong>UMAC96_DIGEST_SIZE</strong></dt>
<dd><p>The size of an UMAC96 digest, 12.
</p></dd></dl>
<dl>
<dt id="index-UMAC128_005fDIGEST_005fSIZE">Constant: <strong>UMAC128_DIGEST_SIZE</strong></dt>
<dd><p>The size of an UMAC128 digest, 16.
</p></dd></dl>
<dl>
<dt id="index-UMAC_005fBLOCK_005fSIZE">Constant: <strong>UMAC_BLOCK_SIZE</strong></dt>
<dd><p>The internal block size of UMAC.
</p></dd></dl>

<dl>
<dt id="index-umac32_005fset_005fkey">Function: <em>void</em> <strong>umac32_set_key</strong> <em>(struct umac32_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-umac64_005fset_005fkey">Function: <em>void</em> <strong>umac64_set_key</strong> <em>(struct umac64_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-umac96_005fset_005fkey">Function: <em>void</em> <strong>umac96_set_key</strong> <em>(struct umac96_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dt id="index-umac128_005fset_005fkey">Function: <em>void</em> <strong>umac128_set_key</strong> <em>(struct umac128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>These functions initialize the <acronym>UMAC</acronym> context struct. They also
initialize the nonce to zero (with length 16, for auto-increment).
</p></dd></dl>

<dl>
<dt id="index-umac32_005fset_005fnonce">Function: <em>void</em> <strong>umac32_set_nonce</strong> <em>(struct umac32_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dt id="index-umac64_005fset_005fnonce">Function: <em>void</em> <strong>umac64_set_nonce</strong> <em>(struct umac64_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dt id="index-umac96_005fset_005fnonce">Function: <em>void</em> <strong>umac96_set_nonce</strong> <em>(struct umac96_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dt id="index-umac128_005fset_005fnonce">Function: <em>void</em> <strong>umac128_set_nonce</strong> <em>(struct umac128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Sets the nonce to be used for the next message. In general, nonces
should be set before processing of the message. This is not strictly
required for <acronym>UMAC</acronym> (the nonce only affects the final processing
generating the digest), but it is nevertheless recommended that this
function is called <em>before</em> the first <code>_update</code> call for the
message.
</p></dd></dl>

<dl>
<dt id="index-umac32_005fupdate">Function: <em>void</em> <strong>umac32_update</strong> <em>(struct umac32_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-umac64_005fupdate">Function: <em>void</em> <strong>umac64_update</strong> <em>(struct umac64_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-umac96_005fupdate">Function: <em>void</em> <strong>umac96_update</strong> <em>(struct umac96_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dt id="index-umac128_005fupdate">Function: <em>void</em> <strong>umac128_update</strong> <em>(struct umac128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>These functions are called zero or more times to process the message.
</p></dd></dl>

<dl>
<dt id="index-umac32_005fdigest">Function: <em>void</em> <strong>umac32_digest</strong> <em>(struct umac32_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-umac64_005fdigest">Function: <em>void</em> <strong>umac64_digest</strong> <em>(struct umac64_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-umac96_005fdigest">Function: <em>void</em> <strong>umac96_digest</strong> <em>(struct umac96_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dt id="index-umac128_005fdigest">Function: <em>void</em> <strong>umac128_digest</strong> <em>(struct umac128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>.
<var>length</var> is usually equal to the specified output size, but if you
provide a smaller value, only the first <var>length</var> octets of the
<acronym>MAC</acronym> are written. These functions reset the context for
processing of a new message with the same key. The nonce is incremented
as described above, the new value is used unless you call the
<code>_set_nonce</code> function explicitly for each message.
</p></dd></dl>

<hr>
<span id="CMAC"></span><div class="header">
<p>
Next: <a href="#Poly1305" accesskey="n" rel="next">Poly1305</a>, Previous: <a href="#UMAC" accesskey="p" rel="prev">UMAC</a>, Up: <a href="#Keyed-hash-functions" accesskey="u" rel="up">Keyed hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="CMAC-1"></span><h4 class="subsection">7.5.3 <acronym>CMAC</acronym></h4>
<span id="index-CMAC"></span>
<span id="index-CMAC_002d128"></span>
<span id="index-CMAC_002d64"></span>

<p><acronym>CMAC</acronym> is a message authentication code based on CBC encryption
mode. It is suitable for systems where block ciphers are preferrable
and perform better than hash functions. <acronym>CMAC-128</acronym> is specified in
<cite>RFC4493</cite>. The block size is always 128 bits (16 octets).
<acronym>CMAC-64</acronym> is specified by
<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38B.pdf">NIST Special Publication 800-38B</a>. The block size is always 64 bits
(8 octets).
</p>
<p>Nettle provides helper functions for <acronym>CMAC-128</acronym> with
the <acronym>AES</acronym> block cipher and for <acronym>CMAC-64</acronym> with
the <acronym>Tripple-DES</acronym> block cipher.
</p>
<p>Nettle defines <acronym>CMAC</acronym> in <samp>&lt;nettle/cmac.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-cmac_005faes128_005fctx">Context struct: <strong>struct cmac_aes128_ctx</strong></dt>
<dt id="index-struct-cmac_005faes256_005fctx">Context struct: <strong>struct cmac_aes256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-CMAC128_005fDIGEST_005fSIZE">Constant: <strong>CMAC128_DIGEST_SIZE</strong></dt>
<dd><p>The size of an CMAC-128 digest, 16.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes128_005fset_005fkey">Function: <em>void</em> <strong>cmac_aes128_set_key</strong> <em>(struct cmac_aes128_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>This function initializes the <acronym>CMAC</acronym> context struct for AES-128.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes128_005fupdate">Function: <em>void</em> <strong>cmac_aes128_update</strong> <em>(struct cmac_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>This function is called zero or more times to process the message.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes128_005fdigest">Function: <em>void</em> <strong>cmac_aes128_digest</strong> <em>(struct cmac_aes128_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>.
<var>length</var> is usually equal to the specified output size, but if you
provide a smaller value, only the first <var>length</var> octets of the
<acronym>MAC</acronym> are written. This function resets the context for
processing of a new message with the same key.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes256_005fset_005fkey">Function: <em>void</em> <strong>cmac_aes256_set_key</strong> <em>(struct cmac_aes256_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>This function initializes the <acronym>CMAC</acronym> context struct for AES-256.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes256_005fupdate">Function: <em>void</em> <strong>cmac_aes256_update</strong> <em>(struct cmac_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>This function is called zero or more times to process the message.
</p></dd></dl>

<dl>
<dt id="index-cmac_005faes256_005fdigest">Function: <em>void</em> <strong>cmac_aes256_digest</strong> <em>(struct cmac_aes256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>.
<var>length</var> is usually equal to the specified output size, but if you
provide a smaller value, only the first <var>length</var> octets of the
<acronym>MAC</acronym> are written. This function resets the context for
processing of a new message with the same key.
</p></dd></dl>

<dl>
<dt id="index-struct-cmac_005fdes3_005fctx">Context struct: <strong>struct cmac_des3_ctx</strong></dt>
</dl>

<dl>
<dt id="index-CMAC64_005fDIGEST_005fSIZE">Constant: <strong>CMAC64_DIGEST_SIZE</strong></dt>
<dd><p>The size of an CMAC-64 digest, 8.
</p></dd></dl>

<dl>
<dt id="index-cmac_005fdes3_005fset_005fkey">Function: <em>void</em> <strong>cmac_des3_set_key</strong> <em>(struct cmac_des3_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>This function initializes the <acronym>CMAC</acronym> context struct for <acronym>Tripple-DES</acronym>.
</p></dd></dl>

<dl>
<dt id="index-cmac_005fdes3_005fupdate">Function: <em>void</em> <strong>cmac_des3_update</strong> <em>(struct cmac_des3_ctx *<var>ctx</var>,size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>This function is called zero or more times to process the message.
</p></dd></dl>

<dl>
<dt id="index-cmac_005fdes3_005fdigest">Function: <em>void</em> <strong>cmac_des3_digest</strong> <em>(struct cmac_des3_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>.
<var>length</var> is usually equal to the specified output size, but if you
provide a smaller value, only the first <var>length</var> octets of the
<acronym>MAC</acronym> are written. This function resets the context for
processing of a new message with the same key.
</p></dd></dl>

<hr>
<span id="Poly1305"></span><div class="header">
<p>
Previous: <a href="#CMAC" accesskey="p" rel="prev">CMAC</a>, Up: <a href="#Keyed-hash-functions" accesskey="u" rel="up">Keyed hash functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Poly1305-1"></span><h4 class="subsection">7.5.4 Poly1305</h4>

<p>Poly1305-<acronym>AES</acronym> is a message authentication code designed by D. J.
Bernstein. It treats the message as a polynomial modulo the prime number
<em>2^130 - 5</em>.
</p>
<p>The key, 256 bits, consists of two parts, where the first half is an
<acronym>AES</acronym>-128 key, and the second half specifies the point where the
polynomial is evaluated. Of the latter half, 22 bits are set to zero, to
enable high-performance implementation, leaving 106 bits for specifying
an evaluation point <code>r</code>. For each message, one must also provide a
128-bit nonce. The nonce is encrypted using the <acronym>AES</acronym> key, and
that&rsquo;s the only thing <acronym>AES</acronym> is used for.
</p>
<p>The message is split into 128-bit chunks (with final chunk possibly
being shorter), each read as a little-endian integer. Each chunk has a
one-bit appended at the high end. The resulting integers are treated as
polynomial coefficients modulo <em>2^130 - 5</em>, and the polynomial is
evaluated at the point <code>r</code>. Finally, this value is reduced modulo
<em>2^128</em>, and added (also modulo <em>2^128</em>) to the encrypted
nonce, to produce an 128-bit authenticator for the message. See
<a href="https://cr.yp.to/mac/poly1305-20050329.pdf">https://cr.yp.to/mac/poly1305-20050329.pdf</a> for further details.
</p>
<p>Clearly, variants using a different cipher than <acronym>AES</acronym> could be
defined. Another variant is the ChaCha-Poly1305 <acronym>AEAD</acronym>
construction (see <a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a>). Nettle defines
Poly1305-<acronym>AES</acronym> in <samp>nettle/poly1305.h</samp>.
</p>
<dl>
<dt id="index-POLY1305_005fAES_005fKEY_005fSIZE">Constant: <strong>POLY1305_AES_KEY_SIZE</strong></dt>
<dd><p>Key size, 32 octets.
</p></dd></dl>

<dl>
<dt id="index-POLY1305_005fAES_005fDIGEST_005fSIZE">Constant: <strong>POLY1305_AES_DIGEST_SIZE</strong></dt>
<dd><p>Size of the digest or &ldquo;authenticator&rdquo;, 16 octets.
</p></dd></dl>

<dl>
<dt id="index-POLY1305_005fAES_005fNONCE_005fSIZE">Constant: <strong>POLY1305_AES_NONCE_SIZE</strong></dt>
<dd><p>Nonce size, 16 octets.
</p></dd></dl>

<dl>
<dt id="index-struct-poly1305_005faes_005fctx">Context struct: <strong>struct poly1305_aes_ctx</strong></dt>
<dd><p>The poly1305-aes context struct.
</p></dd></dl>

<dl>
<dt id="index-poly1305_005faes_005fset_005fkey">Function: <em>void</em> <strong>poly1305_aes_set_key</strong> <em>(struct poly1305_aes_ctx *<var>ctx</var>, const uint8_t *<var>key</var>)</em></dt>
<dd><p>Initialize the context struct. Also sets the nonce to zero.
</p></dd></dl>

<dl>
<dt id="index-poly1305_005faes_005fset_005fnonce">Function: <em>void</em> <strong>poly1305_aes_set_nonce</strong> <em>(struct poly1305_aes_ctx *<var>ctx</var>, const uint8_t *<var>nonce</var>)</em></dt>
<dd><p>Sets the nonce. Calling this function is optional, since the nonce is
incremented automatically for each message.
</p></dd></dl>

<dl>
<dt id="index-poly1305_005faes_005fupdate">Function: <em>void</em> <strong>poly1305_aes_update</strong> <em>(struct poly1305_aes_ctx *<var>ctx</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Process more data.
</p></dd></dl>

<dl>
<dt id="index-poly1305_005faes_005fdigest">Function: <em>void</em> <strong>poly1305_aes_digest</strong> <em>(struct poly1305_aes_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>digest</var>)</em></dt>
<dd><p>Extracts the digest. If <var>length</var> is smaller than
<code>POLY1305_AES_DIGEST_SIZE</code>, only the first <var>length</var> octets are
written. Also increments the nonce, and prepares the context for
processing a new message.
</p></dd></dl>


<hr>
<span id="Key-derivation-functions"></span><div class="header">
<p>
Next: <a href="#Public_002dkey-algorithms" accesskey="n" rel="next">Public-key algorithms</a>, Previous: <a href="#Keyed-hash-functions" accesskey="p" rel="prev">Keyed hash functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Key-derivation-Functions"></span><h3 class="section">7.6 Key derivation Functions</h3>
<span id="index-Key-Derivation-Function"></span>

<p>A <em>key derivation function</em> (<acronym>KDF</acronym>) is a function that from
a given symmetric key derives other symmetric keys.  A sub-class of KDFs
is the <em>password-based key derivation functions</em> (<acronym>PBKDFs</acronym>),
which take as input a password or passphrase, and its purpose is
typically to strengthen it and protect against certain pre-computation
attacks by using salting and expensive computation.
</p>
<span id="HKDF_003a-HMAC_002dbased-Extract_002dand_002dExpand"></span><h4 class="subsection">7.6.1 HKDF: HMAC-based Extract-and-Expand</h4>
<span id="index-HKDF"></span>

<p>HKDF is a key derivation function used as a building block of
higher-level protocols like TLS 1.3. It is a derivation function
based on HMAC described in <cite>RFC 5869</cite>,
and is split into two logical modules, called &rsquo;extract&rsquo; and &rsquo;expand&rsquo;.
The extract module takes an initial secret and a random
salt to &quot;extract&quot; a fixed-length pseudorandom key (PRK). The second stage
takes as input the previous PRK and some informational data (e.g.,
text) and expands them into multiple keys.
</p>
<p>Nettle&rsquo;s <acronym>HKDF</acronym> functions are defined in
<samp>&lt;nettle/hkdf.h&gt;</samp>.  There are two abstract functions for the extract
and expand operations that operate on any HMAC implemented via the <code>nettle_hash_update_func</code>,
and <code>nettle_hash_digest_func</code> interfaces.
</p>
<dl>
<dt id="index-hkdf_005fextract">Function: <em>void</em> <strong>hkdf_extract</strong> <em>(void *mac_ctx, nettle_hash_update_func *update, nettle_hash_digest_func *digest, size_t digest_size,size_t secret_size, const uint8_t *secret, uint8_t *dst)</em></dt>
<dd><p>Extract a Pseudorandom Key (PRK) from a secret and a salt according
to HKDF. The HMAC must have been initialized, with its key being the
salt for the Extract operation. This function will call the
<var>update</var> and <var>digest</var> functions passing the <var>mac_ctx</var>
context parameter as an argument in order to compute digest of size
<var>digest_size</var>.  Inputs are the secret <var>secret</var> of length
<var>secret_length</var>. The output length is fixed to <var>digest_size</var> octets,
thus the output buffer <var>dst</var> must have room for at least <var>digest_size</var> octets.
</p></dd></dl>

<dl>
<dt id="index-hkdf_005fexpand">Function: <em>void</em> <strong>hkdf_expand</strong> <em>(void *mac_ctx, nettle_hash_update_func *update, nettle_hash_digest_func *digest, size_t digest_size, size_t info_size, const uint8_t *info, size_t length, uint8_t *dst)</em></dt>
<dd><p>Expand a Pseudorandom Key (PRK) to an arbitrary size according to HKDF.
The HMAC must have been initialized, with its key being the
PRK from the Extract operation. This function will call the
<var>update</var> and <var>digest</var> functions passing the <var>mac_ctx</var>
context parameter as an argument in order to compute digest of size
<var>digest_size</var>.  Inputs are the info <var>info</var> of length
<var>info_length</var>, and the desired derived output length <var>length</var>.
The output buffer is <var>dst</var> which must have room for at least <var>length</var> octets.
</p></dd></dl>


<span id="PBKDF2"></span><h4 class="subsection">7.6.2 <acronym>PBKDF2</acronym></h4>
<span id="index-Password-Based-Key-Derivation-Function"></span>
<span id="index-PKCS-_00235"></span>
<span id="index-KDF"></span>
<span id="index-PBKDF"></span>
<p>The most well known PBKDF is the <code>PKCS #5 PBKDF2</code> described in
<cite>RFC 2898</cite> which uses a pseudo-random function such as
<acronym>HMAC-SHA1</acronym>.
</p>
<p>Nettle&rsquo;s <acronym>PBKDF2</acronym> functions are defined in
<samp>&lt;nettle/pbkdf2.h&gt;</samp>.  There is an abstract function that operate on
any PRF implemented via the <code>nettle_hash_update_func</code>,
<code>nettle_hash_digest_func</code> interfaces.  There is also helper macros
and concrete functions PBKDF2-HMAC-SHA1, PBKDF2-HMAC-SHA256, PBKDF2-HMAC-SHA384
and PBKDF2-HMAC-SHA512.  First, the abstract function:
</p>
<dl>
<dt id="index-pbkdf2">Function: <em>void</em> <strong>pbkdf2</strong> <em>(void *mac_ctx, nettle_hash_update_func *update, nettle_hash_digest_func *digest, size_t digest_size, unsigned iterations, size_t salt_length, const uint8_t *salt, size_t length, uint8_t *dst)</em></dt>
<dd><p>Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
PRF is assumed to have been initialized and this function will call the
<var>update</var> and <var>digest</var> functions passing the <var>mac_ctx</var>
context parameter as an argument in order to compute digest of size
<var>digest_size</var>.  Inputs are the salt <var>salt</var> of length
<var>salt_length</var>, the iteration counter <var>iterations</var> (&gt; 0), and the
desired derived output length <var>length</var>.  The output buffer is
<var>dst</var> which must have room for at least <var>length</var> octets.
</p></dd></dl>

<p>Like for CBC and HMAC, there is a macro to help use the function
correctly.
</p>
<dl>
<dt id="index-PBKDF2">Macro: <strong>PBKDF2</strong> <em>(<var>ctx</var>, <var>update</var>, <var>digest</var>, <var>digest_size</var>, <var>iterations</var>, <var>salt_length</var>, <var>salt</var>, <var>length</var>, <var>dst</var>)</em></dt>
<dd><p><var>ctx</var> is a pointer to a context struct passed to the <var>update</var>
and <var>digest</var> functions (of the types <code>nettle_hash_update_func</code>
and <code>nettle_hash_digest_func</code> respectively) to implement the
underlying PRF with digest size of <var>digest_size</var>.  Inputs are the
salt <var>salt</var> of length <var>salt_length</var>, the iteration counter
<var>iterations</var> (&gt; 0), and the desired derived output length
<var>length</var>.  The output buffer is <var>dst</var> which must have room for
at least <var>length</var> octets.
</p></dd></dl>

<span id="Concrete-PBKDF2-functions"></span><h4 class="subsection">7.6.3 Concrete <acronym>PBKDF2</acronym> functions</h4>
<p>Now we come to the specialized <acronym>PBKDF2</acronym> functions, which are
easier to use than the general <acronym>PBKDF2</acronym> function.
</p>
<span id="PBKDF2_002dHMAC_002dSHA1"></span><h4 class="subsubsection">7.6.3.1 <acronym>PBKDF2-HMAC-SHA1</acronym></h4>

<dl>
<dt id="index-pbkdf2_005fhmac_005fsha1">Function: <em>void</em> <strong>pbkdf2_hmac_sha1</strong> <em>(size_t <var>key_length</var>, const uint8_t *<var>key</var>, unsigned <var>iterations</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, size_t <var>length</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>PBKDF2 with HMAC-SHA1.  Derive <var>length</var> bytes of key into buffer
<var>dst</var> using the password <var>key</var> of length <var>key_length</var> and
salt <var>salt</var> of length <var>salt_length</var>, with iteration counter
<var>iterations</var> (&gt; 0).  The output buffer is <var>dst</var> which must have
room for at least <var>length</var> octets.
</p></dd></dl>

<span id="PBKDF2_002dHMAC_002dSHA256"></span><h4 class="subsubsection">7.6.3.2 <acronym>PBKDF2-HMAC-SHA256</acronym></h4>

<dl>
<dt id="index-pbkdf2_005fhmac_005fsha256">Function: <em>void</em> <strong>pbkdf2_hmac_sha256</strong> <em>(size_t <var>key_length</var>, const uint8_t *<var>key</var>, unsigned <var>iterations</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, size_t <var>length</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>PBKDF2 with HMAC-SHA256.  Derive <var>length</var> bytes of key into buffer
<var>dst</var> using the password <var>key</var> of length <var>key_length</var> and
salt <var>salt</var> of length <var>salt_length</var>, with iteration counter
<var>iterations</var> (&gt; 0).  The output buffer is <var>dst</var> which must have
room for at least <var>length</var> octets.
</p></dd></dl>

<span id="PBKDF2_002dHMAC_002dSHA384"></span><h4 class="subsubsection">7.6.3.3 <acronym>PBKDF2-HMAC-SHA384</acronym></h4>

<dl>
<dt id="index-pbkdf2_005fhmac_005fsha384">Function: <em>void</em> <strong>pbkdf2_hmac_sha384</strong> <em>(size_t <var>key_length</var>, const uint8_t *<var>key</var>, unsigned <var>iterations</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, size_t <var>length</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>PBKDF2 with HMAC-SHA384.  Derive <var>length</var> bytes of key into buffer
<var>dst</var> using the password <var>key</var> of length <var>key_length</var> and
salt <var>salt</var> of length <var>salt_length</var>, with iteration counter
<var>iterations</var> (&gt; 0).  The output buffer is <var>dst</var> which must have
room for at least <var>length</var> octets.
</p></dd></dl>

<span id="PBKDF2_002dHMAC_002dSHA512"></span><h4 class="subsubsection">7.6.3.4 <acronym>PBKDF2-HMAC-SHA512</acronym></h4>

<dl>
<dt id="index-pbkdf2_005fhmac_005fsha512">Function: <em>void</em> <strong>pbkdf2_hmac_sha512</strong> <em>(size_t <var>key_length</var>, const uint8_t *<var>key</var>, unsigned <var>iterations</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, size_t <var>length</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>PBKDF2 with HMAC-SHA512.  Derive <var>length</var> bytes of key into buffer
<var>dst</var> using the password <var>key</var> of length <var>key_length</var> and
salt <var>salt</var> of length <var>salt_length</var>, with iteration counter
<var>iterations</var> (&gt; 0).  The output buffer is <var>dst</var> which must have
room for at least <var>length</var> octets.
</p></dd></dl>

<hr>
<span id="Public_002dkey-algorithms"></span><div class="header">
<p>
Next: <a href="#Randomness" accesskey="n" rel="next">Randomness</a>, Previous: <a href="#Key-derivation-functions" accesskey="p" rel="prev">Key derivation functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Public_002dkey-algorithms-1"></span><h3 class="section">7.7 Public-key algorithms</h3>

<p>Nettle uses <acronym>GMP</acronym>, the GNU bignum library, for all calculations
with large numbers. In order to use the public-key features of Nettle,
you must install <acronym>GMP</acronym>, at least version 3.0, before compiling
Nettle, and you need to link your programs with <code>-lhogweed -lnettle
-lgmp</code>.
</p>
<p>The concept of <em>Public-key</em> encryption and digital signatures was
discovered by Whitfield Diffie and Martin E. Hellman and described in a
paper 1976. In traditional, &ldquo;symmetric&rdquo;, cryptography, sender and
receiver share the same keys, and these keys must be distributed in a
secure way. And if there are many users or entities that need to
communicate, each <em>pair</em> needs a shared secret key known by nobody
else.
</p>
<span id="index-Public-Key-Cryptography"></span>
<span id="index-One_002dway-function"></span>

<p>Public-key cryptography uses trapdoor one-way functions. A
<em>one-way function</em> is a function <code>F</code> such that it is easy to
compute the value <code>F(x)</code> for any <code>x</code>, but given a value
<code>y</code>, it is hard to compute a corresponding <code>x</code> such that
<code>y = F(x)</code>. Two examples are cryptographic hash functions, and
exponentiation in certain groups.
</p>
<p>A <em>trapdoor one-way function</em> is a function <code>F</code> that is
one-way, unless one knows some secret information about <code>F</code>. If one
knows the secret, it is easy to compute both <code>F</code> and it&rsquo;s inverse.
If this sounds strange, look at the <acronym>RSA</acronym> example below.
</p>
<p>Two important uses for one-way functions with trapdoors are public-key
encryption, and digital signatures. The public-key encryption functions
in Nettle are not yet documented; the rest of this chapter is about
digital signatures.
</p>
<p>To use a digital signature algorithm, one must first create a
<em>key-pair</em>: A public key and a corresponding private key. The private
key is used to sign messages, while the public key is used for verifying
that that signatures and messages match. Some care must be taken when
distributing the public key; it need not be kept secret, but if a bad
guy is able to replace it (in transit, or in some user&rsquo;s list of known
public keys), bad things may happen.
</p>
<p>There are two operations one can do with the keys. The signature
operation takes a message and a private key, and creates a signature for
the message. A signature is some string of bits, usually at most a few
thousand bits or a few hundred octets. Unlike paper-and-ink signatures,
the digital signature depends on the message, so one can&rsquo;t cut it out of
context and glue it to a different message.
</p>
<p>The verification operation takes a public key, a message, and a string
that is claimed to be a signature on the message, and returns true or
false. If it returns true, that means that the three input values
matched, and the verifier can be sure that someone went through with the
signature operation on that very message, and that the &ldquo;someone&rdquo; also
knows the private key corresponding to the public key.
</p>
<p>The desired properties of a digital signature algorithm are as follows:
Given the public key and pairs of messages and valid signatures on them,
it should be hard to compute the private key, and it should also be hard
to create a new message and signature that is accepted by the
verification operation.
</p>
<p>Besides signing meaningful messages, digital signatures can be used for
authorization. A server can be configured with a public key, such that
any client that connects to the service is given a random nonce message.
If the server gets a reply with a correct signature matching the nonce
message and the configured public key, the client is granted access. So
the configuration of the server can be understood as &ldquo;grant access to
whoever knows the private key corresponding to this particular public
key, and to no others&rdquo;.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#RSA" accesskey="1">RSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The RSA public key algorithm.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DSA" accesskey="2">DSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The DSA digital signature algorithm.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Elliptic-curves" accesskey="3">Elliptic curves</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Elliptic curves and ECDSA
</td></tr>
</table>

<hr>
<span id="RSA"></span><div class="header">
<p>
Next: <a href="#DSA" accesskey="n" rel="next">DSA</a>, Up: <a href="#Public_002dkey-algorithms" accesskey="u" rel="up">Public-key algorithms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="RSA-1"></span><h4 class="subsection">7.7.1 <acronym>RSA</acronym></h4>

<p>The <acronym>RSA</acronym> algorithm was the first practical digital signature
algorithm that was constructed. It was described 1978 in a paper by
Ronald Rivest, Adi Shamir and L.M. Adleman, and the technique was also
patented in the <acronym>USA</acronym> in 1983. The patent expired on September 20, 2000, and since
that day, <acronym>RSA</acronym> can be used freely, even in the <acronym>USA</acronym>.
</p>
<p>It&rsquo;s remarkably simple to describe the trapdoor function behind
<acronym>RSA</acronym>. The &ldquo;one-way&rdquo;-function used is
</p>
<div class="example">
<pre class="example">F(x) = x^e mod n
</pre></div>

<p>I.e. raise x to the <code>e</code>&rsquo;th power, while discarding all multiples of
<code>n</code>. The pair of numbers <code>n</code> and <code>e</code> is the public key.
<code>e</code> can be quite small, even <code>e = 3</code> has been used, although
slightly larger numbers are recommended. <code>n</code> should be about 2000
bits or larger.
</p>
<p>If <code>n</code> is large enough, and properly chosen, the inverse of F,
the computation of <code>e</code>&rsquo;th roots modulo <code>n</code>, is very difficult.
But, where&rsquo;s the trapdoor?
</p>
<p>Let&rsquo;s first look at how <acronym>RSA</acronym> key-pairs are generated. First
<code>n</code> is chosen as the product of two large prime numbers <code>p</code>
and <code>q</code> of roughly the same size (so if <code>n</code> is 2000 bits,
<code>p</code> and <code>q</code> are about 1000 bits each). One also computes the
number <code>phi = (p-1)(q-1)</code>, in mathematical speak, <code>phi</code> is the
order of the multiplicative group of integers modulo n.
</p>
<p>Next, <code>e</code> is chosen. It must have no factors in common with <code>phi</code> (in
particular, it must be odd), but can otherwise be chosen more or less
randomly. <code>e = 65537</code> is a popular choice, because it makes raising
to the <code>e</code>&rsquo;th power particularly efficient, and being prime, it
usually has no factors common with <code>phi</code>.
</p>
<p>Finally, a number <code>d</code>, <code>d &lt; n</code> is computed such that <code>e d
mod phi = 1</code>. It can be shown that such a number exists (this is why
<code>e</code> and <code>phi</code> must have no common factors), and that for all x,
</p>
<div class="example">
<pre class="example">(x^e)^d mod n = x^(ed) mod n = (x^d)^e mod n = x
</pre></div>

<p>Using Euclid&rsquo;s algorithm, <code>d</code> can be computed quite easily from
<code>phi</code> and <code>e</code>. But it is still hard to get <code>d</code> without
knowing <code>phi</code>, which depends on the factorization of <code>n</code>.
</p>
<p>So <code>d</code> is the trapdoor, if we know <code>d</code> and <code>y = F(x)</code>, we can
recover x as <code>y^d mod n</code>. <code>d</code> is also the private half of
the <acronym>RSA</acronym> key-pair.
</p>
<p>The most common signature operation for <acronym>RSA</acronym> is defined in
<cite>PKCS#1</cite>, a specification by RSA Laboratories. The message to be
signed is first hashed using a cryptographic hash function, e.g.
<acronym>MD5</acronym> or <acronym>SHA1</acronym>. Next, some padding, the <acronym>ASN.1</acronym>
&ldquo;Algorithm Identifier&rdquo; for the hash function, and the message digest
itself, are concatenated and converted to a number <code>x</code>. The
signature is computed from <code>x</code> and the private key as <code>s = x^d
mod n</code><a id="DOCF1" href="#FOOT1"><sup>1</sup></a>. The signature, <code>s</code> is a
number of about the same size of <code>n</code>, and it usually encoded as a
sequence of octets, most significant octet first.
</p>
<p>The verification operation is straight-forward, <code>x</code> is computed
from the message in the same way as above. Then <code>s^e mod n</code> is
computed, the operation returns true if and only if the result equals
<code>x</code>.
</p>
<p>The <acronym>RSA</acronym> algorithm can also be used for encryption. RSA encryption uses
the public key <code>(n,e)</code> to compute the ciphertext <code>m^e mod n</code>.
The <cite>PKCS#1</cite> padding scheme will use at least 8 random and non-zero
octets, using <var>m</var> of the form <code>[00 02 padding 00 plaintext]</code>.
It is required that <code>m &lt; n</code>, and therefor the plaintext must be
smaller than the octet size of the modulo <code>n</code>, with some margin.
</p>
<p>To decrypt the message, one needs the private key to compute <code>m =
c^e mod n</code> followed by checking and removing the padding.
</p>
<span id="Nettle_0027s-RSA-support"></span><h4 class="subsubsection">7.7.1.1 Nettle&rsquo;s <acronym>RSA</acronym> support</h4>

<p>Nettle represents <acronym>RSA</acronym> keys using two structures that contain
large numbers (of type <code>mpz_t</code>).
</p>
<dl>
<dt id="index-rsa_005fpublic_005fkey">Context struct: <strong>rsa_public_key</strong> <em>size n e</em></dt>
<dd><p><code>size</code> is the size, in octets, of the modulo, and is used internally.
<code>n</code> and <code>e</code> is the public key.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fprivate_005fkey">Context struct: <strong>rsa_private_key</strong> <em>size d p q a b c</em></dt>
<dd><p><code>size</code> is the size, in octets, of the modulo, and is used internally.
<code>d</code> is the secret exponent, but it is not actually used when
signing. Instead, the factors <code>p</code> and <code>q</code>, and the parameters
<code>a</code>, <code>b</code> and <code>c</code> are used. They are computed from <code>p</code>,
<code>q</code> and <code>e</code> such that <code>a e mod (p - 1) = 1, b e mod (q -
1) = 1, c q mod p = 1</code>.
</p></dd></dl>

<p>Before use, these structs must be initialized by calling one of
</p>
<dl>
<dt id="index-rsa_005fpublic_005fkey_005finit">Function: <em>void</em> <strong>rsa_public_key_init</strong> <em>(struct rsa_public_key *<var>pub</var>)</em></dt>
<dt id="index-rsa_005fprivate_005fkey_005finit">Function: <em>void</em> <strong>rsa_private_key_init</strong> <em>(struct rsa_private_key *<var>key</var>)</em></dt>
<dd><p>Calls <code>mpz_init</code> on all numbers in the key struct.
</p></dd></dl>

<p>and when finished with them, the space for the numbers must be
deallocated by calling one of
</p>
<dl>
<dt id="index-rsa_005fpublic_005fkey_005fclear">Function: <em>void</em> <strong>rsa_public_key_clear</strong> <em>(struct rsa_public_key *<var>pub</var>)</em></dt>
<dt id="index-rsa_005fprivate_005fkey_005fclear">Function: <em>void</em> <strong>rsa_private_key_clear</strong> <em>(struct rsa_private_key *<var>key</var>)</em></dt>
<dd><p>Calls <code>mpz_clear</code> on all numbers in the key struct.
</p></dd></dl>

<p>In general, Nettle&rsquo;s <acronym>RSA</acronym> functions deviates from Nettle&rsquo;s &ldquo;no
memory allocation&rdquo;-policy. Space for all the numbers, both in the key structs
above, and temporaries, are allocated dynamically. For information on how
to customize allocation, see
See <a href="https://www.gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GMP Allocation</a> in <cite>GMP Manual</cite>.
</p>
<p>When you have assigned values to the attributes of a key, you must call
</p>
<dl>
<dt id="index-rsa_005fpublic_005fkey_005fprepare">Function: <em>int</em> <strong>rsa_public_key_prepare</strong> <em>(struct rsa_public_key *<var>pub</var>)</em></dt>
<dt id="index-rsa_005fprivate_005fkey_005fprepare">Function: <em>int</em> <strong>rsa_private_key_prepare</strong> <em>(struct rsa_private_key *<var>key</var>)</em></dt>
<dd><p>Computes the octet size of the key (stored in the <code>size</code> attribute,
and may also do other basic sanity checks. Returns one if successful, or
zero if the key can&rsquo;t be used, for instance if the modulo is smaller
than the minimum size needed for <acronym>RSA</acronym> operations specified by PKCS#1.
</p></dd></dl>

<p>For each operation using the private key, there are two variants, e.g.,
<code>rsa_sha256_sign</code> and <code>rsa_sha256_sign_tr</code>. The former
function is older, and it should be avoided, because it provides no
defenses against side-channel attacks. The latter function use
randomized <acronym>RSA</acronym> blinding, which defends against timing attacks
using chosen-ciphertext, and it also checks the correctness of the
private key computation using the public key, which defends against
software or hardware errors which could leak the private key.
</p>
<p>Before signing or verifying a message, you first hash it with the
appropriate hash function. You pass the hash function&rsquo;s context struct
to the <acronym>RSA</acronym> signature function, and it will extract the message
digest and do the rest of the work. There are also alternative functions
that take the hash digest as argument.
</p>
<p>There is currently no support for using SHA224 or SHA384 with
<acronym>RSA</acronym> signatures, since there&rsquo;s no gain in either computation
time nor message size compared to using SHA256 and SHA512, respectively.
</p>
<p>Creating an <acronym>RSA</acronym> signature is done with one of the following
functions:
</p>
<dl>
<dt id="index-rsa_005fmd5_005fsign_005ftr_0028const">Function: <em>int</em> <strong>rsa_md5_sign_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, struct md5_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fsign_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha1_sign_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, struct sha1_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha256_005fsign_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha256_sign_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, struct sha256_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha512_005fsign_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha512_sign_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, struct sha512_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dd><p>The signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>&rsquo;ed earlier). The hash context is reset so that it can be
used for new messages. The <var>random_ctx</var> and <var>random</var> pointers
are used to generate the <acronym>RSA</acronym> blinding. Returns one on success,
or zero on failure. Signing fails if an error in the computation was
detected, or if the key is too small for the given hash size, e.g., it&rsquo;s
not possible to create a signature using SHA512 and a 512-bit
<acronym>RSA</acronym> key.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fmd5_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_md5_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha1_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha256_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha256_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha512_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_sha512_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dd><p>Creates a signature from the given hash digest. <var>digest</var> should
point to a digest of size <code>MD5_DIGEST_SIZE</code>,
<code>SHA1_DIGEST_SIZE</code>, <code>SHA256_DIGEST_SIZE</code>, or
<code>SHA512_DIGEST_SIZE</code>respectively. The signature is stored in
<var>signature</var> (which must have been <code>mpz_init</code>:ed earlier).
Returns one on success, or zero on failure.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fpkcs1_005fsign_005ftr_0028const">Function: <em>int</em> <strong>rsa_pkcs1_sign_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>length</var>, const uint8_t *<var>digest_info</var>, mpz_t <var>signature</var>)</em></dt>
<dd><p>Similar to the above <code>_sign_digest_tr</code> functions, but the input is not the
plain hash digest, but a PKCS#1 &ldquo;DigestInfo&rdquo;, an ASN.1 DER-encoding
of the digest together with an object identifier for the used hash
algorithm.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fmd5_005fsign">Function: <em>int</em> <strong>rsa_md5_sign</strong> <em>(const struct rsa_private_key *<var>key</var>, struct md5_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fsign">Function: <em>int</em> <strong>rsa_sha1_sign</strong> <em>(const struct rsa_private_key *<var>key</var>, struct sha1_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha256_005fsign">Function: <em>int</em> <strong>rsa_sha256_sign</strong> <em>(const struct rsa_private_key *<var>key</var>, struct sha256_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha512_005fsign">Function: <em>int</em> <strong>rsa_sha512_sign</strong> <em>(const struct rsa_private_key *<var>key</var>, struct sha512_ctx *<var>hash</var>, mpz_t <var>signature</var>)</em></dt>
<dd><p>The signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>&rsquo;ed earlier). The hash context is reset so that it can be
used for new messages. Returns one on success, or zero on failure.
Signing fails if the key is too small for the given hash size, e.g.,
it&rsquo;s not possible to create a signature using SHA512 and a 512-bit
<acronym>RSA</acronym> key.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fmd5_005fsign_005fdigest">Function: <em>int</em> <strong>rsa_md5_sign_digest</strong> <em>(const struct rsa_private_key *<var>key</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fsign_005fdigest">Function: <em>int</em> <strong>rsa_sha1_sign_digest</strong> <em>(const struct rsa_private_key *<var>key</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>);</em></dt>
<dt id="index-rsa_005fsha256_005fsign_005fdigest">Function: <em>int</em> <strong>rsa_sha256_sign_digest</strong> <em>(const struct rsa_private_key *<var>key</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>);</em></dt>
<dt id="index-rsa_005fsha512_005fsign_005fdigest">Function: <em>int</em> <strong>rsa_sha512_sign_digest</strong> <em>(const struct rsa_private_key *<var>key</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>);</em></dt>
<dd><p>Creates a signature from the given hash digest; otherwise analoguous to
the above signing functions. <var>digest</var> should point to a digest of
size <code>MD5_DIGEST_SIZE</code>, <code>SHA1_DIGEST_SIZE</code>,
<code>SHA256_DIGEST_SIZE</code>, or <code>SHA512_DIGEST_SIZE</code>, respectively.
The signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>:ed earlier). Returns one on success, or zero on failure.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fpkcs1_005fsign_0028const">Function: <em>int</em> <strong>rsa_pkcs1_sign(const</strong> <em>struct rsa_private_key *<var>key</var>, size_t <var>length</var>, const uint8_t *<var>digest_info</var>, mpz_t <var>s</var>)</em></dt>
<dd><p>Similar to the above _sign_digest functions, but the input is not the
plain hash digest, but a PKCS#1 &ldquo;DigestInfo&rdquo;, an ASN.1 DER-encoding
of the digest together with an object identifier for the used hash
algorithm.
</p></dd></dl>

<p>Verifying an RSA signature is done with one of the following functions:
</p>
<dl>
<dt id="index-rsa_005fmd5_005fverify">Function: <em>int</em> <strong>rsa_md5_verify</strong> <em>(const struct rsa_public_key *<var>key</var>, struct md5_ctx *<var>hash</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fverify">Function: <em>int</em> <strong>rsa_sha1_verify</strong> <em>(const struct rsa_public_key *<var>key</var>, struct sha1_ctx *<var>hash</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha256_005fverify">Function: <em>int</em> <strong>rsa_sha256_verify</strong> <em>(const struct rsa_public_key *<var>key</var>, struct sha256_ctx *<var>hash</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha512_005fverify">Function: <em>int</em> <strong>rsa_sha512_verify</strong> <em>(const struct rsa_public_key *<var>key</var>, struct sha512_ctx *<var>hash</var>, const mpz_t <var>signature</var>)</em></dt>
<dd><p>Returns 1 if the signature is valid, or 0 if it isn&rsquo;t. In either case,
the hash context is reset so that it can be used for new messages.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fmd5_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_md5_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha1_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_sha1_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha256_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_sha256_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fsha512_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_sha512_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dd><p>Returns 1 if the signature is valid, or 0 if it isn&rsquo;t. <var>digest</var>
should point to a digest of size <code>MD5_DIGEST_SIZE</code>,
<code>SHA1_DIGEST_SIZE</code>, <code>SHA256_DIGEST_SIZE</code>, or
<code>SHA512_DIGEST_SIZE</code> respectively.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fpkcs1_005fverify_0028const">Function: <em>int</em> <strong>rsa_pkcs1_verify(const</strong> <em>struct rsa_public_key *<var>key</var>, size_t <var>length</var>, const uint8_t *<var>digest_info</var>, const mpz_t <var>signature</var>)</em></dt>
<dd><p>Similar to the above _verify_digest functions, but the input is not the
plain hash digest, but a PKCS#1 &ldquo;DigestInfo&rdquo;, and ASN.1 DER-encoding
of the digest together with an object identifier for the used hash
algorithm.
</p></dd></dl>

<p>While the above functions for the RSA signature operations use the
<cite>PKCS#1</cite> padding scheme, Nettle also provides the variants based on
the PSS padding scheme, specified in <cite>RFC 3447</cite>.  These variants
take advantage of a randomly choosen salt value, which could enhance the
security by causing output to be different for equivalent inputs.
However, assuming the same security level as inverting the <acronym>RSA</acronym>
algorithm, a longer salt value does not always mean a better security
<a href="https://www.iacr.org/archive/eurocrypt2002/23320268/coron.pdf">https://www.iacr.org/archive/eurocrypt2002/23320268/coron.pdf</a>.
The typical choices of the length are between 0 and the digest size of
the underlying hash function.
</p>
<p>Creating an RSA signature with the PSS padding scheme is done with one
of the following functions:
</p>
<dl>
<dt id="index-rsa_005fpss_005fsha256_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_pss_sha256_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fpss_005fsha384_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_pss_sha384_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fpss_005fsha512_005fsign_005fdigest_005ftr_0028const">Function: <em>int</em> <strong>rsa_pss_sha512_sign_digest_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>salt_length</var>, const uint8_t *<var>salt</var>, const uint8_t *<var>digest</var>, mpz_t <var>signature</var>)</em></dt>
<dd><p>Creates a signature using the PSS padding scheme. <var>salt</var> should
point to a salt string of size <var>salt_length</var>. <var>digest</var> should
point to a digest of size <code>SHA256_DIGEST_SIZE</code>,
<code>SHA384_DIGEST_SIZE</code>, or <code>SHA512_DIGEST_SIZE</code>respectively. The
signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>:ed earlier).
Returns one on success, or zero on failure.
</p></dd></dl>

<p>Verifying an RSA signature with the PSS padding scheme is done with one
of the following functions:
</p>
<dl>
<dt id="index-rsa_005fpss_005fsha256_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_pss_sha256_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, size_t <var>salt_length</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fpss_005fsha384_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_pss_sha384_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, size_t <var>salt_length</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dt id="index-rsa_005fpss_005fsha512_005fverify_005fdigest">Function: <em>int</em> <strong>rsa_pss_sha512_verify_digest</strong> <em>(const struct rsa_public_key *<var>key</var>, size_t <var>salt_length</var>, const uint8_t *<var>digest</var>, const mpz_t <var>signature</var>)</em></dt>
<dd><p>Returns 1 if the signature is valid, or 0 if it isn&rsquo;t. <var>digest</var>
should point to a digest of size <code>SHA256_DIGEST_SIZE</code>,
<code>SHA384_DIGEST_SIZE</code>, or <code>SHA512_DIGEST_SIZE</code> respectively.
</p></dd></dl>

<p>The following function is used to encrypt a clear text message using RSA.
</p><dl>
<dt id="index-rsa_005fencrypt">Function: <em>int</em> <strong>rsa_encrypt</strong> <em>(const struct rsa_public_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>length</var>, const uint8_t *<var>cleartext</var>, mpz_t <var>ciphertext</var>)</em></dt>
<dd><p>Returns 1 on success, 0 on failure. If the message is too long then this
will lead to a failure.
</p></dd></dl>
<p>The following function is used to decrypt a cipher text message using RSA.
</p><dl>
<dt id="index-rsa_005fdecrypt">Function: <em>int</em> <strong>rsa_decrypt</strong> <em>(const struct rsa_private_key *<var>key</var>, size_t *<var>length</var>, uint8_t *<var>cleartext</var>, const mpz_t <var>ciphertext</var>)</em></dt>
<dd><p>Returns 1 on success, 0 on failure. Causes of failure include decryption
failing or the resulting message being to large. The message buffer
pointed to by <var>cleartext</var> must be of size *<var>length</var>. After
decryption, *<var>length</var> will be updated with the size of the
message.
</p></dd></dl>
<p>There is also a timing resistant version of decryption that utilizes
randomized RSA blinding.
</p><dl>
<dt id="index-rsa_005fdecrypt_005ftr">Function: <em>int</em> <strong>rsa_decrypt_tr</strong> <em>(const struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t *<var>length</var>, uint8_t *<var>message</var>, const mpz_t <var>ciphertext</var>)</em></dt>
<dd><p>Returns 1 on success, 0 on failure.
</p></dd></dl>

<p>If you need to use the <acronym>RSA</acronym> trapdoor, the private key, in a way
that isn&rsquo;t supported by the above functions Nettle also includes a
function that computes <code>x^d mod n</code> and nothing more, using the
<acronym>CRT</acronym> optimization.
</p>
<dl>
<dt id="index-rsa_005fcompute_005froot_005ftr_0028const">Function: <em>int</em> <strong>rsa_compute_root_tr(const</strong> <em>struct rsa_public_key *<var>pub</var>, const struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, mpz_t <var>x</var>, const mpz_t <var>m</var>)</em></dt>
<dd><p>Computes <code>x = m^d</code>. Returns one on success, or zero if a failure in
the computation was detected.
</p></dd></dl>

<dl>
<dt id="index-rsa_005fcompute_005froot">Function: <em>void</em> <strong>rsa_compute_root</strong> <em>(struct rsa_private_key *<var>key</var>, mpz_t <var>x</var>, const mpz_t <var>m</var>)</em></dt>
<dd><p>Computes <code>x = m^d</code>.
</p></dd></dl>

<p>At last, how do you create new keys?
</p>
<dl>
<dt id="index-rsa_005fgenerate_005fkeypair">Function: <em>int</em> <strong>rsa_generate_keypair</strong> <em>(struct rsa_public_key *<var>pub</var>, struct rsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, void *<var>progress_ctx</var>, nettle_progress_func <var>progress</var>, unsigned <var>n_size</var>, unsigned <var>e_size</var>);</em></dt>
<dd><p>There are lots of parameters. <var>pub</var> and <var>key</var> is where the
resulting key pair is stored. The structs should be initialized, but you
don&rsquo;t need to call <code>rsa_public_key_prepare</code> or
<code>rsa_private_key_prepare</code> after key generation.
</p>
<p><var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.
</p>
<p><var>progress</var> and <var>progress_ctx</var> can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress. <var>progress</var> can be NULL, in that case there are no
callbacks.
</p>
<p><var>size_n</var> is the desired size of the modulo, in bits. If <var>size_e</var>
is non-zero, it is the desired size of the public exponent and a random
exponent of that size is selected. But if <var>e_size</var> is zero, it is
assumed that the caller has already chosen a value for <code>e</code>, and
stored it in <var>pub</var>.
Returns one on success, and zero on failure. The function can fail for
example if if <var>n_size</var> is too small, or if <var>e_size</var> is zero and
<code>pub-&gt;e</code> is an even number.
</p></dd></dl>

<hr>
<span id="DSA"></span><div class="header">
<p>
Next: <a href="#Elliptic-curves" accesskey="n" rel="next">Elliptic curves</a>, Previous: <a href="#RSA" accesskey="p" rel="prev">RSA</a>, Up: <a href="#Public_002dkey-algorithms" accesskey="u" rel="up">Public-key algorithms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DSA-1"></span><h4 class="subsection">7.7.2 <acronym>DSA</acronym></h4>

<p>The <acronym>DSA</acronym> digital signature algorithm is more complex than
<acronym>RSA</acronym>. It was specified during the early 1990s, and in 1994 NIST
published <acronym>FIPS</acronym> 186 which is the authoritative specification.
Sometimes <acronym>DSA</acronym> is referred to using the acronym <acronym>DSS</acronym>,
for Digital Signature Standard. The most recent revision of the
specification, FIPS186-3, was issued in 2009, and it adds support for
larger hash functions than <acronym>sha1</acronym>.
</p>
<p>For <acronym>DSA</acronym>, the underlying mathematical problem is the
computation of discrete logarithms. The public key consists of a large
prime <code>p</code>, a small prime <code>q</code> which is a factor of <code>p-1</code>,
a number <code>g</code> which generates a subgroup of order <code>q</code> modulo
<code>p</code>, and an element <code>y</code> in that subgroup.
</p>
<p>In the original <acronym>DSA</acronym>, the size of <code>q</code> is fixed to 160
bits, to match with the <acronym>SHA1</acronym> hash algorithm. The size of
<code>p</code> is in principle unlimited, but the
standard specifies only nine specific sizes: <code>512 + l*64</code>, where
<code>l</code> is between 0 and 8. Thus, the maximum size of <code>p</code> is 1024
bits, and sizes less than 1024 bits are considered obsolete and not
secure.
</p>
<p>The subgroup requirement means that if you compute 
</p>
<div class="example">
<pre class="example">g^t mod p
</pre></div>

<p>for all possible integers <code>t</code>, you will get precisely <code>q</code>
distinct values.
</p>
<p>The private key is a secret exponent <code>x</code>, such that
</p>
<div class="example">
<pre class="example">g^x = y mod p
</pre></div>

<p>In mathematical speak, <code>x</code> is the <em>discrete logarithm</em> of
<code>y</code> mod <code>p</code>, with respect to the generator <code>g</code>. The size
of <code>x</code> will also be about the same size as <code>q</code>. The security of the
<acronym>DSA</acronym> algorithm relies on the difficulty of the discrete
logarithm problem. Current algorithms to compute discrete logarithms in
this setting, and hence crack <acronym>DSA</acronym>, are of two types. The first
type works directly in the (multiplicative) group of integers mod
<code>p</code>. The best known algorithm of this type is the Number Field
Sieve, and it&rsquo;s complexity is similar to the complexity of factoring
numbers of the same size as <code>p</code>. The other type works in the
smaller <code>q</code>-sized subgroup generated by <code>g</code>, which has a more
difficult group structure. One good algorithm is Pollard-rho, which has
complexity <code>sqrt(q)</code>.
</p>
<p>The important point is that security depends on the size of <em>both</em>
<code>p</code> and <code>q</code>, and they should be chosen so that the difficulty
of both discrete logarithm methods are comparable. Today, the security
margin of the original <acronym>DSA</acronym> may be uncomfortably small. Using a
<code>p</code> of 1024 bits implies that cracking using the number field sieve
is expected to take about the same time as factoring a 1024-bit
<acronym>RSA</acronym> modulo, and using a <code>q</code> of size 160 bits implies
that cracking using Pollard-rho will take roughly <code>2^80</code> group
operations. With the size of <code>q</code> fixed, tied to the <acronym>SHA1</acronym>
digest size, it may be tempting to increase the size of <code>p</code> to,
say, 4096 bits. This will provide excellent resistance against attacks
like the number field sieve which works in the large group. But it will
do very little to defend against Pollard-rho attacking the small
subgroup; the attacker is slowed down at most by a single factor of 10
due to the more expensive group operation. And the attacker will surely
choose the latter attack.
</p>
<p>The signature generation algorithm is randomized; in order to create a
<acronym>DSA</acronym> signature, you need a good source for random numbers
(see <a href="#Randomness">Randomness</a>). Let us describe the common case of a 160-bit
<code>q</code>.
</p>
<p>To create a signature, one starts with the hash digest of the message,
<code>h</code>, which is a 160 bit number, and a random number <code>k,
0&lt;k&lt;q</code>, also 160 bits. Next, one computes 
</p>
<div class="example">
<pre class="example">r = (g^k mod p) mod q
s = k^-1 (h + x r) mod q
</pre></div>

<p>The signature is the pair <code>(r, s)</code>, two 160 bit numbers. Note the
two different mod operations when computing <code>r</code>, and the use of the
secret exponent <code>x</code>.
</p>
<p>To verify a signature, one first checks that <code>0 &lt; r,s &lt; q</code>, and
then one computes backwards,
</p>
<div class="example">
<pre class="example">w = s^-1 mod q
v = (g^(w h) y^(w r) mod p) mod q
</pre></div>

<p>The signature is valid if <code>v = r</code>. This works out because <code>w =
s^-1 mod q = k (h + x r)^-1 mod q</code>, so that
</p>
<div class="example">
<pre class="example">g^(w h) y^(w r) = g^(w h) (g^x)^(w r) = g^(w (h + x r)) = g^k 
</pre></div>

<p>When reducing mod <code>q</code> this yields <code>r</code>. Note that when
verifying a signature, we don&rsquo;t know either <code>k</code> or <code>x</code>: those
numbers are secret.
</p>
<p>If you can choose between <acronym>RSA</acronym> and <acronym>DSA</acronym>, which one is
best? Both are believed to be secure. <acronym>DSA</acronym> gained popularity in
the late 1990s, as a patent free alternative to <acronym>RSA</acronym>. Now that
the <acronym>RSA</acronym> patents have expired, there&rsquo;s no compelling reason to
want to use <acronym>DSA</acronym>. Today, the original <acronym>DSA</acronym> key size
does not provide a large security margin, and it should probably be
phased out together with <acronym>RSA</acronym> keys of 1024 bits. Using the
revised <acronym>DSA</acronym> algorithm with a larger hash function, in
particular, <acronym>SHA256</acronym>, a 256-bit <code>q</code>, and <code>p</code> of size
2048 bits or more, should provide for a more comfortable security
margin, but these variants are not yet in wide use.
</p>
<p><acronym>DSA</acronym> signatures are smaller than <acronym>RSA</acronym> signatures,
which is important for some specialized applications.
</p>
<p>From a practical point of view, <acronym>DSA</acronym>&rsquo;s need for a good
randomness source is a serious disadvantage. If you ever use the same
<code>k</code> (and <code>r</code>) for two different message, you leak your private
key.
</p>
<span id="Nettle_0027s-DSA-support"></span><h4 class="subsubsection">7.7.2.1 Nettle&rsquo;s <acronym>DSA</acronym> support</h4>

<p>Like for <acronym>RSA</acronym>, Nettle represents <acronym>DSA</acronym> keys using two
structures, containing values of type <code>mpz_t</code>. For information on
how to customize allocation, see See <a href="https://www.gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GMP
Allocation</a> in <cite>GMP Manual</cite>. Nettle&rsquo;s <acronym>DSA</acronym> interface is defined
in <samp>&lt;nettle/dsa.h&gt;</samp>.
</p>
<p>A <acronym>DSA</acronym> group is represented using the following struct.
</p>
<dl>
<dt id="index-dsa_005fparams">Context struct: <strong>dsa_params</strong> <em>p q g</em></dt>
<dd><p>Parameters of the <acronym>DSA</acronym> group.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fparams_005finit">Function: <em>void</em> <strong>dsa_params_init</strong> <em>(struct dsa_params *<var>params</var>)</em></dt>
<dd><p>Calls <code>mpz_init</code> on all numbers in the struct.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fparams_005fclear">Function: <em>void</em> <strong>dsa_params_clear</strong> <em>(struct dsa_params *<var>params</var>params)</em></dt>
<dd><p>Calls <code>mpz_clear</code> on all numbers in the struct.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fgenerate_005fparams">Function: <em>int</em> <strong>dsa_generate_params</strong> <em>(struct dsa_params *<var>params</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, void *<var>progress_ctx</var>, nettle_progress_func *<var>progress</var>, unsigned <var>p_bits</var>, unsigned <var>q_bits</var>)</em></dt>
<dd><p>Generates parameters of a new group. The <var>params</var> struct should be
initialized before you call this function.
</p>
<p><var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.
</p>
<p><var>progress</var> and <var>progress_ctx</var> can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress. <var>progress</var> can be NULL, in that case there are no
callbacks.
</p>
<p><var>p_bits</var> and <var>q_bits</var> are the desired sizes of <code>p</code> and
<code>q</code>. To generate keys that conform to the original <acronym>DSA</acronym>
standard, you must use <code>q_bits = 160</code> and select <var>p_bits</var> of
the form <code>p_bits = 512 + l*64</code>, for <code>0 &lt;= l &lt;= 8</code>, where the
smaller sizes are no longer recommended, so you should most likely stick
to <code>p_bits = 1024</code>. Non-standard sizes are possible, in particular
<code>p_bits</code> larger than 1024, although <acronym>DSA</acronym> implementations
can not in general be expected to support such keys. Also note that
using very large <var>p_bits</var>, with <var>q_bits</var> fixed at 160, doesn&rsquo;t
make much sense, because the security is also limited by the size of the
smaller prime. To generate <acronym>DSA</acronym> keys for use with
<acronym>SHA256</acronym>, use <code>q_bits = 256</code> and, e.g., <code>p_bits =
2048</code>.
</p>
<p>Returns one on success, and zero on failure. The function will fail if
<var>q_bits</var> is too small, or too close to <var>p_bits</var>.
</p></dd></dl>

<p>Signatures are represented using the structure below.
</p>
<dl>
<dt id="index-dsa_005fsignature">Context struct: <strong>dsa_signature</strong> <em>r s</em></dt>
<dd><p>The <var>r</var> and <var>s</var> fields are both of type <code>mpz_t</code>.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fsignature_005finit">Function: <em>void</em> <strong>dsa_signature_init</strong> <em>(struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsignature_005fclear">Function: <em>void</em> <strong>dsa_signature_clear</strong> <em>(struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>You must call <code>dsa_signature_init</code> before creating or using a
signature, and call <code>dsa_signature_clear</code> when you are finished
with it.
</p></dd></dl>

<p>Keys are represented as bignums, of type <code>mpz_t</code>. A public key
represents a group element, and is of the same size as <code>p</code>, while a
private key is an exponent, of the same size as <code>q</code>.
</p>
<dl>
<dt id="index-dsa_005fsign">Function: <em>int</em> <strong>dsa_sign</strong> <em>(const struct dsa_params *<var>params</var>, const mpz_t <var>x</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>digest_size</var>, const uint8_t *<var>digest</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Creates a signature from the given hash digest, using the private key
<var>x</var>. <var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>. Returns one on success, or zero on failure. Signing
can fail only if the key is invalid, so that inversion modulo <code>q</code>
fails.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fverify">Function: <em>int</em> <strong>dsa_verify</strong> <em>(const struct dsa_params *<var>params</var>, const mpz_t <var>y</var>, size_t <var>digest_size</var>, const uint8_t *<var>digest</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Verifies a signature, using the public key y. Returns 1 if the signature
is valid, otherwise 0.
</p></dd></dl>

<p>To generate a keypair, first generate a <acronym>DSA</acronym> group using
<code>dsa_generate_params</code>. A keypair in this group is then created
using
</p>
<dl>
<dt id="index-dsa_005fgenerate_005fkeypair">Function: <em>void</em> <strong>dsa_generate_keypair</strong> <em>(const struct dsa_params *<var>params</var>, mpz_t <var>pub</var>, mpz_t <var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>)</em></dt>
<dd><p>Generates a new keypair, using the group <var>params</var>. The public key is
stored in <var>pub</var>, and the private key in <var>key</var>. Both variables
must be initialized using <code>mpz_init</code> before this call.
</p>
<p><var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.
</p></dd></dl>

<span id="Old_002c-deprecated_002c-DSA-interface"></span><h4 class="subsubsection">7.7.2.2 Old, deprecated, <acronym>DSA</acronym> interface</h4>

<p>Versions before nettle-3.0 used a different interface for <acronym>DSA</acronym>
signatures, where the group parameters and the public key was packed
together as <code>struct dsa_public_key</code>. Most of this interface is kept
for backwards compatibility, and declared in <samp>nettle/dsa-compat.h</samp>.
Below is the old documentation. The old and new interface use distinct
names and don&rsquo;t confict, with one exception: The key generation
function. The <samp>nettle/dsa-compat.h</samp> redefines
<code>dsa_generate_keypair</code> as an alias for
<code>dsa_compat_generate_keypair</code>, compatible with the old interface
and documented below.
</p>
<p>The old <acronym>DSA</acronym> functions are very similar to the corresponding
<acronym>RSA</acronym> functions, but there are a few differences pointed out
below. For a start, there are no functions corresponding to
<code>rsa_public_key_prepare</code> and <code>rsa_private_key_prepare</code>.
</p>
<dl>
<dt id="index-dsa_005fpublic_005fkey">Context struct: <strong>dsa_public_key</strong> <em>p q g y</em></dt>
<dd><p>The public parameters described above.
</p></dd></dl>

<dl>
<dt id="index-dsa_005fprivate_005fkey">Context struct: <strong>dsa_private_key</strong> <em>x</em></dt>
<dd><p>The private key <code>x</code>.
</p></dd></dl>

<p>Before use, these structs must be initialized by calling one of
</p>
<dl>
<dt id="index-dsa_005fpublic_005fkey_005finit">Function: <em>void</em> <strong>dsa_public_key_init</strong> <em>(struct dsa_public_key *<var>pub</var>)</em></dt>
<dt id="index-dsa_005fprivate_005fkey_005finit">Function: <em>void</em> <strong>dsa_private_key_init</strong> <em>(struct dsa_private_key *<var>key</var>)</em></dt>
<dd><p>Calls <code>mpz_init</code> on all numbers in the key struct.
</p></dd></dl>

<p>When finished with them, the space for the numbers must be
deallocated by calling one of
</p>
<dl>
<dt id="index-dsa_005fpublic_005fkey_005fclear">Function: <em>void</em> <strong>dsa_public_key_clear</strong> <em>(struct dsa_public_key *<var>pub</var>)</em></dt>
<dt id="index-dsa_005fprivate_005fkey_005fclear">Function: <em>void</em> <strong>dsa_private_key_clear</strong> <em>(struct dsa_private_key *<var>key</var>)</em></dt>
<dd><p>Calls <code>mpz_clear</code> on all numbers in the key struct.
</p></dd></dl>

<p>Signatures are represented using <code>struct dsa_signature</code>, described
earlier.
</p>
<p>For signing, you need to provide both the public and the private key
(unlike <acronym>RSA</acronym>, where the private key struct includes all
information needed for signing), and a source for random numbers.
Signatures can use the <acronym>SHA1</acronym> or the <acronym>SHA256</acronym> hash
function, although the implementation of <acronym>DSA</acronym> with
<acronym>SHA256</acronym> should be considered somewhat experimental due to lack
of official test vectors and interoperability testing.
</p>
<dl>
<dt id="index-dsa_005fsha1_005fsign">Function: <em>int</em> <strong>dsa_sha1_sign</strong> <em>(const struct dsa_public_key *<var>pub</var>, const struct dsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, struct sha1_ctx *<var>hash</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha1_005fsign_005fdigest">Function: <em>int</em> <strong>dsa_sha1_sign_digest</strong> <em>(const struct dsa_public_key *<var>pub</var>, const struct dsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, const uint8_t *<var>digest</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha256_005fsign">Function: <em>int</em> <strong>dsa_sha256_sign</strong> <em>(const struct dsa_public_key *<var>pub</var>, const struct dsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, struct sha256_ctx *<var>hash</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha256_005fsign_005fdigest">Function: <em>int</em> <strong>dsa_sha256_sign_digest</strong> <em>(const struct dsa_public_key *<var>pub</var>, const struct dsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, const uint8_t *<var>digest</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Creates a signature from the given hash context or digest.
<var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>. Returns one on success, or zero on failure.
Signing fails if the key size and the hash size don&rsquo;t match.
</p></dd></dl>

<p>Verifying signatures is a little easier, since no randomness generator is
needed. The functions are
</p>
<dl>
<dt id="index-dsa_005fsha1_005fverify">Function: <em>int</em> <strong>dsa_sha1_verify</strong> <em>(const struct dsa_public_key *<var>key</var>, struct sha1_ctx *<var>hash</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha1_005fverify_005fdigest">Function: <em>int</em> <strong>dsa_sha1_verify_digest</strong> <em>(const struct dsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha256_005fverify">Function: <em>int</em> <strong>dsa_sha256_verify</strong> <em>(const struct dsa_public_key *<var>key</var>, struct sha256_ctx *<var>hash</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dt id="index-dsa_005fsha256_005fverify_005fdigest">Function: <em>int</em> <strong>dsa_sha256_verify_digest</strong> <em>(const struct dsa_public_key *<var>key</var>, const uint8_t *<var>digest</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Verifies a signature. Returns 1 if the signature is valid, otherwise 0.
</p></dd></dl>

<p>Key generation uses mostly the same parameters as the corresponding
<acronym>RSA</acronym> function.
</p>
<dl>
<dt id="index-dsa_005fcompat_005fgenerate_005fkeypair">Function: <em>int</em> <strong>dsa_compat_generate_keypair</strong> <em>(struct dsa_public_key *<var>pub</var>, struct dsa_private_key *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func <var>random</var>, void *<var>progress_ctx</var>, nettle_progress_func <var>progress</var>, unsigned <var>p_bits</var>, unsigned <var>q_bits</var>)</em></dt>
<dd><p><var>pub</var> and <var>key</var> is where the resulting key pair is stored. The
structs should be initialized before you call this function. 
</p>
<p><var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.
</p>
<p><var>progress</var> and <var>progress_ctx</var> can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress. <var>progress</var> can be NULL, in that case there are no
callbacks.
</p>
<p><var>p_bits</var> and <var>q_bits</var> are the desired sizes of <code>p</code> and
<code>q</code>. See <code>dsa_generate_keypair</code> for details.
</p></dd></dl>

<hr>
<span id="Elliptic-curves"></span><div class="header">
<p>
Previous: <a href="#DSA" accesskey="p" rel="prev">DSA</a>, Up: <a href="#Public_002dkey-algorithms" accesskey="u" rel="up">Public-key algorithms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Elliptic-curves-1"></span><h4 class="subsection">7.7.3 Elliptic curves</h4>

<p>For cryptographic purposes, an elliptic curve is a mathematical group of
points, and computing logarithms in this group is computationally
difficult problem. Nettle uses additive notation for elliptic curve
groups. If <em>P</em> and <em>Q</em> are two points, and <em>k</em> is an
integer, the point sum, <em>P + Q</em>, and the multiple <em>k P</em> can be
computed efficiently, but given only two points <em>P</em> and <em>Q</em>,
finding an integer <em>k</em> such that <em>Q = k P</em> is the elliptic
curve discrete logarithm problem.
</p>
<p>Nettle supports standard curves which are all of the form <em>y^2 =
x^3 - 3 x + b (mod p)</em>, i.e., the points have coordinates <em>(x,y)</em>,
both considered as integers modulo a specified prime <em>p</em>. Curves
are represented as a <code>struct ecc_curve</code>. It also supports
curve25519, which uses a different form of curve. Supported curves are
declared in <samp>&lt;nettle/ecc-curve.h&gt;</samp>, e.g., call
<code>nettle_get_secp_256r1</code> for a standardized curve using the 256-bit
prime <em>p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1</em>. The contents
of these structs is not visible to nettle users. The &ldquo;bitsize of the
curve&rdquo; is used as a shorthand for the bitsize of the curve&rsquo;s prime
<em>p</em>, e.g., 256 bits for the SECP 256R1 curve.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Side_002dchannel-silence" accesskey="1">Side-channel silence</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ECDSA" accesskey="2">ECDSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GOSTDSA" accesskey="3">GOSTDSA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Curve-25519-and-Curve-448" accesskey="4">Curve 25519 and Curve 448</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Side_002dchannel-silence"></span><div class="header">
<p>
Next: <a href="#ECDSA" accesskey="n" rel="next">ECDSA</a>, Up: <a href="#Elliptic-curves" accesskey="u" rel="up">Elliptic curves</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Side_002dchannel-silence-1"></span><h4 class="subsubsection">7.7.3.1 Side-channel silence</h4>
<span id="index-Side_002dchannel-attack"></span>

<p>Nettle&rsquo;s implementation of the elliptic curve operations is intended to
be side-channel silent. The side-channel attacks considered are:
</p>
<ul>
<li> Timing attacks
If the timing of operations depends on secret values, an attacker
interacting with your system can measure the response time, and infer
information about your secrets, e.g., a private signature key.

</li><li> Attacks using memory caches
Assume you have some secret data on a multi-user system, and that this
data is properly protected so that other users get no direct access to
it. If you have a process operating on the secret data, and this process
does memory accesses depending on the data, e.g, an internal lookup
table in some cryptographic algorithm, an attacker running a separate
process on the same system may use behavior of internal CPU caches to
get information about your secrets. This type of attack can even cross
virtual machine boundaries.
</li></ul>

<p>Nettle&rsquo;s ECC implementation is designed to be <em>side-channel silent</em>,
and not leak any information to these attacks. Timing and memory
accesses depend only on the size of the input data and its location in
memory, not on the actual data bits. This implies a performance penalty
in several of the building blocks.
</p>
<hr>
<span id="ECDSA"></span><div class="header">
<p>
Next: <a href="#GOSTDSA" accesskey="n" rel="next">GOSTDSA</a>, Previous: <a href="#Side_002dchannel-silence" accesskey="p" rel="prev">Side-channel silence</a>, Up: <a href="#Elliptic-curves" accesskey="u" rel="up">Elliptic curves</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="ECDSA-1"></span><h4 class="subsubsection">7.7.3.2 ECDSA</h4>

<p>ECDSA is a variant of the DSA digital signature scheme (see <a href="#DSA">DSA</a>),
which works over an elliptic curve group rather than over a (subgroup
of) integers modulo <em>p</em>. Like DSA, creating a signature requires a unique
random nonce (repeating the nonce with two different messages reveals
the private key, and any leak or bias in the generation of the nonce
also leaks information about the key).
</p>
<p>Unlike DSA, signatures are in general not tied to any particular hash
function or even hash size. Any hash function can be used, and the hash
value is truncated or padded as needed to get a size matching the curve
being used. It is recommended to use a strong cryptographic hash
function with digest size close to the bit size of the curve, e.g.,
SHA256 is a reasonable choice when using ECDSA signature over the curve
secp256r1. A protocol or application using ECDSA has to specify which
curve and which hash function to use, or provide some mechanism for
negotiating.
</p>
<p>Nettle defines ECDSA in <samp>&lt;nettle/ecdsa.h&gt;</samp>. We first need
to define the data types used to represent public and private keys.
</p>
<dl>
<dt id="index-struct-ecc_005fpoint">struct: <strong>struct ecc_point</strong></dt>
<dd><p>Represents a point on an elliptic curve. In particular, it is used to
represent an ECDSA public key.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fpoint_005finit">Function: <em>void</em> <strong>ecc_point_init</strong> <em>(struct ecc_point *<var>p</var>, const struct ecc_curve *<var>ecc</var>)</em></dt>
<dd><p>Initializes <var>p</var> to represent points on the given curve <var>ecc</var>.
Allocates storage for the coordinates, using the same allocation
functions as GMP.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fpoint_005fclear">Function: <em>void</em> <strong>ecc_point_clear</strong> <em>(struct ecc_point *<var>p</var>)</em></dt>
<dd><p>Deallocate storage allocated by previous ecc_point_init.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fpoint_005fset">Function: <em>int</em> <strong>ecc_point_set</strong> <em>(struct ecc_point *<var>p</var>, const mpz_t <var>x</var>, const mpz_t <var>y</var>)</em></dt>
<dd><p>Check that the given coordinates represent a point on the curve. If so,
the coordinates are copied and converted to internal representation, and
the function returns 1. Otherwise, it returns 0. Currently, the
infinity point (or zero point, with additive notation) is not allowed.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fpoint_005fget">Function: <em>void</em> <strong>ecc_point_get</strong> <em>(const struct ecc_point *<var>p</var>, mpz_t <var>x</var>, mpz_t <var>y</var>)</em></dt>
<dd><p>Extracts the coordinate of the point <var>p</var>. The output parameters
<var>x</var> or <var>y</var> may be NULL if the caller doesn&rsquo;t want that
coordinate.
</p></dd></dl>

<dl>
<dt id="index-struct-ecc_005fscalar">struct: <strong>struct ecc_scalar</strong></dt>
<dd><p>Represents an integer in the range <em>0 &lt; x &lt; group order</em>, where the
&ldquo;group order&rdquo; refers to the order of an ECC group. In particular, it
is used to represent an ECDSA private key.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fscalar_005finit">Function: <em>void</em> <strong>ecc_scalar_init</strong> <em>(struct ecc_scalar *<var>s</var>, const struct ecc_curve *<var>ecc</var>)</em></dt>
<dd><p>Initializes <var>s</var> to represent a scalar suitable for the given curve
<var>ecc</var>. Allocates storage using the same allocation functions as GMP.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fscalar_005fclear">Function: <em>void</em> <strong>ecc_scalar_clear</strong> <em>(struct ecc_scalar *<var>s</var>)</em></dt>
<dd><p>Deallocate the storage allocated by previous ecc_scalar_init.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fscalar_005fset">Function: <em>int</em> <strong>ecc_scalar_set</strong> <em>(struct ecc_scalar *<var>s</var>, const mpz_t <var>z</var>)</em></dt>
<dd><p>Check that <var>z</var> is in the correct range. If so, copies the value to
<var>s</var> and returns 1, otherwise returns 0.
</p></dd></dl>

<dl>
<dt id="index-ecc_005fscalar_005fget">Function: <em>void</em> <strong>ecc_scalar_get</strong> <em>(const struct ecc_scalar *<var>s</var>, mpz_t <var>z</var>)</em></dt>
<dd><p>Extracts the scalar, in GMP <code>mpz_t</code> representation.
</p></dd></dl>

<p>To create and verify ECDSA signatures, the following functions are used.
</p>
<dl>
<dt id="index-ecdsa_005fsign">Function: <em>void</em> <strong>ecdsa_sign</strong> <em>(const struct ecc_scalar *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>digest_length</var>, const uint8_t *<var>digest</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Uses the private key <var>key</var> to create a signature of <var>digest</var>.
<var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. The signature is stored in
<var>signature</var>, in the same way as for plain DSA.
</p></dd></dl>

<dl>
<dt id="index-ecdsa_005fverify">Function: <em>int</em> <strong>ecdsa_verify</strong> <em>(const struct ecc_point *<var>pub</var>, size_t <var>length</var>, const uint8_t *<var>digest</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Uses the public key <var>pub</var> to verify that <var>signature</var> is a valid
signature for the message digest <var>digest</var> (of <var>length</var> octets).
Returns 1 if the signature is valid, otherwise 0.
</p></dd></dl>

<p>Finally, generating a new ECDSA key pair:
</p>
<dl>
<dt id="index-ecdsa_005fgenerate_005fkeypair">Function: <em>void</em> <strong>ecdsa_generate_keypair</strong> <em>(struct ecc_point *<var>pub</var>, struct ecc_scalar *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>);</em></dt>
<dd><p><var>pub</var> and <var>key</var> is where the resulting key pair is stored. The
structs should be initialized, for the desired ECC curve, before you call this function.
</p>
<p><var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.
</p></dd></dl>

<hr>
<span id="GOSTDSA"></span><div class="header">
<p>
Next: <a href="#Curve-25519-and-Curve-448" accesskey="n" rel="next">Curve 25519 and Curve 448</a>, Previous: <a href="#ECDSA" accesskey="p" rel="prev">ECDSA</a>, Up: <a href="#Elliptic-curves" accesskey="u" rel="up">Elliptic curves</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="GOSTDSA-1"></span><h4 class="subsubsection">7.7.3.3 GOSTDSA</h4>
<span id="index-GOST-DSA"></span>

<p>GOSTDSA (GOST R 34.10-2001, GOST R 34.10-2012) is a variant of the DSA
(see <a href="#DSA">DSA</a>) and ECDSA (see <a href="#ECDSA">ECDSA</a>) digital signature schemes, which works
over an elliptic curve group. Original documents are written in Russian.
English translations are provided in <cite>RFC 5832</cite> and <cite>RFC 7091</cite>.
While technically nothing stops one from using GOSTDSA over any curve, it
is defined only over several 256 and 512-bit curves.  Like DSA and ECDSA,
creating a signature requires a unique random nonce (repeating the nonce
with two different messages reveals the private key, and any leak or bias
in the generation of the nonce also leaks information about the key).
</p>
<p>GOST R 34.10-2001 was defined to use GOST R 34.11-94 hash function
(GOSTHASH94 and GOSTHASH94CP, <cite>RFC 5831</cite>).  GOST R 34.10-2012 is
defined to use GOST R 34.11-2012 hash function (Streebog, <cite>RFC
6986</cite>) of corresponding size (256 or 512) depending on curve size.
</p>
<p>Nettle defines GOSTDSA in <samp>&lt;nettle/gostdsa.h&gt;</samp>. GOSTDSA reuses ECDSA
data types (<code>struct ecc_point</code>, <code>struct ecc_scalar</code>) to
represent public and private keys.  Also to generate a new GOSTDSA key
pair one has to use <code>ecdsa_generate_keypair()</code> function.
</p>
<p>To create and verify GOSTDSA signatures, the following functions are used.
</p>
<dl>
<dt id="index-gostdsa_005fsign">Function: <em>void</em> <strong>gostdsa_sign</strong> <em>(const struct ecc_scalar *<var>key</var>, void *<var>random_ctx</var>, nettle_random_func *<var>random</var>, size_t <var>digest_length</var>, const uint8_t *<var>digest</var>, struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Uses the private key <var>key</var> to create a signature of <var>digest</var>.
<var>random_ctx</var> and <var>random</var> is a randomness generator.
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. The signature is stored in
<var>signature</var>, in the same was as for plain DSA.
</p></dd></dl>

<dl>
<dt id="index-gostdsa_005fverify">Function: <em>int</em> <strong>gostdsa_verify</strong> <em>(const struct ecc_point *<var>pub</var>, size_t <var>length</var>, const uint8_t *<var>digest</var>, const struct dsa_signature *<var>signature</var>)</em></dt>
<dd><p>Uses the public key <var>pub</var> to verify that <var>signature</var> is a valid
signature for the message digest <var>digest</var> (of <var>length</var> octets).
Returns 1 if the signature is valid, otherwise 0.
</p></dd></dl>

<p>For historical reason several curve IDs (OIDs) may correspond to a single
curve/generator combination. Following list defines correspondence
between nettle&rsquo;s view on curves and actual identifiers defined in <cite>RFC
4357</cite> and <cite>RFC 7836</cite>.
</p>
<dl>
<dt id="index-nettle_005fget_005fgost_005fgc256b_0028void_0029">Function: <em>const struct ecc_curve</em> <strong>nettle_get_gost_gc256b(void)</strong></dt>
<dd><p>Returns curve corresponding to following identifiers:
</p><ul>
<li> id-GostR3410-2001-CryptoPro-A-ParamSet (<cite>RFC 4357</cite>)
</li><li> id-GostR3410-2001-CryptoPro-XchA-ParamSet (<cite>RFC 4357</cite>)
</li><li> id-tc26-gost-3410-12-256-paramSetB
</li></ul>
</dd></dl>

<dl>
<dt id="index-nettle_005fget_005fgost_005fgc512a_0028void_0029">Function: <em>const struct ecc_curve</em> <strong>nettle_get_gost_gc512a(void)</strong></dt>
<dd><p>Returns curve corresponding to following identifiers:
</p><ul>
<li> id-tc26-gost-3410-12-512-paramSetA (<cite>RFC 7836</cite>)
</li></ul>
</dd></dl>

<p>For GOST key pairs key derivation/key agreement function (VKO) is defined in
<cite>RFC 4357</cite> and <cite>RFC 7836</cite>.  Basically shared key is equal to
hash(cofactor * ukm * priv * pub). Nettle library provides a function that does
multiplication. Caller should do hashing on his own (it will be either
GOST R 34.11-94 (see <a href="#GOSTHASH94CP">GOSTHASH94CP</a>) or GOST R 34.11-2012, Streebog, which nor part of the library yet).
</p>
<dl>
<dt id="index-gostdsa_005fvko">Function: <em>void</em> <strong>gostdsa_vko</strong> <em>(const struct ecc_scalar *<var>priv</var>, const struct ecc_point *<var>pub</var>, size_t <var>ukm_length</var>, const uint8_t *<var>ukm</var>, uint8_t *<var>out</var>)</em></dt>
<dd><p>Uses private key <var>priv</var>, public ket <var>pub</var> and shared key material
<var>ukm</var> to generate shared secret, written to buffer <var>out</var>. The buffer
should be of the size equal to 2 private key lengths: 64 bytes for 256 bit
curves and 128 bytes for 512 bit ones. UKM is a shared key material, usually
transferred in cleartext. It does not have to be secret.
</p></dd></dl>

<hr>
<span id="Curve-25519-and-Curve-448"></span><div class="header">
<p>
Previous: <a href="#GOSTDSA" accesskey="p" rel="prev">GOSTDSA</a>, Up: <a href="#Elliptic-curves" accesskey="u" rel="up">Elliptic curves</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Curve25519-and-Curve448"></span><h4 class="subsubsection">7.7.3.4 Curve25519 and Curve448</h4>
<span id="index-Curve-25519"></span>
<span id="index-Curve-448"></span>


<p>Curve25519 is an elliptic curve of Montgomery type, <em>y^2 = x^3 +
486662 x^2 + x (mod p)</em>, with <em>p = 2^255 - 19</em>. Montgomery curves
have the advantage of simple and efficient point addition based on the
x-coordinate only. This particular curve was proposed by D. J. Bernstein
in 2006, for fast Diffie-Hellman key exchange, and is also described in
<cite>RFC 7748</cite>. The group generator is defined by <em>x = 9</em> (there
are actually two points with <em>x = 9</em>, differing by the sign of the
y-coordinate, but that doesn&rsquo;t matter for the curve25519 operations
which work with the x-coordinate only).
</p>
<p>The curve25519 functions are defined as operations on octet strings,
representing 255-bit scalars or x-coordinates, in little-endian byte
order. The most significant input bit, i.e, the most significant bit of
the last octet, is always ignored.
</p>
<p>For scalars, in addition, the least significant three bits are ignored,
and treated as zero, and the second most significant bit is ignored too,
and treated as one. Then the scalar input string always represents 8
times a number in the range <em>2^251 &lt;= s &lt; 2^252</em>.
</p>
<p>Of all the possible input strings, only about half correspond to
x-coordinates of points on curve25519, i.e., a value <em>x</em> for which
the the curve equation can be solved for <em>y</em>. The other half
correspond to points on a related &ldquo;twist curve&rdquo;. The function
<code>curve25519_mul</code> uses a Montgomery ladder for the scalar
multiplication, as suggested in the curve25519 literature, and required
by <cite>RFC 7748</cite>. The output is therefore well defined for
<em>all</em> possible inputs, no matter if the input string represents a
valid point on the curve or not.
</p>
<p>Note that the curve25519 implementation in earlier versions of Nettle
deviates slightly from <cite>RFC 7748</cite>, in that bit 255 of the <em>x</em>
coordinate of the point input to curve25519_mul was not ignored. The
<samp>nette/curve25519.h</samp> defines a preprocessor symbol
<code>NETTLE_CURVE25519_RFC7748</code> to indicate conformance with the
standard.
</p>
<p>Nettle defines Curve 25519 in <samp>&lt;nettle/curve25519.h&gt;</samp>.
</p>
<dl>
<dt id="index-NETTLE_005fCURVE25519_005fRFC7748">Constant: <strong>NETTLE_CURVE25519_RFC7748</strong></dt>
<dd><p>Defined to 1 in Nettle versions conforming to RFC 7748. Undefined in
earlier versions.
</p></dd></dl>

<dl>
<dt id="index-CURVE25519_005fSIZE">Constant: <strong>CURVE25519_SIZE</strong></dt>
<dd><p>The size of the strings representing curve25519 points and scalars, 32.
</p></dd></dl>

<dl>
<dt id="index-curve25519_005fmul_005fg">Function: <em>void</em> <strong>curve25519_mul_g</strong> <em>(uint8_t *<var>q</var>, const uint8_t *<var>n</var>)</em></dt>
<dd><p>Computes <em>Q = N G</em>, where <em>G</em> is the group generator and
<em>N</em> is an integer. The input argument <var>n</var> and the output
argument <var>q</var> use a little-endian representation of the scalar and
the x-coordinate, respectively. They are both of size
<code>CURVE25519_SIZE</code>.
</p>
<p>This function is intended to be compatible with the function
<code>crypto_scalar_mult_base</code> in the NaCl library.
</p></dd></dl>

<dl>
<dt id="index-curve25519_005fmul">Function: <em>void</em> <strong>curve25519_mul</strong> <em>(uint8_t *<var>q</var>, const uint8_t *<var>n</var>, const uint8_t *<var>p</var>)</em></dt>
<dd><p>Computes <em>Q = N P</em>, where <em>P</em> is an input point and <em>N</em>
is an integer. The input arguments <var>n</var> and <var>p</var> and the output
argument <var>q</var> use a little-endian representation of the scalar and
the x-coordinates, respectively. They are all of size
<code>CURVE25519_SIZE</code>.
</p>
<p>This function is intended to be compatible with the function
<code>crypto_scalar_mult</code> in the NaCl library.
</p></dd></dl>

<p>Similarly, Nettle also implements Curve448, an elliptic curve of
Montgomery type, <em>y^2 = x^3 + 156326 x^2 + x (mod p)</em>, with
<em>p = 2^448 - 2^224 - 1</em>.  This particular curve was proposed by
Mike Hamburg in 2015, for fast Diffie-Hellman key exchange, and is also
described in <cite>RFC 7748</cite>.
</p>
<p>Nettle defines Curve 448 in <samp>&lt;nettle/curve448.h&gt;</samp>.
</p>
<dl>
<dt id="index-CURVE448_005fSIZE">Constant: <strong>CURVE448_SIZE</strong></dt>
<dd><p>The octet length of the strings representing curve448 points and scalars, 56.
</p></dd></dl>

<dl>
<dt id="index-curve448_005fmul_005fg">Function: <em>void</em> <strong>curve448_mul_g</strong> <em>(uint8_t *<var>q</var>, const uint8_t *<var>n</var>)</em></dt>
<dd><p>Computes <em>Q = N G</em>, where <em>G</em> is the group generator and
<em>N</em> is an integer. The input argument <var>n</var> and the output
argument <var>q</var> use a little-endian representation of the scalar and
the x-coordinate, respectively. They are both of size
<code>CURVE448_SIZE</code>.
</p>
<p>This function is intended to be compatible with the function
<code>crypto_scalar_mult_base</code> in the NaCl library.
</p></dd></dl>

<dl>
<dt id="index-curve448_005fmul">Function: <em>void</em> <strong>curve448_mul</strong> <em>(uint8_t *<var>q</var>, const uint8_t *<var>n</var>, const uint8_t *<var>p</var>)</em></dt>
<dd><p>Computes <em>Q = N P</em>, where <em>P</em> is an input point and <em>N</em>
is an integer. The input arguments <var>n</var> and <var>p</var> and the output
argument <var>q</var> use a little-endian representation of the scalar and
the x-coordinates, respectively. They are all of size
<code>CURVE448_SIZE</code>.
</p>
<p>This function is intended to be compatible with the function
<code>crypto_scalar_mult</code> in the NaCl library.
</p></dd></dl>

<span id="EdDSA"></span><h4 class="subsubsection">7.7.3.5 EdDSA</h4>
<span id="index-eddsa"></span>

<p>EdDSA is a signature scheme proposed by D. J. Bernstein et al. in 2011.
It is defined using a &ldquo;Twisted Edwards curve&rdquo;, of the form <em>-x^2
+ y^2 = 1 + d x^2 y^2</em>. The specific signature scheme Ed25519 uses a
curve which is equivalent to curve25519: The two groups used differ only
by a simple change of coordinates, so that the discrete logarithm
problem is of equal difficulty in both groups.
</p>
<p>Unlike other signature schemes in Nettle, the input to the EdDSA sign
and verify functions is the possibly large message itself, not a hash
digest. EdDSA is a variant of Schnorr signatures, where the message is
hashed together with other data during the signature process, providing
resilience to hash-collisions: A successful attack finding collisions in
the hash function does not automatically translate into an attack to
forge signatures. EdDSA also avoids the use of a randomness source by
generating the needed signature nonce from a hash of the private key and
the message, which means that the message is actually hashed twice when
creating a signature. If signing huge messages, it is possible to hash
the message first and pass the short message digest as input to the sign
and verify functions, however, the resilience to hash collision is then
lost.
</p>
<dl>
<dt id="index-ED25519_005fKEY_005fSIZE">Constant: <strong>ED25519_KEY_SIZE</strong></dt>
<dd><p>The size of a private or public Ed25519 key, 32 octets.
</p></dd></dl>

<dl>
<dt id="index-ED25519_005fSIGNATURE_005fSIZE">Constant: <strong>ED25519_SIGNATURE_SIZE</strong></dt>
<dd><p>The size of an Ed25519 signature, 64 octets.
</p></dd></dl>

<dl>
<dt id="index-ed25519_005fsha512_005fpublic_005fkey">Function: <em>void</em> <strong>ed25519_sha512_public_key</strong> <em>(uint8_t *<var>pub</var>, const uint8_t *<var>priv</var>)</em></dt>
<dd><p>Computes the public key corresponding to the given private key. Both
input and output are of size <code>ED25519_KEY_SIZE</code>.
</p></dd></dl>

<dl>
<dt id="index-ed25519_005fsha512_005fsign">Function: <em>void</em> <strong>ed25519_sha512_sign</strong> <em>(const uint8_t *<var>pub</var>, const uint8_t *<var>priv</var>, size_t <var>length</var>, const uint8_t *<var>msg</var>, uint8_t *<var>signature</var>)</em></dt>
<dd><p>Signs a message using the provided key pair.
</p></dd></dl>

<dl>
<dt id="index-ed25519_005fsha512_005fverify">Function: <em>int</em> <strong>ed25519_sha512_verify</strong> <em>(const uint8_t *<var>pub</var>, size_t <var>length</var>, const uint8_t *<var>msg</var>, const uint8_t *<var>signature</var>)</em></dt>
<dd><p>Verifies a message using the provided public key. Returns 1 if the
signature is valid, otherwise 0.
</p></dd></dl>

<p>Nettle also provides Ed448, an EdDSA signature scheme based on an
Edwards curve equivalent to curve448.
</p>
<dl>
<dt id="index-ED448_005fKEY_005fSIZE">Constant: <strong>ED448_KEY_SIZE</strong></dt>
<dd><p>The size of a private or public Ed448 key, 57 octets.
</p></dd></dl>

<dl>
<dt id="index-ED448_005fSIGNATURE_005fSIZE">Constant: <strong>ED448_SIGNATURE_SIZE</strong></dt>
<dd><p>The size of an Ed448 signature, 114 octets.
</p></dd></dl>

<dl>
<dt id="index-ed448_005fshake256_005fpublic_005fkey">Function: <em>void</em> <strong>ed448_shake256_public_key</strong> <em>(uint8_t *<var>pub</var>, const uint8_t *<var>priv</var>)</em></dt>
<dd><p>Computes the public key corresponding to the given private key. Both
input and output are of size <code>ED448_KEY_SIZE</code>.
</p></dd></dl>

<dl>
<dt id="index-ed448_005fshake256_005fsign">Function: <em>void</em> <strong>ed448_shake256_sign</strong> <em>(const uint8_t *<var>pub</var>, const uint8_t *<var>priv</var>, size_t <var>length</var>, const uint8_t *<var>msg</var>, uint8_t *<var>signature</var>)</em></dt>
<dd><p>Signs a message using the provided key pair.
</p></dd></dl>

<dl>
<dt id="index-ed448_005fshake256_005fverify">Function: <em>int</em> <strong>ed448_shake256_verify</strong> <em>(const uint8_t *<var>pub</var>, size_t <var>length</var>, const uint8_t *<var>msg</var>, const uint8_t *<var>signature</var>)</em></dt>
<dd><p>Verifies a message using the provided public key. Returns 1 if the
signature is valid, otherwise 0.
</p></dd></dl>

<hr>
<span id="Randomness"></span><div class="header">
<p>
Next: <a href="#ASCII-encoding" accesskey="n" rel="next">ASCII encoding</a>, Previous: <a href="#Public_002dkey-algorithms" accesskey="p" rel="prev">Public-key algorithms</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Randomness-1"></span><h3 class="section">7.8 Randomness</h3>

<span id="index-Randomness"></span>

<p>A crucial ingredient in many cryptographic contexts is randomness: Let
<code>p</code> be a random prime, choose a random initialization vector
<code>iv</code>, a random key <code>k</code> and a random exponent <code>e</code>, etc. In
the theories, it is assumed that you have plenty of randomness around.
If this assumption is not true in practice, systems that are otherwise
perfectly secure, can be broken. Randomness has often turned out to be
the weakest link in the chain.
</p>
<p>In non-cryptographic applications, such as games as well as scientific
simulation, a good randomness generator usually means a generator that
has good statistical properties, and is seeded by some simple function
of things like the current time, process id, and host name.
</p>
<p>However, such a generator is inadequate for cryptography, for at least
two reasons:
</p>

<ul>
<li> It&rsquo;s too easy for an attacker to guess the initial seed. Even if it will
take some 2^32 tries before he guesses right, that&rsquo;s far too easy. For
example, if the process id is 16 bits, the resolution of &ldquo;current time&rdquo;
is one second, and the attacker knows what day the generator was seeded,
there are only about 2^32 possibilities to try if all possible values
for the process id and time-of-day are tried.

</li><li> The generator output reveals too much. By observing only a small segment
of the generator&rsquo;s output, its internal state can be recovered, and from
there, all previous output and all future output can be computed by the
attacker. 
</li></ul>

<p>A randomness generator that is used for cryptographic purposes must have
better properties. Let&rsquo;s first look at the seeding, as the issues here
are mostly independent of the rest of the generator. The initial state
of the generator (its seed) must be unguessable by the attacker. So
what&rsquo;s unguessable? It depends on what the attacker already knows. The
concept used in information theory to reason about such things is called
&ldquo;entropy&rdquo;, or &ldquo;conditional entropy&rdquo; (not to be confused with the
thermodynamic concept with the same name). A reasonable requirement is
that the seed contains a conditional entropy of at least some 80-100
bits. This property can be explained as follows: Allow the attacker to
ask <code>n</code> yes-no-questions, of his own choice, about the seed. If
the attacker, using this question-and-answer session, as well as any
other information he knows about the seeding process, still can&rsquo;t guess
the seed correctly, then the conditional entropy is more than <code>n</code>
bits.
</p>
<span id="index-Entropy"></span>
<span id="index-Conditional-entropy"></span>

<p>Let&rsquo;s look at an example. Say information about timing of received
network packets is used in the seeding process. If there is some random
network traffic going on, this will contribute some bits of entropy or
&ldquo;unguessability&rdquo; to the seed. However, if the attacker can listen in to
the local network, or if all but a small number of the packets were
transmitted by machines that the attacker can monitor, this additional
information makes the seed easier for the attacker to figure out. Even
if the information is exactly the same, the conditional entropy, or
unguessability, is smaller for an attacker that knows some of it already
before the hypothetical question-and-answer session.
</p>
<p>Seeding of good generators is usually based on several sources. The key
point here is that the amount of unguessability that each source
contributes, depends on who the attacker is. Some sources that have been
used are:
</p>
<dl compact="compact">
<dt>High resolution timing of i/o activities</dt>
<dd><p>Such as completed blocks from spinning hard disks, network packets, etc.
Getting access to such information is quite system dependent, and not
all systems include suitable hardware. If available, it&rsquo;s one of the
better randomness source one can find in a digital, mostly predictable,
computer.
</p>
</dd>
<dt>User activity</dt>
<dd><p>Timing and contents of user interaction events is another popular source
that is available for interactive programs (even if I suspect that it is
sometimes used in order to make the user feel good, not because the
quality of the input is needed or used properly). Obviously, not
available when a machine is unattended. Also beware of networks: User
interaction that happens across a long serial cable, <acronym>TELNET</acronym>
session, or even <acronym>SSH</acronym> session may be visible to an attacker, in
full or partially.
</p>
</dd>
<dt>Audio input</dt>
<dd><p>Any room, or even a microphone input that&rsquo;s left unconnected, is a
source of some random background noise, which can be fed into the
seeding process.
</p>
</dd>
<dt>Specialized hardware</dt>
<dd><p>Hardware devices with the sole purpose of generating random data have
been designed. They range from radioactive samples with an attached
Geiger counter, to amplification of the inherent noise in electronic
components such as diodes and resistors, to low-frequency sampling of
chaotic systems. Hashing successive images of a Lava lamp is a
spectacular example of the latter type.
</p>
</dd>
<dt>Secret information</dt>
<dd><p>Secret information, such as user passwords or keys, or private files
stored on disk, can provide some unguessability. A problem is that if
the information is revealed at a later time, the unguessability
vanishes. Another problem is that this kind of information tends to be
fairly constant, so if you rely on it and seed your generator regularly,
you risk constructing almost similar seeds or even constructing the same
seed more than once.
</p></dd>
</dl>

<p>For all practical sources, it&rsquo;s difficult but important to provide a
reliable lower bound on the amount of unguessability that it provides.
Two important points are to make sure that the attacker can&rsquo;t observe
your sources (so if you like the Lava lamp idea, remember that you have
to get your own lamp, and not put it by a window or anywhere else where
strangers can see it), and that hardware failures are detected. What if
the bulb in the Lava lamp, which you keep locked into a cupboard
following the above advice, breaks after a few months?
</p>
<p>So let&rsquo;s assume that we have been able to find an unguessable seed,
which contains at least 80 bits of conditional entropy, relative to all
attackers that we care about (typically, we must at the very least
assume that no attacker has root privileges on our machine).
</p>
<p>How do we generate output from this seed, and how much can we get? Some
generators (notably the Linux <samp>/dev/random</samp> generator) tries to
estimate available entropy and restrict the amount of output. The goal
is that if you read 128 bits from <samp>/dev/random</samp>, you should get 128
&ldquo;truly random&rdquo; bits. This is a property that is useful in some
specialized circumstances, for instance when generating key material for
a one time pad, or when working with unconditional blinding, but in most
cases, it doesn&rsquo;t matter much. For most application, there&rsquo;s no limit on
the amount of useful &ldquo;random&rdquo; data that we can generate from a small
seed; what matters is that the seed is unguessable and that the
generator has good cryptographic properties.
</p>
<p>At the heart of all generators lies its internal state. Future output
is determined by the internal state alone. Let&rsquo;s call it the generator&rsquo;s
key. The key is initialized from the unguessable seed. Important
properties of a generator are:
</p>
<dl compact="compact">
<dt><em>Key-hiding</em></dt>
<dd><p>An attacker observing the output should not be able to recover the
generator&rsquo;s key.
</p>
</dd>
<dt><em>Independence of outputs</em></dt>
<dd><p>Observing some of the output should not help the attacker to guess
previous or future output.
</p>
</dd>
<dt><em>Forward secrecy</em></dt>
<dd><p>Even if an attacker compromises the generator&rsquo;s key, he should not be
able to guess the generator output <em>before</em> the key compromise.
</p>
</dd>
<dt><em>Recovery from key compromise</em></dt>
<dd><p>If an attacker compromises the generator&rsquo;s key, he can compute
<em>all</em> future output. This is inevitable if the generator is seeded
only once, at startup. However, the generator can provide a reseeding
mechanism, to achieve recovery from key compromise. More precisely: If
the attacker compromises the key at a particular time <code>t_1</code>, there
is another later time <code>t_2</code>, such that if the attacker observes all
output generated between <code>t_1</code> and <code>t_2</code>, he still can&rsquo;t guess
what output is generated after <code>t_2</code>.
</p>
</dd>
</dl>

<p>Nettle includes one randomness generator that is believed to have all
the above properties, and two simpler ones.
</p>
<p><acronym>ARCFOUR</acronym>, like any stream cipher, can be used as a randomness
generator. Its output should be of reasonable quality, if the seed is
hashed properly before it is used with <code>arcfour_set_key</code>. There&rsquo;s
no single natural way to reseed it, but if you need reseeding, you
should be using Yarrow instead.
</p>
<p>The &ldquo;lagged Fibonacci&rdquo; generator in <samp>&lt;nettle/knuth-lfib.h&gt;</samp> is a
fast generator with good statistical properties, but is <strong>not</strong> for
cryptographic use, and therefore not documented here. It is included
mostly because the Nettle test suite needs to generate some test data
from a small seed.
</p>
<p>The recommended generator to use is Yarrow, described below.
</p>
<span id="Yarrow"></span><h4 class="subsection">7.8.1 Yarrow</h4>

<p>Yarrow is a family of pseudo-randomness generators, designed for
cryptographic use, by John Kelsey, Bruce Schneier and Niels Ferguson.
Yarrow-160 is described in a paper at
<a href="https://www.counterpane.com/yarrow.html">https://www.counterpane.com/yarrow.html</a>, and it uses <acronym>SHA1</acronym>
and triple-DES, and has a 160-bit internal state. Nettle implements
Yarrow-256, which is similar, but uses <acronym>SHA256</acronym> and
<acronym>AES</acronym> to get an internal state of 256 bits.
</p>
<p>Yarrow was an almost finished project, the paper mentioned above is the
closest thing to a specification for it, but some smaller details are
left out. There is no official reference implementation or test cases.
This section includes an overview of Yarrow, but for the details of
Yarrow-256, as implemented by Nettle, you have to consult the source
code. Maybe a complete specification can be written later.
</p>
<p>Yarrow can use many sources (at least two are needed for proper
reseeding), and two randomness &ldquo;pools&rdquo;, referred to as the &ldquo;slow pool&rdquo; and
the &ldquo;fast pool&rdquo;. Input from the sources is fed alternatingly into the
two pools. When one of the sources has contributed 100 bits of entropy
to the fast pool, a &ldquo;fast reseed&rdquo; happens and the fast pool is mixed
into the internal state. When at least two of the sources have
contributed at least 160 bits each to the slow pool, a &ldquo;slow reseed&rdquo;
takes place. The contents of both pools are mixed into the internal
state. These procedures should ensure that the generator will eventually
recover after a key compromise.
</p>
<p>The output is generated by using <acronym>AES</acronym> to encrypt a counter,
using the generator&rsquo;s current key. After each request for output,
another 256 bits are generated which replace the key. This ensures
forward secrecy.
</p>
<p>Yarrow can also use a <em>seed file</em> to save state across restarts.
Yarrow is seeded by either feeding it the contents of the previous seed
file, or feeding it input from its sources until a slow reseed happens.
</p>
<p>Nettle defines Yarrow-256 in <samp>&lt;nettle/yarrow.h&gt;</samp>. 
</p>
<dl>
<dt id="index-struct-yarrow256_005fctx">Context struct: <strong>struct yarrow256_ctx</strong></dt>
</dl>

<dl>
<dt id="index-struct-yarrow_005fsource">Context struct: <strong>struct yarrow_source</strong></dt>
<dd><p>Information about a single source.
</p></dd></dl>

<dl>
<dt id="index-YARROW256_005fSEED_005fFILE_005fSIZE">Constant: <strong>YARROW256_SEED_FILE_SIZE</strong></dt>
<dd><p>Recommended size of the Yarrow-256 seed file.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005finit">Function: <em>void</em> <strong>yarrow256_init</strong> <em>(struct yarrow256_ctx *<var>ctx</var>, unsigned <var>nsources</var>, struct yarrow_source *<var>sources</var>)</em></dt>
<dd><p>Initializes the yarrow context, and its <var>nsources</var> sources. It&rsquo;s
possible to call it with <var>nsources</var>=0 and <var>sources</var>=NULL, if
you don&rsquo;t need the update features.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005fseed">Function: <em>void</em> <strong>yarrow256_seed</strong> <em>(struct yarrow256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>seed_file</var>)</em></dt>
<dd><p>Seeds Yarrow-256 from a previous seed file. <var>length</var> should be at least
<code>YARROW256_SEED_FILE_SIZE</code>, but it can be larger.
</p>
<p>The generator will trust you that the <var>seed_file</var> data really is
unguessable. After calling this function, you <em>must</em> overwrite the old
seed file with newly generated data from <code>yarrow256_random</code>. If it&rsquo;s
possible for several processes to read the seed file at about the same
time, access must be coordinated using some locking mechanism.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005fupdate">Function: <em>int</em> <strong>yarrow256_update</strong> <em>(struct yarrow256_ctx *<var>ctx</var>, unsigned <var>source</var>, unsigned <var>entropy</var>, size_t <var>length</var>, const uint8_t *<var>data</var>)</em></dt>
<dd><p>Updates the generator with data from source <var>SOURCE</var> (an index that
must be smaller than the number of sources). <var>entropy</var> is your
estimated lower bound for the entropy in the data, measured in bits.
Calling update with zero <var>entropy</var> is always safe, no matter if the
data is random or not.
</p>
<p>Returns 1 if a reseed happened, in which case an application using a
seed file may want to generate new seed data with
<code>yarrow256_random</code> and overwrite the seed file. Otherwise, the
function returns 0.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005frandom">Function: <em>void</em> <strong>yarrow256_random</strong> <em>(struct yarrow256_ctx *<var>ctx</var>, size_t <var>length</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>Generates <var>length</var> octets of output. The generator must be seeded
before you call this function.
</p>
<p>If you don&rsquo;t need forward secrecy, e.g. if you need non-secret
randomness for initialization vectors or padding, you can gain some
efficiency by buffering, calling this function for reasonably large
blocks of data, say 100-1000 octets at a time.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005fis_005fseeded">Function: <em>int</em> <strong>yarrow256_is_seeded</strong> <em>(struct yarrow256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Returns 1 if the generator is seeded and ready to generate output,
otherwise 0.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005fneeded_005fsources">Function: <em>unsigned</em> <strong>yarrow256_needed_sources</strong> <em>(struct yarrow256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Returns the number of sources that must reach the threshold before a
slow reseed will happen. Useful primarily when the generator is unseeded.
</p></dd></dl>

<dl>
<dt id="index-yarrow256_005ffast_005freseed">Function: <em>void</em> <strong>yarrow256_fast_reseed</strong> <em>(struct yarrow256_ctx *<var>ctx</var>)</em></dt>
<dt id="index-yarrow256_005fslow_005freseed">Function: <em>void</em> <strong>yarrow256_slow_reseed</strong> <em>(struct yarrow256_ctx *<var>ctx</var>)</em></dt>
<dd><p>Causes a fast or slow reseed to take place immediately, regardless of the
current entropy estimates of the two pools. Use with care.
</p></dd></dl>

<p>Nettle includes an entropy estimator for one kind of input source: User
keyboard input.
</p>
<dl>
<dt id="index-struct-yarrow_005fkey_005fevent_005fctx">Context struct: <strong>struct yarrow_key_event_ctx</strong></dt>
<dd><p>Information about recent key events.
</p></dd></dl>

<dl>
<dt id="index-yarrow_005fkey_005fevent_005finit">Function: <em>void</em> <strong>yarrow_key_event_init</strong> <em>(struct yarrow_key_event_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initializes the context.
</p></dd></dl>

<dl>
<dt id="index-yarrow_005fkey_005fevent_005festimate">Function: <em>unsigned</em> <strong>yarrow_key_event_estimate</strong> <em>(struct yarrow_key_event_ctx *<var>ctx</var>, unsigned <var>key</var>, unsigned <var>time</var>)</em></dt>
<dd><p><var>key</var> is the id of the key (ASCII value, hardware key code, X
keysym, &hellip;, it doesn&rsquo;t matter), and <var>time</var> is the timestamp of
the event. The time must be given in units matching the resolution by
which you read the clock. If you read the clock with microsecond
precision, <var>time</var> should be provided in units of microseconds. But
if you use <code>gettimeofday</code> on a typical Unix system where the clock
ticks 10 or so microseconds at a time, <var>time</var> should be given in
units of 10 microseconds.
</p>
<p>Returns an entropy estimate, in bits, suitable for calling
<code>yarrow256_update</code>. Usually, 0, 1 or 2 bits.
</p></dd></dl>

<hr>
<span id="ASCII-encoding"></span><div class="header">
<p>
Next: <a href="#Miscellaneous-functions" accesskey="n" rel="next">Miscellaneous functions</a>, Previous: <a href="#Randomness" accesskey="p" rel="prev">Randomness</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="ASCII-encoding-1"></span><h3 class="section">7.9 ASCII encoding</h3>

<p>Encryption will transform your data from text into binary format, and that
may be a problem if, for example, you want to send the data as if it was
plain text in an email, or store it along with descriptive text in a
file. You may then use an encoding from binary to text: each binary byte
is translated into a number of bytes of plain text.
</p>
<p>A base-N encoding of data is one representation of data that only uses N
different symbols (instead of the 256 possible values of a byte).
</p>
<p>The base64 encoding will always use alphanumeric (upper and lower case)
characters and the &rsquo;+&rsquo;, &rsquo;/&rsquo; and &rsquo;=&rsquo; symbols to represent the data. Four
output characters are generated for each three bytes of input. In case
the length of the input is not a multiple of three, padding characters
are added at the end. There&rsquo;s also a &ldquo;URL safe&rdquo; variant, which is
useful for encoding binary data into URLs and filenames. See <cite>RFC
4648</cite>.
</p>
<p>The base16 encoding, also known as &ldquo;hexadecimal&rdquo;, uses the decimal
digits and the letters from A to F. Two hexadecimal digits are generated
for each input byte.
</p>
<p>Nettle supports both base64 and base16 encoding and decoding.
</p>
<p>Encoding and decoding uses a context struct to maintain its state (with
the exception of base16 encoding, which doesn&rsquo;t need any). To encode or
decode the data, first initialize the context, then call the update
function as many times as necessary, and complete the operation by
calling the final function.
</p>
<p>The following functions can be used to perform base64 encoding and decoding.
They are defined in <samp>&lt;nettle/base64.h&gt;</samp>.
</p>
<dl>
<dt id="index-struct-base64_005fencode_005fctx">Context struct: <strong>struct base64_encode_ctx</strong></dt>
</dl>

<dl>
<dt id="index-base64_005fencode_005finit">Function: <em>void</em> <strong>base64_encode_init</strong> <em>(struct base64_encode_ctx *<var>ctx</var>)</em></dt>
<dt id="index-base64url_005fencode_005finit">Function: <em>void</em> <strong>base64url_encode_init</strong> <em>(struct base64_encode_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initializes a base64 context. This is necessary before starting an
encoding session. <code>base64_encode_init</code> selects the standard base64
alphabet, while <code>base64url_encode_init</code> selects the URL safe
alphabet.
</p></dd></dl>


<dl>
<dt id="index-base64_005fencode_005fsingle">Function: <em>size_t</em> <strong>base64_encode_single</strong> <em>(struct base64_encode_ctx *<var>ctx</var>, uint8_t *<var>dst</var>, uint8_t <var>src</var>)</em></dt>
<dd><p>Encodes a single byte. Returns amount of output (always 1 or 2).
</p></dd></dl>

<dl>
<dt id="index-BASE64_005fENCODE_005fLENGTH">Macro: <strong>BASE64_ENCODE_LENGTH</strong> <em>(<var>length</var>)</em></dt>
<dd><p>The maximum number of output bytes when passing <var>length</var> input bytes
to <code>base64_encode_update</code>.
</p></dd></dl>

<dl>
<dt id="index-base64_005fencode_005fupdate">Function: <em>size_t</em> <strong>base64_encode_update</strong> <em>(struct base64_encode_ctx *<var>ctx</var>, uint8_t *<var>dst</var>, size_t <var>length</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>After <var>ctx</var> is initialized, this function may be called to encode <var>length</var>
bytes from <var>src</var>. The result will be placed in <var>dst</var>, and the return value
will be the number of bytes generated. Note that <var>dst</var> must be at least of size
BASE64_ENCODE_LENGTH(<var>length</var>).
</p></dd></dl>

<dl>
<dt id="index-BASE64_005fENCODE_005fFINAL_005fLENGTH">Constant: <strong>BASE64_ENCODE_FINAL_LENGTH</strong></dt>
<dd><p>The maximum amount of output from <code>base64_encode_final</code>.
</p></dd></dl>

<dl>
<dt id="index-base64_005fencode_005ffinal">Function: <em>size_t</em> <strong>base64_encode_final</strong> <em>(struct base64_encode_ctx *<var>ctx</var>, uint8_t *<var>dst</var>)</em></dt>
<dd><p>After calling base64_encode_update one or more times, this function
should be called to generate the final output bytes, including any
needed paddding. The return value is the number of output bytes
generated.
</p></dd></dl>

<dl>
<dt id="index-struct-base64_005fdecode_005fctx">Context struct: <strong>struct base64_decode_ctx</strong></dt>
</dl>

<dl>
<dt id="index-base64_005fdecode_005finit">Function: <em>void</em> <strong>base64_decode_init</strong> <em>(struct base64_decode_ctx *<var>ctx</var>)</em></dt>
<dt id="index-base64url_005fdecode_005finit">Function: <em>void</em> <strong>base64url_decode_init</strong> <em>(struct base64_decode_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initializes a base64 decoding context. This is necessary before starting
a decoding session. <code>base64_decode_init</code> selects the standard
base64 alphabet, while <code>base64url_decode_init</code> selects the URL safe
alphabet.
</p></dd></dl>

<dl>
<dt id="index-base64_005fdecode_005fsingle">Function: <em>int</em> <strong>base64_decode_single</strong> <em>(struct base64_decode_ctx *<var>ctx</var>, uint8_t *<var>dst</var>, uint8_t <var>src</var>)</em></dt>
<dd><p>Decodes a single byte (<var>src</var>) and stores the result in <var>dst</var>.
Returns amount of output (0 or 1), or -1 on errors.
</p></dd></dl>

<dl>
<dt id="index-BASE64_005fDECODE_005fLENGTH">Macro: <strong>BASE64_DECODE_LENGTH</strong> <em>(<var>length</var>)</em></dt>
<dd><p>The maximum number of output bytes when passing <var>length</var> input bytes
to <code>base64_decode_update</code>.
</p></dd></dl>

<dl>
<dt id="index-base64_005fdecode_005fupdate">Function: <em>void</em> <strong>base64_decode_update</strong> <em>(struct base64_decode_ctx *<var>ctx</var>, size_t *<var>dst_length</var>, uint8_t *<var>dst</var>, size_t <var>src_length</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>After <var>ctx</var> is initialized, this function may be called to decode
<var>src_length</var> bytes from <var>src</var>. <var>dst</var> should point to an area
of size at least BASE64_DECODE_LENGTH(<var>src_length</var>). The amount of data
generated is returned in *<var>dst_length</var>. Returns 1 on success
and 0 on error.
</p></dd></dl>

<dl>
<dt id="index-base64_005fdecode_005ffinal">Function: <em>int</em> <strong>base64_decode_final</strong> <em>(struct base64_decode_ctx *<var>ctx</var>)</em></dt>
<dd><p>Check that final padding is correct. Returns 1 on success, and 0 on
error.
</p></dd></dl>

<p>Similarly to the base64 functions, the following functions perform base16 encoding,
and are defined in <samp>&lt;nettle/base16.h&gt;</samp>. Note that there is no encoding context
necessary for doing base16 encoding.
</p>
<dl>
<dt id="index-base16_005fencode_005fsingle">Function: <em>void</em> <strong>base16_encode_single</strong> <em>(uint8_t *<var>dst</var>, uint8_t <var>src</var>)</em></dt>
<dd><p>Encodes a single byte. Always stores two digits in <var>dst</var>[0] and <var>dst</var>[1].
</p></dd></dl>

<dl>
<dt id="index-BASE16_005fENCODE_005fLENGTH">Macro: <strong>BASE16_ENCODE_LENGTH</strong> <em>(<var>length</var>)</em></dt>
<dd><p>The number of output bytes when passing <var>length</var> input bytes to
<code>base16_encode_update</code>.
</p></dd></dl>

<dl>
<dt id="index-base16_005fencode_005fupdate">Function: <em>void</em> <strong>base16_encode_update</strong> <em>(uint8_t *<var>dst</var>, size_t <var>length</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>Always stores BASE16_ENCODE_LENGTH(<var>length</var>) digits in <var>dst</var>.
</p></dd></dl>

<dl>
<dt id="index-struct-base16_005fdecode_005fctx">Context struct: <strong>struct base16_decode_ctx</strong></dt>
</dl>

<dl>
<dt id="index-base16_005fdecode_005finit">Function: <em>void</em> <strong>base16_decode_init</strong> <em>(struct base16_decode_ctx *<var>ctx</var>)</em></dt>
<dd><p>Initializes a base16 decoding context. This is necessary before starting a decoding
session.
</p></dd></dl>

<dl>
<dt id="index-base16_005fdecode_005fsingle">Function: <em>int</em> <strong>base16_decode_single</strong> <em>(struct base16_decode_ctx *<var>ctx</var>, uint8_t *<var>dst</var>, uint8_t <var>src</var>)</em></dt>
<dd><p>Decodes a single byte from <var>src</var> into <var>dst</var>. Returns amount of output (0 or 1), or -1 on errors.
</p></dd></dl>

<dl>
<dt id="index-BASE16_005fDECODE_005fLENGTH">Macro: <strong>BASE16_DECODE_LENGTH</strong> <em>(<var>length</var>)</em></dt>
<dd><p>The maximum number of output bytes when passing <var>length</var> input bytes
to <code>base16_decode_update</code>.
</p></dd></dl>

<dl>
<dt id="index-base16_005fdecode_005fupdate">Function: <em>int</em> <strong>base16_decode_update</strong> <em>(struct base16_decode_ctx *<var>ctx</var>, size_t *<var>dst_length</var>, uint8_t *<var>dst</var>, size_t <var>src_length</var>, const uint8_t *<var>src</var>)</em></dt>
<dd><p>After <var>ctx</var> is initialized, this function may be called to decode
<var>src_length</var> bytes from <var>src</var>. <var>dst</var> should point to an area
of size at least BASE16_DECODE_LENGTH(<var>src_length</var>). The amount of data
generated is returned in *<var>dst_length</var>. Returns 1 on success
and 0 on error.
</p></dd></dl>

<dl>
<dt id="index-base16_005fdecode_005ffinal">Function: <em>int</em> <strong>base16_decode_final</strong> <em>(struct base16_decode_ctx *<var>ctx</var>)</em></dt>
<dd><p>Checks that the end of data is correct (i.e., an even number of
hexadecimal digits have been seen). Returns 1 on success, and 0 on
error.
</p></dd></dl>

<hr>
<span id="Miscellaneous-functions"></span><div class="header">
<p>
Next: <a href="#Compatibility-functions" accesskey="n" rel="next">Compatibility functions</a>, Previous: <a href="#ASCII-encoding" accesskey="p" rel="prev">ASCII encoding</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Miscellaneous-functions-1"></span><h3 class="section">7.10 Miscellaneous functions</h3>

<dl>
<dt id="index-memxor">Function: <em>void *</em> <strong>memxor</strong> <em>(void *<var>dst</var>, const void *<var>src</var>, size_t <var>n</var>)</em></dt>
<dd><p>XORs the source area on top of the destination area. The interface
doesn&rsquo;t follow the Nettle conventions, because it is intended to be
similar to the ANSI-C <code>memcpy</code> function.
</p></dd></dl>

<dl>
<dt id="index-memxor3">Function: <em>void *</em> <strong>memxor3</strong> <em>(void *<var>dst</var>, const void *<var>a</var>, const void *<var>b</var>, size_t <var>n</var>)</em></dt>
<dd><p>Like <code>memxor</code>, but takes two source areas and separate
destination area.
</p></dd></dl>

<dl>
<dt id="index-memeql_005fsec">Function: <em>int</em> <strong>memeql_sec</strong> <em>(const void *<var>a</var>, const void *<var>b</var>, size_t <var>n</var>)</em></dt>
<dd><p>Side-channel silent comparison of the <var>n</var> bytes at <var>a</var> and
<var>b</var>. I.e., instructions executed and memory accesses are identical
no matter where the areas differ, see <a href="#Side_002dchannel-silence">Side-channel silence</a>. Return
non-zero if the areas are equal, and zero if they differ.
</p></dd></dl>

<p>These functions are declared in <samp>&lt;nettle/memops.h&gt;</samp>. For
compatibility with earlier versions of Nettle, <code>memxor</code> and
<code>memxor3</code> are also declared in <samp>&lt;nettle/memxor.h&gt;</samp>.
</p>
<hr>
<span id="Compatibility-functions"></span><div class="header">
<p>
Previous: <a href="#Miscellaneous-functions" accesskey="p" rel="prev">Miscellaneous functions</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compatibility-functions-1"></span><h3 class="section">7.11 Compatibility functions</h3>

<p>For convenience, Nettle includes alternative interfaces to some
algorithms, for compatibility with some other popular crypto toolkits.
These are not fully documented here; refer to the source or to the
documentation for the original implementation.
</p>
<p>MD5 is defined in [RFC 1321], which includes a reference implementation.
Nettle defines a compatible interface to MD5 in
<samp>&lt;nettle/md5-compat.h&gt;</samp>. This file defines the typedef
<code>MD5_CTX</code>, and declares the functions <code>MD5Init</code>, <code>MD5Update</code> and
<code>MD5Final</code>.
</p>
<hr>
<span id="Nettle-soup"></span><div class="header">
<p>
Next: <a href="#Installation" accesskey="n" rel="next">Installation</a>, Previous: <a href="#Reference" accesskey="p" rel="prev">Reference</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Traditional-Nettle-Soup"></span><h2 class="chapter">8 Traditional Nettle Soup</h2>
<p>For the serious nettle hacker, here is a recipe for nettle soup. 4 servings.
</p>
<ul class="no-bullet">
<li><!-- /@w --> 1 liter fresh nettles (urtica dioica)
</li><li><!-- /@w --> 2 tablespoons butter
</li><li><!-- /@w --> 3 tablespoons flour
</li><li><!-- /@w --> 1 liter stock (meat or vegetable)
</li><li><!-- /@w --> 1/2 teaspoon salt
</li><li><!-- /@w --> a tad white pepper
</li><li><!-- /@w --> some cream or milk
</li></ul>

<p>Gather 1 liter fresh nettles. Use gloves! Small, tender shoots are
preferable but the tops of larger nettles can also be used.
</p>
<p>Rinse the nettles very well. Boil them for 10 minutes in lightly salted
water. Strain the nettles and save the water. Hack the nettles. Melt the
butter and mix in the flour. Dilute with stock and the nettle-water you
saved earlier. Add the hacked nettles. If you wish you can add some milk
or cream at this stage. Bring to a boil and let boil for a few minutes.
Season with salt and pepper.
</p>
<p>Serve with boiled egg-halves.
</p>

<hr>
<span id="Installation"></span><div class="header">
<p>
Next: <a href="#Index" accesskey="n" rel="next">Index</a>, Previous: <a href="#Nettle-soup" accesskey="p" rel="prev">Nettle soup</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Installation-1"></span><h2 class="chapter">9 Installation</h2>

<p>Nettle uses <code>autoconf</code>. To build it, unpack the source and run
</p>
<div class="example">
<pre class="example">./configure
make
make check
make install
</pre></div>

<p>to install it under the default prefix, <samp>/usr/local</samp>. Using GNU
make is strongly recommended. By default, both static and shared
libraries are built and installed.
</p>
<p>To get a list of configure options, use <code>./configure --help</code>. Some
of the more interesting are:
</p>
<dl compact="compact">
<dt><samp>--enable-fat</samp></dt>
<dd><p>Include multiple versions of certain functions in the library, and
select the ones to use at run-time, depending on available processor
features. Supported for ARM and x86_64.
</p>
</dd>
<dt><samp>--enable-mini-gmp</samp></dt>
<dd><p>Use the smaller and slower &ldquo;mini-gmp&rdquo; implementation of the bignum
functions needed for public-key cryptography, instead of the real GNU
GMP library. This option is intended primarily for smaller embedded
systems. Note that builds using mini-gmp are <strong>not</strong> binary compatible
with regular builds of Nettle, and more likely to leak side-channel
information.
</p>
</dd>
<dt><samp>--disable-shared</samp></dt>
<dd><p>Omit building the shared libraries.
</p>
</dd>
<dt><samp>--disable-dependency-tracking</samp></dt>
<dd><p>Disable the automatic dependency tracking. You will likely need this
option to be able to build with BSD make.
</p>
</dd>
</dl>

<hr>
<span id="Index"></span><div class="header">
<p>
Previous: <a href="#Installation" accesskey="p" rel="prev">Installation</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Function-and-Concept-Index"></span><h2 class="unnumbered">Function and Concept Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_symbol-1"><b>3</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_symbol-1">3</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-3DES">3DES</a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ABI-compatibility">ABI compatibility</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AEAD">AEAD</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authenticated-encryption">Authenticated encryption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AES">AES</a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes128_005fdecrypt"><code>aes128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes128_005fencrypt"><code>aes128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes128_005finvert_005fkey"><code>aes128_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes128_005fset_005fdecrypt_005fkey"><code>aes128_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes128_005fset_005fencrypt_005fkey"><code>aes128_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes192_005fdecrypt"><code>aes192_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes192_005fencrypt"><code>aes192_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes192_005finvert_005fkey"><code>aes192_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes192_005fset_005fdecrypt_005fkey"><code>aes192_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes192_005fset_005fencrypt_005fkey"><code>aes192_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes256_005fdecrypt"><code>aes256_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes256_005fencrypt"><code>aes256_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes256_005finvert_005fkey"><code>aes256_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes256_005fset_005fdecrypt_005fkey"><code>aes256_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes256_005fset_005fencrypt_005fkey"><code>aes256_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes_005fdecrypt"><code>aes_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes_005fencrypt"><code>aes_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes_005finvert_005fkey"><code>aes_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes_005fset_005fdecrypt_005fkey"><code>aes_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aes_005fset_005fencrypt_005fkey"><code>aes_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-API-compatibility">API compatibility</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arcfour">Arcfour</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arcfour">Arcfour</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arcfour_005fcrypt"><code>arcfour_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arcfour">Arcfour</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arcfour_005fset_005fkey"><code>arcfour_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arcfour">Arcfour</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arctwo">Arctwo</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctwo_005fdecrypt"><code>arctwo_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctwo_005fencrypt"><code>arctwo_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctwo_005fset_005fkey"><code>arctwo_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctwo_005fset_005fkey_005fekb"><code>arctwo_set_key_ekb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctwo_005fset_005fkey_005fgutmann"><code>arctwo_set_key_gutmann</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Authenticated-encryption">Authenticated encryption</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authenticated-encryption">Authenticated encryption</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-B">B</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fdecode_005ffinal"><code>base16_decode_final</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fdecode_005finit"><code>base16_decode_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASE16_005fDECODE_005fLENGTH"><code>BASE16_DECODE_LENGTH</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fdecode_005fsingle"><code>base16_decode_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fdecode_005fupdate"><code>base16_decode_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASE16_005fENCODE_005fLENGTH"><code>BASE16_ENCODE_LENGTH</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fencode_005fsingle"><code>base16_encode_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base16_005fencode_005fupdate"><code>base16_encode_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64url_005fdecode_005finit"><code>base64url_decode_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64url_005fencode_005finit"><code>base64url_encode_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fdecode_005ffinal"><code>base64_decode_final</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fdecode_005finit"><code>base64_decode_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASE64_005fDECODE_005fLENGTH"><code>BASE64_DECODE_LENGTH</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fdecode_005fsingle"><code>base64_decode_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fdecode_005fupdate"><code>base64_decode_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fencode_005ffinal"><code>base64_encode_final</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fencode_005finit"><code>base64_encode_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASE64_005fENCODE_005fLENGTH"><code>BASE64_ENCODE_LENGTH</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fencode_005fsingle"><code>base64_encode_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base64_005fencode_005fupdate"><code>base64_encode_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Binary-compatibility">Binary compatibility</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Block-Cipher">Block Cipher</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cipher-functions">Cipher functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Blowfish">Blowfish</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blowfish_005fbcrypt_005fhash"><code>blowfish_bcrypt_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blowfish_005fbcrypt_005fverify"><code>blowfish_bcrypt_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blowfish_005fdecrypt"><code>blowfish_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blowfish_005fencrypt"><code>blowfish_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blowfish_005fset_005fkey"><code>blowfish_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-C">C</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Camellia">Camellia</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia128_005fcrypt"><code>camellia128_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia128_005finvert_005fkey"><code>camellia128_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia128_005fset_005fdecrypt_005fkey"><code>camellia128_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia128_005fset_005fencrypt_005fkey"><code>camellia128_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia192_005fcrypt"><code>camellia192_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia192_005finvert_005fkey"><code>camellia192_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia192_005fset_005fdecrypt_005fkey"><code>camellia192_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia192_005fset_005fencrypt_005fkey"><code>camellia192_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia256_005fcrypt"><code>camellia256_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia256_005finvert_005fkey"><code>camellia256_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia256_005fset_005fdecrypt_005fkey"><code>camellia256_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia256_005fset_005fencrypt_005fkey"><code>camellia256_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia_005fcrypt"><code>camellia_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia_005finvert_005fkey"><code>camellia_invert_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia_005fset_005fdecrypt_005fkey"><code>camellia_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-camellia_005fset_005fencrypt_005fkey"><code>camellia_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CAST">CAST</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cast128_005fdecrypt"><code>cast128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cast128_005fencrypt"><code>cast128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cast128_005fset_005fkey"><code>cast128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cast5_005fset_005fkey"><code>cast5_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CBC-Mode">CBC Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbc_005faes128_005fencrypt"><code>cbc_aes128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbc_005faes192_005fencrypt"><code>cbc_aes192_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbc_005faes256_005fencrypt"><code>cbc_aes256_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CBC_005fCTX"><code>CBC_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbc_005fdecrypt"><code>cbc_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CBC_005fDECRYPT"><code>CBC_DECRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbc_005fencrypt"><code>cbc_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CBC_005fENCRYPT"><code>CBC_ENCRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CBC_005fSET_005fIV"><code>CBC_SET_IV</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CCM-Mode">CCM Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fdecrypt"><code>ccm_aes128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fdecrypt_005fmessage"><code>ccm_aes128_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fdigest"><code>ccm_aes128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fencrypt"><code>ccm_aes128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fencrypt_005fmessage"><code>ccm_aes128_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fset_005fkey"><code>ccm_aes128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fset_005fnonce"><code>ccm_aes128_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes128_005fupdate"><code>ccm_aes128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fdecrypt"><code>ccm_aes192_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fdecrypt_005fmessage"><code>ccm_aes192_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fdecrypt_005fmessage-1"><code>ccm_aes192_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fdigest"><code>ccm_aes192_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fencrypt"><code>ccm_aes192_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fencrypt_005fmessage"><code>ccm_aes192_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fset_005fkey"><code>ccm_aes192_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fset_005fnonce"><code>ccm_aes192_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes192_005fupdate"><code>ccm_aes192_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fdecrypt"><code>ccm_aes256_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fdigest"><code>ccm_aes256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fencrypt"><code>ccm_aes256_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fencrypt_005fmessage"><code>ccm_aes256_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fset_005fkey"><code>ccm_aes256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fset_005fnonce"><code>ccm_aes256_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005faes256_005fupdate"><code>ccm_aes256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fdecrypt"><code>ccm_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fdecrypt_005fmessage"><code>ccm_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fdigest"><code>ccm_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fencrypt"><code>ccm_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fencrypt_005fmessage"><code>ccm_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CCM_005fMAX_005fMSG_005fSIZE"><code>CCM_MAX_MSG_SIZE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fset_005fnonce"><code>ccm_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ccm_005fupdate"><code>ccm_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB-Modes">CFB Modes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB8-Mode">CFB8 Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB8_005fCTX"><code>CFB8_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cfb8_005fdecrypt"><code>cfb8_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB8_005fDECRYPT"><code>CFB8_DECRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cfb8_005fencrypt"><code>cfb8_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB8_005fENCRYPT"><code>CFB8_ENCRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB8_005fSET_005fIV"><code>CFB8_SET_IV</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB_005fCTX"><code>CFB_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cfb_005fdecrypt"><code>cfb_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB_005fDECRYPT"><code>CFB_DECRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cfb_005fencrypt"><code>cfb_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB_005fENCRYPT"><code>CFB_ENCRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFB_005fSET_005fIV_0028ctx_002c"><code>CFB_SET_IV(<var>ctx</var>,</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ChaCha">ChaCha</a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fcrypt"><code>chacha_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fcrypt32"><code>chacha_crypt32</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fdecrypt"><code>chacha_poly1305_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fdigest"><code>chacha_poly1305_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fencrypt"><code>chacha_poly1305_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fset_005fkey"><code>chacha_poly1305_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fset_005fnonce"><code>chacha_poly1305_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fpoly1305_005fupdate"><code>chacha_poly1305_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fset_005fcounter"><code>chacha_set_counter</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fset_005fcounter32"><code>chacha_set_counter32</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fset_005fkey"><code>chacha_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fset_005fnonce"><code>chacha_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chacha_005fset_005fnonce96"><code>chacha_set_nonce96</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cipher">Cipher</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cipher-functions">Cipher functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cipher-Block-Chaining">Cipher Block Chaining</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CBC">CBC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cipher-Feedback-8_002dbit-Mode">Cipher Feedback 8-bit Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cipher-Feedback-Mode">Cipher Feedback Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CFB-and-CFB8">CFB and CFB8</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CMAC">CMAC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CMAC_002d128">CMAC-128</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CMAC_002d64">CMAC-64</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes128_005fdigest"><code>cmac_aes128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes128_005fset_005fkey"><code>cmac_aes128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes128_005fupdate"><code>cmac_aes128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes256_005fdigest"><code>cmac_aes256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes256_005fset_005fkey"><code>cmac_aes256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005faes256_005fupdate"><code>cmac_aes256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005fdes3_005fdigest"><code>cmac_des3_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005fdes3_005fset_005fkey"><code>cmac_des3_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cmac_005fdes3_005fupdate"><code>cmac_des3_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Collision_002dresistant">Collision-resistant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-functions">Hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Conditional-entropy">Conditional entropy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Counter-Mode">Counter Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Counter-with-CBC_002dMAC-Mode">Counter with CBC-MAC Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTR-Mode">CTR Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctr_005fcrypt"><code>ctr_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTR_005fCRYPT"><code>CTR_CRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTR_005fCTX"><code>CTR_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTR_005fSET_005fCOUNTER"><code>CTR_SET_COUNTER</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CTR">CTR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Curve-25519">Curve 25519</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Curve-448">Curve 448</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-curve25519_005fmul"><code>curve25519_mul</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-curve25519_005fmul_005fg"><code>curve25519_mul_g</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-curve448_005fmul"><code>curve448_mul</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-curve448_005fmul_005fg"><code>curve448_mul_g</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-DES">DES</a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DES3">DES3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des3_005fdecrypt"><code>des3_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des3_005fencrypt"><code>des3_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des3_005fset_005fkey"><code>des3_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des_005fcheck_005fparity"><code>des_check_parity</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des_005fdecrypt"><code>des_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des_005fencrypt"><code>des_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des_005ffix_005fparity"><code>des_fix_parity</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-des_005fset_005fkey"><code>des_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fcompat_005fgenerate_005fkeypair"><code>dsa_compat_generate_keypair</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fgenerate_005fkeypair"><code>dsa_generate_keypair</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fgenerate_005fparams"><code>dsa_generate_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fparams"><code>dsa_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fparams_005fclear"><code>dsa_params_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fparams_005finit"><code>dsa_params_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fprivate_005fkey"><code>dsa_private_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fprivate_005fkey_005fclear"><code>dsa_private_key_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fprivate_005fkey_005finit"><code>dsa_private_key_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fpublic_005fkey"><code>dsa_public_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fpublic_005fkey_005fclear"><code>dsa_public_key_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fpublic_005fkey_005finit"><code>dsa_public_key_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha1_005fsign"><code>dsa_sha1_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha1_005fsign_005fdigest"><code>dsa_sha1_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha1_005fverify"><code>dsa_sha1_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha1_005fverify_005fdigest"><code>dsa_sha1_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha256_005fsign"><code>dsa_sha256_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha256_005fsign_005fdigest"><code>dsa_sha256_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha256_005fverify"><code>dsa_sha256_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsha256_005fverify_005fdigest"><code>dsa_sha256_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsign"><code>dsa_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsignature"><code>dsa_signature</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsignature_005fclear"><code>dsa_signature_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fsignature_005finit"><code>dsa_signature_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dsa_005fverify"><code>dsa_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DSA">DSA</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fdecrypt"><code>eax_aes128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fdigest"><code>eax_aes128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fencrypt"><code>eax_aes128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fset_005fkey"><code>eax_aes128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fset_005fnonce"><code>eax_aes128_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005faes128_005fupdate"><code>eax_aes128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fCTX"><code>EAX_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fdecrypt"><code>eax_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fDECRYPT"><code>EAX_DECRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fdigest"><code>eax_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fDIGEST"><code>EAX_DIGEST</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fencrypt"><code>eax_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fENCRYPT"><code>EAX_ENCRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fset_005fkey"><code>eax_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fSET_005fKEY"><code>EAX_SET_KEY</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fset_005fnonce"><code>eax_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fSET_005fNONCE"><code>EAX_SET_NONCE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eax_005fupdate"><code>eax_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EAX_005fUPDATE"><code>EAX_UPDATE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fpoint_005fclear"><code>ecc_point_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fpoint_005fget"><code>ecc_point_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fpoint_005finit"><code>ecc_point_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fpoint_005fset"><code>ecc_point_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fscalar_005fclear"><code>ecc_scalar_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fscalar_005fget"><code>ecc_scalar_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fscalar_005finit"><code>ecc_scalar_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecc_005fscalar_005fset"><code>ecc_scalar_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecdsa_005fgenerate_005fkeypair"><code>ecdsa_generate_keypair</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecdsa_005fsign"><code>ecdsa_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecdsa_005fverify"><code>ecdsa_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed25519_005fsha512_005fpublic_005fkey"><code>ed25519_sha512_public_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed25519_005fsha512_005fsign"><code>ed25519_sha512_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed25519_005fsha512_005fverify"><code>ed25519_sha512_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed448_005fshake256_005fpublic_005fkey"><code>ed448_shake256_public_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed448_005fshake256_005fsign"><code>ed448_shake256_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ed448_005fshake256_005fverify"><code>ed448_shake256_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eddsa">eddsa</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curve-25519-and-Curve-448">Curve 25519 and Curve 448</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Entropy">Entropy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Galois-Counter-Mode">Galois Counter Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM">GCM</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fdecrypt"><code>gcm_aes128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fdigest"><code>gcm_aes128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fencrypt"><code>gcm_aes128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fset_005fiv"><code>gcm_aes128_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fset_005fkey"><code>gcm_aes128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes128_005fupdate"><code>gcm_aes128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fdecrypt"><code>gcm_aes192_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fdigest"><code>gcm_aes192_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fencrypt"><code>gcm_aes192_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fset_005fiv"><code>gcm_aes192_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fset_005fkey"><code>gcm_aes192_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes192_005fupdate"><code>gcm_aes192_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fdecrypt"><code>gcm_aes256_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fdigest"><code>gcm_aes256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fencrypt"><code>gcm_aes256_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fset_005fiv"><code>gcm_aes256_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fset_005fkey"><code>gcm_aes256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes256_005fupdate"><code>gcm_aes256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fdecrypt"><code>gcm_aes_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fdigest"><code>gcm_aes_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fencrypt"><code>gcm_aes_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fset_005fiv"><code>gcm_aes_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fset_005fkey"><code>gcm_aes_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005faes_005fupdate"><code>gcm_aes_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fdecrypt"><code>gcm_camellia128_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fdigest"><code>gcm_camellia128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fencrypt"><code>gcm_camellia128_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fset_005fiv"><code>gcm_camellia128_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fset_005fkey"><code>gcm_camellia128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia128_005fupdate"><code>gcm_camellia128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia192_005fdigest"><code>gcm_camellia192_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fdecrypt"><code>gcm_camellia256_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fdigest"><code>gcm_camellia256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fencrypt"><code>gcm_camellia256_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fset_005fiv"><code>gcm_camellia256_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fset_005fkey"><code>gcm_camellia256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia256_005fupdate"><code>gcm_camellia256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fcamellia_005fdigest"><code>gcm_camellia_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fCTX"><code>GCM_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fdecrypt"><code>gcm_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fDECRYPT"><code>GCM_DECRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fdigest"><code>gcm_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fDIGEST"><code>GCM_DIGEST</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fencrypt"><code>gcm_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fENCRYPT"><code>GCM_ENCRYPT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fset_005fiv"><code>gcm_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fSET_005fIV"><code>GCM_SET_IV</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fset_005fkey"><code>gcm_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fSET_005fKEY"><code>GCM_SET_KEY</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcm_005fupdate"><code>gcm_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCM_005fUPDATE"><code>GCM_UPDATE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GOST-DSA">GOST DSA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GOST-hash">GOST hash</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gostdsa_005fsign"><code>gostdsa_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gostdsa_005fverify"><code>gostdsa_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gostdsa_005fvko"><code>gostdsa_vko</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94cp_005fdigest"><code>gosthash94cp_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94cp_005finit"><code>gosthash94cp_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94cp_005fupdate"><code>gosthash94cp_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94_005fdigest"><code>gosthash94_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94_005finit"><code>gosthash94_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gosthash94_005fupdate"><code>gosthash94_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-H">H</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hash-function">Hash function</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-functions">Hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HKDF">HKDF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hkdf_005fexpand"><code>hkdf_expand</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hkdf_005fextract"><code>hkdf_extract</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HMAC">HMAC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HMAC_005fCTX"><code>HMAC_CTX</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fdigest"><code>hmac_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HMAC_005fDIGEST"><code>HMAC_DIGEST</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fmd5_005fdigest"><code>hmac_md5_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fmd5_005fset_005fkey"><code>hmac_md5_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fmd5_005fupdate"><code>hmac_md5_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fripemd160_005fdigest"><code>hmac_ripemd160_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fripemd160_005fset_005fkey"><code>hmac_ripemd160_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fripemd160_005fupdate"><code>hmac_ripemd160_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fset_005fkey"><code>hmac_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HMAC_005fSET_005fKEY"><code>HMAC_SET_KEY</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha1_005fdigest"><code>hmac_sha1_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha1_005fset_005fkey"><code>hmac_sha1_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha1_005fupdate"><code>hmac_sha1_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha256_005fdigest"><code>hmac_sha256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha256_005fset_005fkey"><code>hmac_sha256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha256_005fupdate"><code>hmac_sha256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha512_005fdigest"><code>hmac_sha512_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha512_005fset_005fkey"><code>hmac_sha512_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsha512_005fupdate"><code>hmac_sha512_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsm3_005fdigest"><code>hmac_sm3_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsm3_005fset_005fkey"><code>hmac_sm3_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fsm3_005fupdate"><code>hmac_sm3_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hmac_005fupdate"><code>hmac_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-K">K</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-KDF">KDF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Key-Derivation-Function">Key Derivation Function</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Keyed-Hash-Function">Keyed Hash Function</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Keyed-hash-functions">Keyed hash functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAC">MAC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Keyed-hash-functions">Keyed hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md2_005fdigest"><code>md2_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md2_005finit"><code>md2_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md2_005fupdate"><code>md2_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md4_005fdigest"><code>md4_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md4_005finit"><code>md4_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md4_005fupdate"><code>md4_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md5_005fdigest"><code>md5_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md5_005finit"><code>md5_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-md5_005fupdate"><code>md5_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-memeql_005fsec"><code>memeql_sec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-functions">Miscellaneous functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-memxor"><code>memxor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-functions">Miscellaneous functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-memxor3"><code>memxor3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-functions">Miscellaneous functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Message-Authentication-Code">Message Authentication Code</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Keyed-hash-functions">Keyed hash functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-N">N</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005faead">nettle_aead</a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005faead-abstraction">nettle_aead abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005faeads"><code>nettle_aeads</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005faead-abstraction">nettle_aead abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fcipher">nettle_cipher</a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fciphers"><code>nettle_ciphers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fget_005faeads"><code>nettle_get_aeads</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005faead-abstraction">nettle_aead abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fget_005fciphers"><code>nettle_get_ciphers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fget_005fgost_005fgc256b_0028void_0029"><code>nettle_get_gost_gc256b(void)</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fget_005fgost_005fgc512a_0028void_0029"><code>nettle_get_gost_gc512a(void)</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GOSTDSA">GOSTDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fget_005fhashes"><code>nettle_get_hashes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fhash-abstraction">nettle_hash abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fhash">nettle_hash</a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fhash-abstraction">nettle_hash abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nettle_005fhashes"><code>nettle_hashes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fhash-abstraction">nettle_hash abstraction</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-O">O</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-One_002dway">One-way</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-functions">Hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-One_002dway-function">One-way function</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Public_002dkey-algorithms">Public-key algorithms</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Password-Based-Key-Derivation-Function">Password Based Key Derivation Function</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PBKDF">PBKDF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pbkdf2"><code>pbkdf2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PBKDF2"><code>PBKDF2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pbkdf2_005fhmac_005fsha1"><code>pbkdf2_hmac_sha1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pbkdf2_005fhmac_005fsha256"><code>pbkdf2_hmac_sha256</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pbkdf2_005fhmac_005fsha384"><code>pbkdf2_hmac_sha384</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pbkdf2_005fhmac_005fsha512"><code>pbkdf2_hmac_sha512</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_00235">PKCS #5</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-derivation-functions">Key derivation functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-poly1305_005faes_005fdigest"><code>poly1305_aes_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Poly1305">Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-poly1305_005faes_005fset_005fkey"><code>poly1305_aes_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Poly1305">Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-poly1305_005faes_005fset_005fnonce"><code>poly1305_aes_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Poly1305">Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-poly1305_005faes_005fupdate"><code>poly1305_aes_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Poly1305">Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Public-Key-Cryptography">Public Key Cryptography</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Public_002dkey-algorithms">Public-key algorithms</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-R">R</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Randomness">Randomness</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RC2">RC2</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RC4">RC4</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arcfour">Arcfour</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ripemd160_005fdigest"><code>ripemd160_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ripemd160_005finit"><code>ripemd160_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ripemd160_005fupdate"><code>ripemd160_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fcompute_005froot"><code>rsa_compute_root</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fcompute_005froot_005ftr_0028const"><code>rsa_compute_root_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fdecrypt"><code>rsa_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fdecrypt_005ftr"><code>rsa_decrypt_tr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fencrypt"><code>rsa_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fgenerate_005fkeypair"><code>rsa_generate_keypair</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fsign"><code>rsa_md5_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fsign_005fdigest"><code>rsa_md5_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fsign_005fdigest_005ftr_0028const"><code>rsa_md5_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fsign_005ftr_0028const"><code>rsa_md5_sign_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fverify"><code>rsa_md5_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fmd5_005fverify_005fdigest"><code>rsa_md5_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpkcs1_005fsign_0028const"><code>rsa_pkcs1_sign(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpkcs1_005fsign_005ftr_0028const"><code>rsa_pkcs1_sign_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpkcs1_005fverify_0028const"><code>rsa_pkcs1_verify(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fprivate_005fkey"><code>rsa_private_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fprivate_005fkey_005fclear"><code>rsa_private_key_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fprivate_005fkey_005finit"><code>rsa_private_key_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fprivate_005fkey_005fprepare"><code>rsa_private_key_prepare</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha256_005fsign_005fdigest_005ftr_0028const"><code>rsa_pss_sha256_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha256_005fverify_005fdigest"><code>rsa_pss_sha256_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha384_005fsign_005fdigest_005ftr_0028const"><code>rsa_pss_sha384_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha384_005fverify_005fdigest"><code>rsa_pss_sha384_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha512_005fsign_005fdigest_005ftr_0028const"><code>rsa_pss_sha512_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpss_005fsha512_005fverify_005fdigest"><code>rsa_pss_sha512_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpublic_005fkey"><code>rsa_public_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpublic_005fkey_005fclear"><code>rsa_public_key_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpublic_005fkey_005finit"><code>rsa_public_key_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fpublic_005fkey_005fprepare"><code>rsa_public_key_prepare</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fsign"><code>rsa_sha1_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fsign_005fdigest"><code>rsa_sha1_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fsign_005fdigest_005ftr_0028const"><code>rsa_sha1_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fsign_005ftr_0028const"><code>rsa_sha1_sign_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fverify"><code>rsa_sha1_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha1_005fverify_005fdigest"><code>rsa_sha1_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fsign"><code>rsa_sha256_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fsign_005fdigest"><code>rsa_sha256_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fsign_005fdigest_005ftr_0028const"><code>rsa_sha256_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fsign_005ftr_0028const"><code>rsa_sha256_sign_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fverify"><code>rsa_sha256_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha256_005fverify_005fdigest"><code>rsa_sha256_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fsign"><code>rsa_sha512_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fsign_005fdigest"><code>rsa_sha512_sign_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fsign_005fdigest_005ftr_0028const"><code>rsa_sha512_sign_digest_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fsign_005ftr_0028const"><code>rsa_sha512_sign_tr(const</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fverify"><code>rsa_sha512_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rsa_005fsha512_005fverify_005fdigest"><code>rsa_sha512_verify_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#RSA">RSA</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Salsa20">Salsa20</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20r12_005fcrypt"><code>salsa20r12_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20_005f128_005fset_005fkey"><code>salsa20_128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20_005f256_005fset_005fkey"><code>salsa20_256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20_005fcrypt"><code>salsa20_crypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20_005fset_005fkey"><code>salsa20_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-salsa20_005fset_005fnonce"><code>salsa20_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Serpent">Serpent</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Serpent">Serpent</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-serpent_005fdecrypt"><code>serpent_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Serpent">Serpent</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-serpent_005fencrypt"><code>serpent_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Serpent">Serpent</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-serpent_005fset_005fkey"><code>serpent_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Serpent">Serpent</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha1_005fdigest"><code>sha1_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha1_005finit"><code>sha1_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha1_005fupdate"><code>sha1_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha224_005fdigest"><code>sha224_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha224_005finit"><code>sha224_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha224_005fupdate"><code>sha224_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha256_005fdigest"><code>sha256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha256_005finit"><code>sha256_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha256_005fupdate"><code>sha256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHA3">SHA3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha384_005fdigest"><code>sha384_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha384_005finit"><code>sha384_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha384_005fupdate"><code>sha384_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f224_005fdigest"><code>sha3_224_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f224_005finit"><code>sha3_224_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f224_005fupdate"><code>sha3_224_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f256_005fdigest"><code>sha3_256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f256_005finit"><code>sha3_256_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f256_005fshake"><code>sha3_256_shake</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f256_005fupdate"><code>sha3_256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f384_005fdigest"><code>sha3_384_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f384_005finit"><code>sha3_384_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f384_005fupdate"><code>sha3_384_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f512_005fdigest"><code>sha3_512_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f512_005finit"><code>sha3_512_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha3_005f512_005fupdate"><code>sha3_512_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f224_005fdigest"><code>sha512_224_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f224_005finit"><code>sha512_224_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f224_005fupdate"><code>sha512_224_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f256_005fdigest"><code>sha512_256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f256_005finit"><code>sha512_256_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005f256_005fupdate"><code>sha512_256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005fdigest"><code>sha512_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005finit"><code>sha512_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sha512_005fupdate"><code>sha512_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHAKE">SHAKE</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Side_002dchannel-attack">Side-channel attack</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Side_002dchannel-silence">Side-channel silence</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIV-mode">SIV mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIV_002dCMAC-mode">SIV-CMAC mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes128_005fdecrypt_005fmessage"><code>siv_cmac_aes128_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes128_005fencrypt_005fmessage"><code>siv_cmac_aes128_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes128_005fset_005fkey"><code>siv_cmac_aes128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes256_005fdecrypt_005fmessage"><code>siv_cmac_aes256_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes256_005fencrypt_005fmessage"><code>siv_cmac_aes256_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-siv_005fcmac_005faes256_005fset_005fkey"><code>siv_cmac_aes256_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sm3_005fdigest"><code>sm3_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sm3_005finit"><code>sm3_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sm3_005fupdate"><code>sm3_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stream-Cipher">Stream Cipher</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cipher-functions">Cipher functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog256_005fdigest"><code>streebog256_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog256_005finit"><code>streebog256_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog256_005fupdate"><code>streebog256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog512_005fdigest"><code>streebog512_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog512_005finit"><code>streebog512_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streebog512_005fupdate"><code>streebog512_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-aes128_005fctx"><code>struct aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-aes192_005fctx"><code>struct aes192_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-aes256_005fctx"><code>struct aes256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-aes_005fctx"><code>struct aes_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#AES">AES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-arcfour_005fctx"><code>struct arcfour_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arcfour">Arcfour</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-arctwo_005fctx"><code>struct arctwo_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Arctwo">Arctwo</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-base16_005fdecode_005fctx"><code>struct base16_decode_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-base64_005fdecode_005fctx"><code>struct base64_decode_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-base64_005fencode_005fctx"><code>struct base64_encode_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ASCII-encoding">ASCII encoding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-blowfish_005fctx"><code>struct blowfish_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Blowfish">Blowfish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-camellia128_005fctx"><code>struct camellia128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-camellia192_005fctx"><code>struct camellia192_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-camellia256_005fctx"><code>struct camellia256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-camellia_005fctx"><code>struct camellia_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Camellia">Camellia</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-cast128_005fctx"><code>struct cast128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CAST128">CAST128</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ccm_005faes128_005fctx"><code>struct ccm_aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ccm_005faes192_005fctx"><code>struct ccm_aes192_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ccm_005faes256_005fctx"><code>struct ccm_aes256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ccm_005fctx"><code>struct ccm_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CCM">CCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-chacha_005fctx"><code>struct chacha_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha">ChaCha</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-chacha_005fpoly1305_005fctx"><code>struct chacha_poly1305_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ChaCha_002dPoly1305">ChaCha-Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-cmac_005faes128_005fctx"><code>struct cmac_aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-cmac_005faes256_005fctx"><code>struct cmac_aes256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-cmac_005fdes3_005fctx"><code>struct cmac_des3_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#CMAC">CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-des3_005fctx"><code>struct des3_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-des_005fctx"><code>struct des_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES">DES</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-eax_005faes128_005fctx"><code>struct eax_aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-eax_005fctx"><code>struct eax_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-eax_005fkey"><code>struct eax_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#EAX">EAX</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ecc_005fpoint"><code>struct ecc_point</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ecc_005fscalar"><code>struct ecc_scalar</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ECDSA">ECDSA</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005faes128_005fctx"><code>struct gcm_aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005faes192_005fctx"><code>struct gcm_aes192_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005faes256_005fctx"><code>struct gcm_aes256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005faes_005fctx"><code>struct gcm_aes_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005fcamellia128_005fctx"><code>struct gcm_camellia128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005fcamellia256_005fctx"><code>struct gcm_camellia256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005fctx"><code>struct gcm_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gcm_005fkey"><code>struct gcm_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#GCM">GCM</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gosthash94cp_005fctx"><code>struct gosthash94cp_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-gosthash94_005fctx"><code>struct gosthash94_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fmd5_005fctx"><code>struct hmac_md5_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fripemd160_005fctx"><code>struct hmac_ripemd160_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fsha1_005fctx"><code>struct hmac_sha1_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fsha256_005fctx"><code>struct hmac_sha256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fsha512_005fctx"><code>struct hmac_sha512_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-hmac_005fsm3_005fctx"><code>struct hmac_sm3_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#HMAC">HMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-md2_005fctx"><code>struct md2_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-md4_005fctx"><code>struct md4_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-md5_005fctx"><code>struct md5_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-nettle_005faead"><code><code>struct nettle_aead</code></code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005faead-abstraction">nettle_aead abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-nettle_005fcipher"><code><code>struct nettle_cipher</code></code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fcipher-abstraction">nettle_cipher abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-nettle_005fhash"><code><code>struct nettle_hash</code></code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#nettle_005fhash-abstraction">nettle_hash abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-poly1305_005faes_005fctx"><code>struct poly1305_aes_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Poly1305">Poly1305</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-ripemd160_005fctx"><code>struct ripemd160_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-salsa20_005fctx"><code>struct salsa20_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Salsa20">Salsa20</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-serpent_005fctx"><code>struct serpent_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Serpent">Serpent</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha1_005fctx"><code>struct sha1_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legacy-hash-functions">Legacy hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha224_005fctx"><code>struct sha224_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha256_005fctx"><code>struct sha256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha384_005fctx"><code>struct sha384_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha3_005f224_005fctx"><code>struct sha3_224_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha3_005f256_005fctx"><code>struct sha3_256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha3_005f384_005fctx"><code>struct sha3_384_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha3_005f512_005fctx"><code>struct sha3_512_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha512_005f224_005fctx"><code>struct sha512_224_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha512_005f256_005fctx"><code>struct sha512_256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sha512_005fctx"><code>struct sha512_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recommended-hash-functions">Recommended hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-siv_005fcmac_005faes128_005fctx"><code>struct siv_cmac_aes128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-siv_005fcmac_005faes256_005fctx"><code>struct siv_cmac_aes256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SIV_002dCMAC">SIV-CMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-sm3_005fctx"><code>struct sm3_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-streebog256_005fctx"><code>struct streebog256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-streebog512_005fctx"><code>struct streebog512_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-hash-functions">Miscellaneous hash functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-twofish_005fctx"><code>struct twofish_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Twofish">Twofish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-umac128_005fctx"><code>struct umac128_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-umac32_005fctx"><code>struct umac32_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-umac64_005fctx"><code>struct umac64_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-umac96_005fctx"><code>struct umac96_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-xts_005faes128_005fkey"><code>struct xts_aes128_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-xts_005faes256_005fkey"><code>struct xts_aes256_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-yarrow256_005fctx"><code>struct yarrow256_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-yarrow_005fkey_005fevent_005fctx"><code>struct yarrow_key_event_ctx</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-struct-yarrow_005fsource"><code>struct yarrow_source</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Triple_002dDES">Triple-DES</a>:</td><td>&nbsp;</td><td valign="top"><a href="#DES3">DES3</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Twofish">Twofish</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Twofish">Twofish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-twofish_005fdecrypt"><code>twofish_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Twofish">Twofish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-twofish_005fencrypt"><code>twofish_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Twofish">Twofish</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-twofish_005fset_005fkey"><code>twofish_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Twofish">Twofish</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-U">U</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-UMAC">UMAC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac128_005fdigest"><code>umac128_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac128_005fset_005fkey"><code>umac128_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac128_005fset_005fnonce"><code>umac128_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac128_005fupdate"><code>umac128_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac32_005fdigest"><code>umac32_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac32_005fset_005fkey"><code>umac32_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac32_005fset_005fnonce"><code>umac32_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac32_005fupdate"><code>umac32_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac64_005fdigest"><code>umac64_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac64_005fset_005fkey"><code>umac64_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac64_005fset_005fnonce"><code>umac64_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac64_005fupdate"><code>umac64_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac96_005fdigest"><code>umac96_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac96_005fset_005fkey"><code>umac96_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac96_005fset_005fnonce"><code>umac96_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umac96_005fupdate"><code>umac96_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#UMAC">UMAC</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-X">X</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-XEX_002dbased-tweaked_002dcodebook-mode-with-ciphertext-stealing">XEX-based tweaked-codebook mode with ciphertext stealing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-XTS-Mode">XTS Mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes128_005fdecrypt_005fmessage_0028struct"><code>xts_aes128_decrypt_message(struct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes128_005fencrypt_005fmessage_0028struct"><code>xts_aes128_encrypt_message(struct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes128_005fset_005fdecrypt_005fkey"><code>xts_aes128_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes128_005fset_005fencrypt_005fkey"><code>xts_aes128_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes256_005fdecrypt_005fmessage_0028struct"><code>xts_aes256_decrypt_message(struct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes256_005fencrypt_005fmessage_0028struct"><code>xts_aes256_encrypt_message(struct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes256_005fset_005fdecrypt_005fkey"><code>xts_aes256_set_decrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005faes256_005fset_005fencrypt_005fkey"><code>xts_aes256_set_encrypt_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005fdecrypt_005fmessage"><code>xts_decrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xts_005fencrypt_005fmessage"><code>xts_encrypt_message</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#XTS">XTS</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-Y">Y</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005ffast_005freseed"><code>yarrow256_fast_reseed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005finit"><code>yarrow256_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005fis_005fseeded"><code>yarrow256_is_seeded</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005fneeded_005fsources"><code>yarrow256_needed_sources</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005frandom"><code>yarrow256_random</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005fseed"><code>yarrow256_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005fslow_005freseed"><code>yarrow256_slow_reseed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow256_005fupdate"><code>yarrow256_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow_005fkey_005fevent_005festimate"><code>yarrow_key_event_estimate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yarrow_005fkey_005fevent_005finit"><code>yarrow_key_event_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Randomness">Randomness</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_symbol-1"><b>3</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="SEC_Foot"></span>
<div class="header">
<p>
 &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Actually, the computation is not done like this, it is
done more efficiently using <code>p</code>, <code>q</code> and the Chinese remainder
theorem (<acronym>CRT</acronym>). But the result is the same.</p>
<hr>



</body>
</html>
