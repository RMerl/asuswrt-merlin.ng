/*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (tcpreplay_opts.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    ../../src/tcpreplay_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 42:1:17 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the tcpreplay author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The tcpreplay program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 2000-2022 Aaron Turner and Fred Klassen, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the GNU General Public License,
 *  version 3 or later <http://gnu.org/licenses/gpl.html>
 *
 *  tcpreplay is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  tcpreplay is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __doxygen__
#define OPTION_CODE_COMPILE 1
#include "tcpreplay_opts.h"
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef  __cplusplus
extern "C" {
#endif
extern FILE * option_usage_fp;
#define zCopyright      (tcpreplay_opt_strs+0)
#define zLicenseDescrip (tcpreplay_opt_strs+283)

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpreplay.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


#ifndef NULL
#  define NULL 0
#endif

/**
 *  static const strings for tcpreplay options
 */
static char const tcpreplay_opt_strs[3902] =
/*     0 */ "tcpreplay (tcpreplay)\n"
            "Copyright (C) 2000-2022 Aaron Turner and Fred Klassen, all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the GNU General Public License,\n"
            "version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"
/*   283 */ "tcpreplay is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "tcpreplay is distributed in the hope that it will be useful, but WITHOUT\n"
            "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n"
            "FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n"
            "more details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   890 */ "Enable debugging output\0"
/*   914 */ "DBUG\0"
/*   919 */ "dbug\0"
/*   924 */ "Quiet mode\0"
/*   935 */ "QUIET\0"
/*   941 */ "quiet\0"
/*   947 */ "Select packet timing mode: select, ioport, gtod, nano\0"
/*  1001 */ "TIMER\0"
/*  1007 */ "timer\0"
/*  1013 */ "gtod\0"
/*  1018 */ "Sleep for no more then X milliseconds between packets\0"
/*  1072 */ "MAXSLEEP\0"
/*  1081 */ "maxsleep\0"
/*  1090 */ "Print decoded packets via tcpdump to STDOUT\0"
/*  1134 */ "VERBOSE\0"
/*  1142 */ "verbose\0"
/*  1150 */ "Arguments passed to tcpdump decoder\0"
/*  1186 */ "DECODE\0"
/*  1193 */ "decode\0"
/*  1200 */ "Preloads packets into RAM before sending\0"
/*  1241 */ "PRELOAD_PCAP\0"
/*  1254 */ "preload-pcap\0"
/*  1267 */ "Split traffic via a tcpprep cache file\0"
/*  1306 */ "CACHEFILE\0"
/*  1316 */ "cachefile\0"
/*  1326 */ "Replay two files at a time from a network tap\0"
/*  1372 */ "DUALFILE\0"
/*  1381 */ "dualfile\0"
/*  1390 */ "Client to server/RX/primary traffic output interface\0"
/*  1443 */ "INTF1\0"
/*  1449 */ "intf1\0"
/*  1455 */ "Server to client/TX/secondary traffic output interface\0"
/*  1510 */ "INTF2\0"
/*  1516 */ "intf2\0"
/*  1522 */ "List available network interfaces and exit\0"
/*  1565 */ "LISTNICS\0"
/*  1574 */ "listnics\0"
/*  1583 */ "Loop through the capture file X times\0"
/*  1621 */ "LOOP\0"
/*  1626 */ "loop\0"
/*  1631 */ "Delay between loops in milliseconds\0"
/*  1667 */ "LOOPDELAY_MS\0"
/*  1680 */ "loopdelay-ms\0"
/*  1693 */ "Override the snaplen and use the actual packet len\0"
/*  1744 */ "PKTLEN\0"
/*  1751 */ "pktlen\0"
/*  1758 */ "Limit the number of packets to send\0"
/*  1794 */ "LIMIT\0"
/*  1800 */ "limit\0"
/*  1806 */ "Limit the number of seconds to send\0"
/*  1842 */ "DURATION\0"
/*  1851 */ "duration\0"
/*  1860 */ "Modify replay speed to a given multiple\0"
/*  1900 */ "MULTIPLIER\0"
/*  1911 */ "multiplier\0"
/*  1922 */ "Replay packets at a given packets/sec\0"
/*  1960 */ "PPS\0"
/*  1964 */ "pps\0"
/*  1968 */ "Replay packets at a given Mbps\0"
/*  1999 */ "MBPS\0"
/*  2004 */ "mbps\0"
/*  2009 */ "Replay packets as fast as possible\0"
/*  2044 */ "TOPSPEED\0"
/*  2053 */ "topspeed\0"
/*  2062 */ "Replay one packet at a time for each user input\0"
/*  2110 */ "ONEATATIME\0"
/*  2121 */ "oneatatime\0"
/*  2132 */ "Number of packets to send for each time interval\0"
/*  2181 */ "PPS_MULTI\0"
/*  2191 */ "pps-multi\0"
/*  2201 */ "Modify IP addresses each loop iteration to generate unique flows\0"
/*  2266 */ "UNIQUE_IP\0"
/*  2276 */ "unique-ip\0"
/*  2286 */ "Number of times to loop before assigning new unique ip\0"
/*  2341 */ "UNIQUE_IP_LOOPS\0"
/*  2357 */ "unique-ip-loops\0"
/*  2373 */ "Write packets directly to netmap enabled network adapter\0"
/*  2430 */ "NETMAP\0"
/*  2437 */ "netmap\0"
/*  2444 */ "Netmap startup delay\0"
/*  2465 */ "NM_DELAY\0"
/*  2474 */ "nm-delay\0"
/*  2483 */ "Suppress printing and tracking flow count, rates and expirations\0"
/*  2548 */ "NO_FLOW_STATS\0"
/*  2562 */ "no-flow-stats\0"
/*  2576 */ "Number of inactive seconds before a flow is considered expired\0"
/*  2639 */ "FLOW_EXPIRY\0"
/*  2651 */ "flow-expiry\0"
/*  2663 */ "Print the PID of tcpreplay at startup\0"
/*  2701 */ "PID\0"
/*  2705 */ "pid\0"
/*  2709 */ "Print statistics every X seconds, or every loop if '0'\0"
/*  2764 */ "STATS\0"
/*  2770 */ "stats\0"
/*  2776 */ "Print version information\0"
/*  2802 */ "VERSION\0"
/*  2810 */ "version\0"
/*  2818 */ "Display less usage information and exit\0"
/*  2858 */ "LESS_HELP\0"
/*  2868 */ "less-help\0"
/*  2878 */ "display extended usage information and exit\0"
/*  2922 */ "help\0"
/*  2927 */ "extended usage information passed thru pager\0"
/*  2972 */ "more-help\0"
/*  2982 */ "save the option state to a config file\0"
/*  3021 */ "save-opts\0"
/*  3031 */ "load options from a config file\0"
/*  3063 */ "LOAD_OPTS\0"
/*  3073 */ "no-load-opts\0"
/*  3086 */ "no\0"
/*  3089 */ "TCPREPLAY\0"
/*  3099 */ "tcpreplay (tcpreplay) - Replay network traffic stored in pcap files\n"
            "Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... \\\n"
            "\t\t<pcap_file(s)> | <pcap_dir(s)>\n\0"
/*  3260 */ "$$/\0"
/*  3264 */ ".tcpreplayrc\0"
/*  3277 */ "tcpreplay-users@lists.sourceforge.net\0"
/*  3315 */ "tcpreplay is a tool for replaying network traffic from files saved with\n"
            "tcpdump or other tools which write pcap(3) files.\n\0"
/*  3438 */ "The basic operation of tcpreplay is to resend all packets from the input\n"
            "file(s) at the speed at which they were recorded, or a specified data rate,\n"
            "up to as fast as the hardware is capable.\n\n"
            "Optionally, the traffic can be split between two interfaces, written to\n"
            "files, filtered and edited in various ways, providing the means to test\n"
            "firewalls, NIDS and other network devices.\n\n"
            "For more details, please see the Tcpreplay Manual at:\n"
            "http://tcpreplay.appneta.com\n";

/**
 *  dbug option description:
 */
#ifdef DEBUG
/** Descriptive text for the dbug option */
#define DBUG_DESC      (tcpreplay_opt_strs+890)
/** Upper-cased name for the dbug option */
#define DBUG_NAME      (tcpreplay_opt_strs+914)
/** Name string for the dbug option */
#define DBUG_name      (tcpreplay_opt_strs+919)
/** The compiled in default value for the dbug option argument */
#define DBUG_DFT_ARG   ((char const*)0)
/** Compiled in flag settings for the dbug option */
#define DBUG_FLAGS     (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable dbug */
#define DBUG_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define DBUG_DFT_ARG   NULL
#define DBUG_NAME      NULL
#define DBUG_DESC      NULL
#define DBUG_name      NULL
#endif  /* DEBUG */

/**
 *  quiet option description:
 */
/** Descriptive text for the quiet option */
#define QUIET_DESC      (tcpreplay_opt_strs+924)
/** Upper-cased name for the quiet option */
#define QUIET_NAME      (tcpreplay_opt_strs+935)
/** Name string for the quiet option */
#define QUIET_name      (tcpreplay_opt_strs+941)
/** Compiled in flag settings for the quiet option */
#define QUIET_FLAGS     (OPTST_DISABLED)

/**
 *  timer option description:
 */
/** Descriptive text for the timer option */
#define TIMER_DESC      (tcpreplay_opt_strs+947)
/** Upper-cased name for the timer option */
#define TIMER_NAME      (tcpreplay_opt_strs+1001)
/** Name string for the timer option */
#define TIMER_name      (tcpreplay_opt_strs+1007)
/** The compiled in default value for the timer option argument */
#define TIMER_DFT_ARG   (tcpreplay_opt_strs+1013)
/** Compiled in flag settings for the timer option */
#define TIMER_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  maxsleep option description:
 */
/** Descriptive text for the maxsleep option */
#define MAXSLEEP_DESC      (tcpreplay_opt_strs+1018)
/** Upper-cased name for the maxsleep option */
#define MAXSLEEP_NAME      (tcpreplay_opt_strs+1072)
/** Name string for the maxsleep option */
#define MAXSLEEP_name      (tcpreplay_opt_strs+1081)
/** The compiled in default value for the maxsleep option argument */
#define MAXSLEEP_DFT_ARG   ((char const*)0)
/** Compiled in flag settings for the maxsleep option */
#define MAXSLEEP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  verbose option description:
 */
#ifdef ENABLE_VERBOSE
/** Descriptive text for the verbose option */
#define VERBOSE_DESC      (tcpreplay_opt_strs+1090)
/** Upper-cased name for the verbose option */
#define VERBOSE_NAME      (tcpreplay_opt_strs+1134)
/** Name string for the verbose option */
#define VERBOSE_name      (tcpreplay_opt_strs+1142)
/** Compiled in flag settings for the verbose option */
#define VERBOSE_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable verbose */
#define VERBOSE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define VERBOSE_NAME      NULL
#define VERBOSE_DESC      NULL
#define VERBOSE_name      NULL
#endif  /* ENABLE_VERBOSE */

/**
 *  decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
/** Descriptive text for the decode option */
#define DECODE_DESC      (tcpreplay_opt_strs+1150)
/** Upper-cased name for the decode option */
#define DECODE_NAME      (tcpreplay_opt_strs+1186)
/** Name string for the decode option */
#define DECODE_name      (tcpreplay_opt_strs+1193)
/** Other options that are required by the decode option */
static int const aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
/** Compiled in flag settings for the decode option */
#define DECODE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable decode */
#define DECODE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define DECODE_NAME      NULL
#define DECODE_DESC      NULL
#define DECODE_name      NULL
#endif  /* ENABLE_VERBOSE */

/**
 *  preload_pcap option description:
 */
/** Descriptive text for the preload_pcap option */
#define PRELOAD_PCAP_DESC      (tcpreplay_opt_strs+1200)
/** Upper-cased name for the preload_pcap option */
#define PRELOAD_PCAP_NAME      (tcpreplay_opt_strs+1241)
/** Name string for the preload_pcap option */
#define PRELOAD_PCAP_name      (tcpreplay_opt_strs+1254)
/** Compiled in flag settings for the preload_pcap option */
#define PRELOAD_PCAP_FLAGS     (OPTST_DISABLED)

/**
 *  cachefile option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the cachefile option */
#define CACHEFILE_DESC      (tcpreplay_opt_strs+1267)
/** Upper-cased name for the cachefile option */
#define CACHEFILE_NAME      (tcpreplay_opt_strs+1306)
/** Name string for the cachefile option */
#define CACHEFILE_name      (tcpreplay_opt_strs+1316)
/** Other options that are required by the cachefile option */
static int const aCachefileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
/** Other options that appear in conjunction with the cachefile option */
static int const aCachefileCantList[] = {
    INDEX_OPT_DUALFILE, NO_EQUIVALENT };
/** Compiled in flag settings for the cachefile option */
#define CACHEFILE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  dualfile option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the dualfile option */
#define DUALFILE_DESC      (tcpreplay_opt_strs+1326)
/** Upper-cased name for the dualfile option */
#define DUALFILE_NAME      (tcpreplay_opt_strs+1372)
/** Name string for the dualfile option */
#define DUALFILE_name      (tcpreplay_opt_strs+1381)
/** Other options that are required by the dualfile option */
static int const aDualfileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
/** Other options that appear in conjunction with the dualfile option */
static int const aDualfileCantList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
/** Compiled in flag settings for the dualfile option */
#define DUALFILE_FLAGS     (OPTST_DISABLED)

/**
 *  intf1 option description:
 */
/** Descriptive text for the intf1 option */
#define INTF1_DESC      (tcpreplay_opt_strs+1390)
/** Upper-cased name for the intf1 option */
#define INTF1_NAME      (tcpreplay_opt_strs+1443)
/** Name string for the intf1 option */
#define INTF1_name      (tcpreplay_opt_strs+1449)
/** Compiled in flag settings for the intf1 option */
#define INTF1_FLAGS     (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  intf2 option description:
 */
/** Descriptive text for the intf2 option */
#define INTF2_DESC      (tcpreplay_opt_strs+1455)
/** Upper-cased name for the intf2 option */
#define INTF2_NAME      (tcpreplay_opt_strs+1510)
/** Name string for the intf2 option */
#define INTF2_name      (tcpreplay_opt_strs+1516)
/** Compiled in flag settings for the intf2 option */
#define INTF2_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
/** Descriptive text for the listnics option */
#define LISTNICS_DESC      (tcpreplay_opt_strs+1522)
/** Upper-cased name for the listnics option */
#define LISTNICS_NAME      (tcpreplay_opt_strs+1565)
/** Name string for the listnics option */
#define LISTNICS_name      (tcpreplay_opt_strs+1574)
/** Compiled in flag settings for the listnics option */
#define LISTNICS_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable listnics */
#define LISTNICS_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define LISTNICS_NAME      NULL
#define LISTNICS_DESC      NULL
#define LISTNICS_name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/**
 *  loop option description:
 */
/** Descriptive text for the loop option */
#define LOOP_DESC      (tcpreplay_opt_strs+1583)
/** Upper-cased name for the loop option */
#define LOOP_NAME      (tcpreplay_opt_strs+1621)
/** Name string for the loop option */
#define LOOP_name      (tcpreplay_opt_strs+1626)
/** The compiled in default value for the loop option argument */
#define LOOP_DFT_ARG   ((char const*)1)
/** Compiled in flag settings for the loop option */
#define LOOP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  loopdelay-ms option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the loopdelay-ms option */
#define LOOPDELAY_MS_DESC      (tcpreplay_opt_strs+1631)
/** Upper-cased name for the loopdelay-ms option */
#define LOOPDELAY_MS_NAME      (tcpreplay_opt_strs+1667)
/** Name string for the loopdelay-ms option */
#define LOOPDELAY_MS_name      (tcpreplay_opt_strs+1680)
/** The compiled in default value for the loopdelay-ms option argument */
#define LOOPDELAY_MS_DFT_ARG   ((char const*)0)
/** Other options that are required by the loopdelay-ms option */
static int const aLoopdelay_MsMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
/** Compiled in flag settings for the loopdelay-ms option */
#define LOOPDELAY_MS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  pktlen option description:
 */
/** Descriptive text for the pktlen option */
#define PKTLEN_DESC      (tcpreplay_opt_strs+1693)
/** Upper-cased name for the pktlen option */
#define PKTLEN_NAME      (tcpreplay_opt_strs+1744)
/** Name string for the pktlen option */
#define PKTLEN_name      (tcpreplay_opt_strs+1751)
/** Compiled in flag settings for the pktlen option */
#define PKTLEN_FLAGS     (OPTST_DISABLED)

/**
 *  limit option description:
 */
/** Descriptive text for the limit option */
#define LIMIT_DESC      (tcpreplay_opt_strs+1758)
/** Upper-cased name for the limit option */
#define LIMIT_NAME      (tcpreplay_opt_strs+1794)
/** Name string for the limit option */
#define LIMIT_name      (tcpreplay_opt_strs+1800)
/** The compiled in default value for the limit option argument */
#define LIMIT_DFT_ARG   ((char const*)-1)
/** Compiled in flag settings for the limit option */
#define LIMIT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  duration option description:
 */
/** Descriptive text for the duration option */
#define DURATION_DESC      (tcpreplay_opt_strs+1806)
/** Upper-cased name for the duration option */
#define DURATION_NAME      (tcpreplay_opt_strs+1842)
/** Name string for the duration option */
#define DURATION_name      (tcpreplay_opt_strs+1851)
/** The compiled in default value for the duration option argument */
#define DURATION_DFT_ARG   ((char const*)-1)
/** Compiled in flag settings for the duration option */
#define DURATION_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  multiplier option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the multiplier option */
#define MULTIPLIER_DESC      (tcpreplay_opt_strs+1860)
/** Upper-cased name for the multiplier option */
#define MULTIPLIER_NAME      (tcpreplay_opt_strs+1900)
/** Name string for the multiplier option */
#define MULTIPLIER_name      (tcpreplay_opt_strs+1911)
/** Other options that appear in conjunction with the multiplier option */
static int const aMultiplierCantList[] = {
    INDEX_OPT_PPS,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
/** Compiled in flag settings for the multiplier option */
#define MULTIPLIER_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  pps option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the pps option */
#define PPS_DESC      (tcpreplay_opt_strs+1922)
/** Upper-cased name for the pps option */
#define PPS_NAME      (tcpreplay_opt_strs+1960)
/** Name string for the pps option */
#define PPS_name      (tcpreplay_opt_strs+1964)
/** Other options that appear in conjunction with the pps option */
static int const aPpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
/** Compiled in flag settings for the pps option */
#define PPS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  mbps option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the mbps option */
#define MBPS_DESC      (tcpreplay_opt_strs+1968)
/** Upper-cased name for the mbps option */
#define MBPS_NAME      (tcpreplay_opt_strs+1999)
/** Name string for the mbps option */
#define MBPS_name      (tcpreplay_opt_strs+2004)
/** Other options that appear in conjunction with the mbps option */
static int const aMbpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
/** Compiled in flag settings for the mbps option */
#define MBPS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  topspeed option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the topspeed option */
#define TOPSPEED_DESC      (tcpreplay_opt_strs+2009)
/** Upper-cased name for the topspeed option */
#define TOPSPEED_NAME      (tcpreplay_opt_strs+2044)
/** Name string for the topspeed option */
#define TOPSPEED_name      (tcpreplay_opt_strs+2053)
/** Other options that appear in conjunction with the topspeed option */
static int const aTopspeedCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME, NO_EQUIVALENT };
/** Compiled in flag settings for the topspeed option */
#define TOPSPEED_FLAGS     (OPTST_DISABLED)

/**
 *  oneatatime option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the oneatatime option */
#define ONEATATIME_DESC      (tcpreplay_opt_strs+2062)
/** Upper-cased name for the oneatatime option */
#define ONEATATIME_NAME      (tcpreplay_opt_strs+2110)
/** Name string for the oneatatime option */
#define ONEATATIME_name      (tcpreplay_opt_strs+2121)
/** Other options that appear in conjunction with the oneatatime option */
static int const aOneatatimeCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_PPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
/** Compiled in flag settings for the oneatatime option */
#define ONEATATIME_FLAGS     (OPTST_DISABLED)

/**
 *  pps-multi option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the pps-multi option */
#define PPS_MULTI_DESC      (tcpreplay_opt_strs+2132)
/** Upper-cased name for the pps-multi option */
#define PPS_MULTI_NAME      (tcpreplay_opt_strs+2181)
/** Name string for the pps-multi option */
#define PPS_MULTI_name      (tcpreplay_opt_strs+2191)
/** The compiled in default value for the pps-multi option argument */
#define PPS_MULTI_DFT_ARG   ((char const*)1)
/** Other options that are required by the pps-multi option */
static int const aPps_MultiMustList[] = {
    INDEX_OPT_PPS, NO_EQUIVALENT };
/** Compiled in flag settings for the pps-multi option */
#define PPS_MULTI_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  unique-ip option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the unique-ip option */
#define UNIQUE_IP_DESC      (tcpreplay_opt_strs+2201)
/** Upper-cased name for the unique-ip option */
#define UNIQUE_IP_NAME      (tcpreplay_opt_strs+2266)
/** Name string for the unique-ip option */
#define UNIQUE_IP_name      (tcpreplay_opt_strs+2276)
/** Other options that are required by the unique-ip option */
static int const aUnique_IpMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
/** Compiled in flag settings for the unique-ip option */
#define UNIQUE_IP_FLAGS     (OPTST_DISABLED)

/**
 *  unique-ip-loops option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the unique-ip-loops option */
#define UNIQUE_IP_LOOPS_DESC      (tcpreplay_opt_strs+2286)
/** Upper-cased name for the unique-ip-loops option */
#define UNIQUE_IP_LOOPS_NAME      (tcpreplay_opt_strs+2341)
/** Name string for the unique-ip-loops option */
#define UNIQUE_IP_LOOPS_name      (tcpreplay_opt_strs+2357)
/** Other options that are required by the unique-ip-loops option */
static int const aUnique_Ip_LoopsMustList[] = {
    INDEX_OPT_UNIQUE_IP, NO_EQUIVALENT };
/** Compiled in flag settings for the unique-ip-loops option */
#define UNIQUE_IP_LOOPS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/**
 *  netmap option description:
 */
#ifdef HAVE_NETMAP
/** Descriptive text for the netmap option */
#define NETMAP_DESC      (tcpreplay_opt_strs+2373)
/** Upper-cased name for the netmap option */
#define NETMAP_NAME      (tcpreplay_opt_strs+2430)
/** Name string for the netmap option */
#define NETMAP_name      (tcpreplay_opt_strs+2437)
/** Compiled in flag settings for the netmap option */
#define NETMAP_FLAGS     (OPTST_DISABLED)

#else   /* disable netmap */
#define NETMAP_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define NETMAP_NAME      NULL
#define NETMAP_DESC      NULL
#define NETMAP_name      NULL
#endif  /* HAVE_NETMAP */

/**
 *  nm-delay option description:
 */
#ifdef HAVE_NETMAP
/** Descriptive text for the nm-delay option */
#define NM_DELAY_DESC      (tcpreplay_opt_strs+2444)
/** Upper-cased name for the nm-delay option */
#define NM_DELAY_NAME      (tcpreplay_opt_strs+2465)
/** Name string for the nm-delay option */
#define NM_DELAY_name      (tcpreplay_opt_strs+2474)
/** The compiled in default value for the nm-delay option argument */
#define NM_DELAY_DFT_ARG   ((char const*)10)
/** Compiled in flag settings for the nm-delay option */
#define NM_DELAY_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable nm-delay */
#define NM_DELAY_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define NM_DELAY_DFT_ARG   NULL
#define NM_DELAY_NAME      NULL
#define NM_DELAY_DESC      NULL
#define NM_DELAY_name      NULL
#endif  /* HAVE_NETMAP */

/**
 *  no-flow-stats option description:
 */
/** Descriptive text for the no-flow-stats option */
#define NO_FLOW_STATS_DESC      (tcpreplay_opt_strs+2483)
/** Upper-cased name for the no-flow-stats option */
#define NO_FLOW_STATS_NAME      (tcpreplay_opt_strs+2548)
/** Name string for the no-flow-stats option */
#define NO_FLOW_STATS_name      (tcpreplay_opt_strs+2562)
/** Compiled in flag settings for the no-flow-stats option */
#define NO_FLOW_STATS_FLAGS     (OPTST_DISABLED)

/**
 *  flow-expiry option description with
 *  "Must also have options" and "Incompatible options":
 */
/** Descriptive text for the flow-expiry option */
#define FLOW_EXPIRY_DESC      (tcpreplay_opt_strs+2576)
/** Upper-cased name for the flow-expiry option */
#define FLOW_EXPIRY_NAME      (tcpreplay_opt_strs+2639)
/** Name string for the flow-expiry option */
#define FLOW_EXPIRY_name      (tcpreplay_opt_strs+2651)
/** The compiled in default value for the flow-expiry option argument */
#define FLOW_EXPIRY_DFT_ARG   ((char const*)0)
/** Other options that appear in conjunction with the flow-expiry option */
static int const aFlow_ExpiryCantList[] = {
    INDEX_OPT_NO_FLOW_STATS, NO_EQUIVALENT };
/** Compiled in flag settings for the flow-expiry option */
#define FLOW_EXPIRY_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  pid option description:
 */
/** Descriptive text for the pid option */
#define PID_DESC      (tcpreplay_opt_strs+2663)
/** Upper-cased name for the pid option */
#define PID_NAME      (tcpreplay_opt_strs+2701)
/** Name string for the pid option */
#define PID_name      (tcpreplay_opt_strs+2705)
/** Compiled in flag settings for the pid option */
#define PID_FLAGS     (OPTST_DISABLED)

/**
 *  stats option description:
 */
/** Descriptive text for the stats option */
#define STATS_DESC      (tcpreplay_opt_strs+2709)
/** Upper-cased name for the stats option */
#define STATS_NAME      (tcpreplay_opt_strs+2764)
/** Name string for the stats option */
#define STATS_name      (tcpreplay_opt_strs+2770)
/** Compiled in flag settings for the stats option */
#define STATS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/**
 *  version option description:
 */
/** Descriptive text for the version option */
#define VERSION_DESC      (tcpreplay_opt_strs+2776)
/** Upper-cased name for the version option */
#define VERSION_NAME      (tcpreplay_opt_strs+2802)
/** Name string for the version option */
#define VERSION_name      (tcpreplay_opt_strs+2810)
/** Compiled in flag settings for the version option */
#define VERSION_FLAGS     (OPTST_DISABLED)

/**
 *  less-help option description:
 */
/** Descriptive text for the less-help option */
#define LESS_HELP_DESC      (tcpreplay_opt_strs+2818)
/** Upper-cased name for the less-help option */
#define LESS_HELP_NAME      (tcpreplay_opt_strs+2858)
/** Name string for the less-help option */
#define LESS_HELP_name      (tcpreplay_opt_strs+2868)
/** Compiled in flag settings for the less-help option */
#define LESS_HELP_FLAGS     (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
#define HELP_DESC       (tcpreplay_opt_strs+2878)
#define HELP_name       (tcpreplay_opt_strs+2922)
#ifdef HAVE_WORKING_FORK
#define MORE_HELP_DESC  (tcpreplay_opt_strs+2927)
#define MORE_HELP_name  (tcpreplay_opt_strs+2972)
#define MORE_HELP_FLAGS (OPTST_IMM | OPTST_NO_INIT)
#else
#define MORE_HELP_DESC  HELP_DESC
#define MORE_HELP_name  HELP_name
#define MORE_HELP_FLAGS (OPTST_OMITTED | OPTST_NO_INIT)
#endif
#define SAVE_OPTS_DESC  (tcpreplay_opt_strs+2982)
#define SAVE_OPTS_name  (tcpreplay_opt_strs+3021)
#define LOAD_OPTS_DESC     (tcpreplay_opt_strs+3031)
#define LOAD_OPTS_NAME     (tcpreplay_opt_strs+3063)
#define NO_LOAD_OPTS_name  (tcpreplay_opt_strs+3073)
#define LOAD_OPTS_pfx      (tcpreplay_opt_strs+3086)
#define LOAD_OPTS_name     (NO_LOAD_OPTS_name + 3)
/**
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionBooleanVal,   optionNestedVal,    optionNumericVal,
    optionPagedUsage,   optionPrintVersion, optionResetOpt,
    optionStackArg,     optionTimeDate,     optionTimeVal,
    optionUnstackArg,   optionVendorOption;
static tOptProc
    doOptDuration,     doOptFlow_Expiry,  doOptLess_Help,
    doOptLimit,        doOptLoop,         doOptLoopdelay_Ms,
    doOptPid,          doOptPps_Multi,    doOptStats,
    doOptVersion,      doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 *  Define the tcpreplay Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the tcpreplay program responds to.
 */
static tOptDesc optDesc[OPTION_CT] = {
  {  /* entry idx, value */ 0, VALUE_OPT_DBUG,
     /* equiv idx, value */ 0, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { DBUG_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ DBUG_DESC, DBUG_NAME, DBUG_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_QUIET,
     /* equiv idx, value */ 1, VALUE_OPT_QUIET,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUIET_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --quiet */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ QUIET_DESC, QUIET_NAME, QUIET_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_TIMER,
     /* equiv idx, value */ 2, VALUE_OPT_TIMER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMER_FLAGS, 0,
     /* last opt argumnt */ { TIMER_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TIMER_DESC, TIMER_NAME, TIMER_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_MAXSLEEP,
     /* equiv idx, value */ 3, VALUE_OPT_MAXSLEEP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MAXSLEEP_FLAGS, 0,
     /* last opt argumnt */ { MAXSLEEP_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ MAXSLEEP_DESC, MAXSLEEP_NAME, MAXSLEEP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 4, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --verbose */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ VERBOSE_DESC, VERBOSE_NAME, VERBOSE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_DECODE,
     /* equiv idx, value */ 5, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --decode */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DECODE_DESC, DECODE_NAME, DECODE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_PRELOAD_PCAP,
     /* equiv idx, value */ 6, VALUE_OPT_PRELOAD_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRELOAD_PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --preload_pcap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PRELOAD_PCAP_DESC, PRELOAD_PCAP_NAME, PRELOAD_PCAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 7, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --cachefile */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aCachefileMustList, aCachefileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ CACHEFILE_DESC, CACHEFILE_NAME, CACHEFILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_DUALFILE,
     /* equiv idx, value */ 8, VALUE_OPT_DUALFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DUALFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --dualfile */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDualfileMustList, aDualfileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DUALFILE_DESC, DUALFILE_NAME, DUALFILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_INTF1,
     /* equiv idx, value */ 9, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf1 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF1_DESC, INTF1_NAME, INTF1_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_INTF2,
     /* equiv idx, value */ 10, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf2 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF2_DESC, INTF2_NAME, INTF2_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 11, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --listnics */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ LISTNICS_DESC, LISTNICS_NAME, LISTNICS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_LOOP,
     /* equiv idx, value */ 12, VALUE_OPT_LOOP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_FLAGS, 0,
     /* last opt argumnt */ { LOOP_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop,
     /* desc, NAME, name */ LOOP_DESC, LOOP_NAME, LOOP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_LOOPDELAY_MS,
     /* equiv idx, value */ 13, VALUE_OPT_LOOPDELAY_MS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOPDELAY_MS_FLAGS, 0,
     /* last opt argumnt */ { LOOPDELAY_MS_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aLoopdelay_MsMustList, NULL,
     /* option proc      */ doOptLoopdelay_Ms,
     /* desc, NAME, name */ LOOPDELAY_MS_DESC, LOOPDELAY_MS_NAME, LOOPDELAY_MS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equiv idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PKTLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pktlen */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PKTLEN_DESC, PKTLEN_NAME, PKTLEN_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 15, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { LIMIT_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ LIMIT_DESC, LIMIT_NAME, LIMIT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_DURATION,
     /* equiv idx, value */ 16, VALUE_OPT_DURATION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DURATION_FLAGS, 0,
     /* last opt argumnt */ { DURATION_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDuration,
     /* desc, NAME, name */ DURATION_DESC, DURATION_NAME, DURATION_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_MULTIPLIER,
     /* equiv idx, value */ 17, VALUE_OPT_MULTIPLIER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MULTIPLIER_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --multiplier */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMultiplierCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ MULTIPLIER_DESC, MULTIPLIER_NAME, MULTIPLIER_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_PPS,
     /* equiv idx, value */ 18, VALUE_OPT_PPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pps */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PPS_DESC, PPS_NAME, PPS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_MBPS,
     /* equiv idx, value */ 19, VALUE_OPT_MBPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MBPS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mbps */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMbpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ MBPS_DESC, MBPS_NAME, MBPS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_TOPSPEED,
     /* equiv idx, value */ 20, VALUE_OPT_TOPSPEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOPSPEED_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --topspeed */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aTopspeedCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TOPSPEED_DESC, TOPSPEED_NAME, TOPSPEED_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_ONEATATIME,
     /* equiv idx, value */ 21, VALUE_OPT_ONEATATIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ONEATATIME_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --oneatatime */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aOneatatimeCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ONEATATIME_DESC, ONEATATIME_NAME, ONEATATIME_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_PPS_MULTI,
     /* equiv idx, value */ 22, VALUE_OPT_PPS_MULTI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_MULTI_FLAGS, 0,
     /* last opt argumnt */ { PPS_MULTI_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aPps_MultiMustList, NULL,
     /* option proc      */ doOptPps_Multi,
     /* desc, NAME, name */ PPS_MULTI_DESC, PPS_MULTI_NAME, PPS_MULTI_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_UNIQUE_IP,
     /* equiv idx, value */ 23, VALUE_OPT_UNIQUE_IP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ UNIQUE_IP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --unique-ip */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aUnique_IpMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ UNIQUE_IP_DESC, UNIQUE_IP_NAME, UNIQUE_IP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_UNIQUE_IP_LOOPS,
     /* equiv idx, value */ 24, VALUE_OPT_UNIQUE_IP_LOOPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ UNIQUE_IP_LOOPS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --unique-ip-loops */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aUnique_Ip_LoopsMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ UNIQUE_IP_LOOPS_DESC, UNIQUE_IP_LOOPS_NAME, UNIQUE_IP_LOOPS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 25, VALUE_OPT_NETMAP,
     /* equiv idx, value */ 25, VALUE_OPT_NETMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NETMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --netmap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ NETMAP_DESC, NETMAP_NAME, NETMAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 26, VALUE_OPT_NM_DELAY,
     /* equiv idx, value */ 26, VALUE_OPT_NM_DELAY,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NM_DELAY_FLAGS, 0,
     /* last opt argumnt */ { NM_DELAY_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ NM_DELAY_DESC, NM_DELAY_NAME, NM_DELAY_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 27, VALUE_OPT_NO_FLOW_STATS,
     /* equiv idx, value */ 27, VALUE_OPT_NO_FLOW_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NO_FLOW_STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --no-flow-stats */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ NO_FLOW_STATS_DESC, NO_FLOW_STATS_NAME, NO_FLOW_STATS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 28, VALUE_OPT_FLOW_EXPIRY,
     /* equiv idx, value */ 28, VALUE_OPT_FLOW_EXPIRY,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FLOW_EXPIRY_FLAGS, 0,
     /* last opt argumnt */ { FLOW_EXPIRY_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aFlow_ExpiryCantList,
     /* option proc      */ doOptFlow_Expiry,
     /* desc, NAME, name */ FLOW_EXPIRY_DESC, FLOW_EXPIRY_NAME, FLOW_EXPIRY_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 29, VALUE_OPT_PID,
     /* equiv idx, value */ 29, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pid */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ PID_DESC, PID_NAME, PID_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 30, VALUE_OPT_STATS,
     /* equiv idx, value */ 30, VALUE_OPT_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --stats */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptStats,
     /* desc, NAME, name */ STATS_DESC, STATS_NAME, STATS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 31, VALUE_OPT_VERSION,
     /* equiv idx, value */ 31, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --version */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ VERSION_DESC, VERSION_NAME, VERSION_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 32, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 32, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --less-help */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ LESS_HELP_DESC, LESS_HELP_NAME, LESS_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, AOUSE_HELP,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ HELP_DESC, NULL, HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_MORE_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MORE_HELP_FLAGS, AOUSE_MORE_HELP,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ MORE_HELP_DESC, NULL, MORE_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_SAVE_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                       | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, AOUSE_SAVE_OPTS,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SAVE_OPTS_DESC, NULL, SAVE_OPTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_LOAD_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, AOUSE_LOAD_OPTS,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ LOAD_OPTS_DESC, LOAD_OPTS_NAME, LOAD_OPTS_name,
     /* disablement strs */ NO_LOAD_OPTS_name, LOAD_OPTS_pfx }
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/** Reference to the upper cased version of tcpreplay. */
#define zPROGNAME       (tcpreplay_opt_strs+3089)
/** Reference to the title line for tcpreplay usage. */
#define zUsageTitle     (tcpreplay_opt_strs+3099)
/** tcpreplay configuration file name. */
#define zRcName         (tcpreplay_opt_strs+3264)
/** Directories to search for tcpreplay config files. */
static char const * const apzHomeList[2] = {
    tcpreplay_opt_strs+3260,
    NULL };
/** The tcpreplay program bug email address. */
#define zBugsAddr       (tcpreplay_opt_strs+3277)
/** Clarification/explanation of what tcpreplay does. */
#define zExplain        (tcpreplay_opt_strs+3315)
/** Extra detail explaining what tcpreplay does. */
#define zDetail         (tcpreplay_opt_strs+3438)
/** The full version string for tcpreplay. */
#define zFullVersion    (NULL)
/* extracted from optcode.tlib near line 342 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */

#define tcpreplay_full_usage (NULL)
#define tcpreplay_short_usage (NULL)

#endif /* not defined __doxygen__ */

/*
 *  Create the static procedure(s) declared above.
 */
/**
 * The callout function that invokes the optionUsage function.
 *
 * @param[in] opts the AutoOpts option description structure
 * @param[in] od   the descriptor for the "help" (usage) option.
 * @noreturn
 */
static void
doUsageOpt(tOptions * opts, tOptDesc * od)
{
    int ex_code;
    ex_code = TCPREPLAY_EXIT_SUCCESS;
    optionUsage(&tcpreplayOptions, ex_code);
    /* NOTREACHED */
    exit(TCPREPLAY_EXIT_FAILURE);
    (void)opts;
    (void)od;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the dbug option, when DEBUG is #define-d.
 * If configured with --enable-debug, then you can specify a verbosity
 * level for debugging output.  Higher numbers increase verbosity.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 5 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     */
    /* extracted from tcpreplay_opts.def, line 297 */

    interface_list_t *list = get_interface_list();
    list_interfaces(list);
    free(list);
    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the loop option.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptLoop(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the loopdelay-ms option.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptLoopdelay_Ms(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the limit option.
 * By default, tcpreplay will send all the packets.  Alternatively, you can
 * specify a maximum number of packets to send.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the duration option.
 * By default, tcpreplay will send all the packets.  Alternatively, you can
 * specify a maximum number of seconds to transmit.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptDuration(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the pps-multi option.
 * When trying to send packets at very high rates, the time between each packet
 * can be so short that it is impossible to accurately sleep for the required
 * period of time.  This option allows you to send multiple packets at a time,
 * thus allowing for longer sleep times which can be more accurately implemented.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptPps_Multi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the flow-expiry option.
 * This option will track and report flow expirations based on the flow idle
 * times. The timestamps within the pcap file are used to determine the expiry,
 * not the actual timestamp of the packets are replayed. For example, a value of
 * 30 suggests that if no traffic is seen on a flow for 30 seconds, any
 * subsequent traffic would be considered a new flow, and thereby will increment
 * the flows and flows per second (fps) statistics.
 *
 * This option can be used to optimize flow timeout settings for flow products.
 * Setting the timeout low may lead to flows being dropped when in fact the flow
 * is simply slow to respond. Configuring your flow timeouts too high may
 * increase resources required by your flow product.
 *
 * Note that using this option while replaying at higher than original speeds
 * can lead to inflated flows and fps counts.
 *
 * Default is 0 (no expiry) and a typical value is 30-120 seconds.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptFlow_Expiry(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the pid option.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     */
    /* extracted from tcpreplay_opts.def, line 582 */

    fprintf(stderr, "PID: %d\n", getpid());

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the stats option.
 * Note that timed delays are a "best effort" and long delays between
 * sending packets may cause equally long delays between printing statistics.
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptStats(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

 emit_ranges:
optionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the version option.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     */
    /* extracted from tcpreplay_opts.def, line 605 */

    fprintf(stderr, "tcpreplay version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
#ifdef TIMESTAMP_TRACE
    fprintf(stderr, " (timestamp-trace)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2013-2022 by Fred Klassen <tcpreplay at appneta dot com> - AppNeta\n");
    fprintf(stderr, "Copyright 2000-2012 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");  
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#elif defined HAVE_PF_RING_PCAP
    fprintf(stderr, "Compiled against PF_RING libpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
#ifdef TCPREPLAY_EDIT
    fprintf(stderr, "Packet editing: enabled\n");
#else
    fprintf(stderr, "Packet editing: disabled\n");
#endif
#ifdef ENABLE_FRAGROUTE
    fprintf(stderr, "Fragroute engine: enabled\n");
#else
    fprintf(stderr, "Fragroute engine: disabled\n");
#endif
#if defined HAVE_NETMAP
    fprintf(stderr, "Default injection method: %s\n", sendpacket_get_method(NULL));
#else
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method(NULL));
#endif
#ifdef HAVE_NETMAP
    fprintf(stderr, "Optional injection method: netmap\n");
#else
    fprintf(stderr, "Not compiled with netmap\n");
#endif
    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the less-help option.
 *
 * @param[in] pOptions the tcpreplay options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     */
    /* extracted from tcpreplay_opts.def, line 672 */

    USAGE(EXIT_FAILURE);

    (void)pOptDesc;
    (void)pOptions;
}
/* extracted from optmain.tlib near line 1250 */

/**
 * The directory containing the data associated with tcpreplay.
 */
#ifndef  PKGDATADIR
# define PKGDATADIR ""
#endif

/**
 * Information about the person or institution that packaged tcpreplay
 * for the current distribution.
 */
#ifndef  WITH_PACKAGER
# define tcpreplay_packager_info NULL
#else
/** Packager information for tcpreplay. */
static char const tcpreplay_packager_info[] =
    "Packaged by " WITH_PACKAGER

# ifdef WITH_PACKAGER_VERSION
        " ("WITH_PACKAGER_VERSION")"
# endif

# ifdef WITH_PACKAGER_BUG_REPORTS
    "\nReport tcpreplay bugs to " WITH_PACKAGER_BUG_REPORTS
# endif
    "\n";
#endif
#ifndef __doxygen__

#endif /* __doxygen__ */
/**
 * The option definitions for tcpreplay.  The one structure that
 * binds them all.
 */
tOptions tcpreplayOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_ARGS_REQ
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zLicenseDescrip,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage, /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    37 /* full option count */, 33 /* user option count */,
    tcpreplay_full_usage, tcpreplay_short_usage,
    NULL, NULL,
    PKGDATADIR, tcpreplay_packager_info
};

#if ENABLE_NLS
/**
 * This code is designed to translate translatable option text for the
 * tcpreplay program.  These translations happen upon entry
 * to optionProcess().
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef HAVE_DCGETTEXT
# include <gettext.h>
#endif
#include <autoopts/usage-txt.h>

static char * AO_gettext(char const * pz);
static void   coerce_it(void ** s);

/**
 * AutoGen specific wrapper function for gettext.  It relies on the macro _()
 * to convert from English to the target language, then strdup-duplicates the
 * result string.  It tries the "libopts" domain first, then whatever has been
 * set via the \a textdomain(3) call.
 *
 * @param[in] pz the input text used as a lookup key.
 * @returns the translated text (if there is one),
 *   or the original text (if not).
 */
static char *
AO_gettext(char const * pz)
{
    char * res;
    if (pz == NULL)
        return NULL;
#ifdef HAVE_DCGETTEXT
    /*
     * While processing the option_xlateable_txt data, try to use the
     * "libopts" domain.  Once we switch to the option descriptor data,
     * do *not* use that domain.
     */
    if (option_xlateable_txt.field_ct != 0) {
        res = dgettext("libopts", pz);
        if (res == pz)
            res = (char *)VOIDP(_(pz));
    } else
        res = (char *)VOIDP(_(pz));
#else
    res = (char *)VOIDP(_(pz));
#endif
    if (res == pz)
        return res;
    res = strdup(res);
    if (res == NULL) {
        fputs(_("No memory for duping translated strings\n"), stderr);
        exit(TCPREPLAY_EXIT_FAILURE);
    }
    return res;
}

/**
 * All the pointers we use are marked "* const", but they are stored in
 * writable memory.  Coerce the mutability and set the pointer.
 */
static void coerce_it(void ** s) { *s = AO_gettext(*s);
}

/**
 * Translate all the translatable strings in the tcpreplayOptions
 * structure defined above.  This is done only once.
 */
static void
translate_option_strings(void)
{
    tOptions * const opts = &tcpreplayOptions;

    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_xlateable_txt.field_ct != 0) {
        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));
        int     ix  = option_xlateable_txt.field_ct;

        do {
            ppz++; /* skip over field_ct */
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);
        /* prevent re-translation and disable "libopts" domain lookup */
        option_xlateable_txt.field_ct = 0;

        coerce_it(VOIDP(&(opts->pzCopyright)));
        coerce_it(VOIDP(&(opts->pzCopyNotice)));
        coerce_it(VOIDP(&(opts->pzFullVersion)));
        coerce_it(VOIDP(&(opts->pzUsageTitle)));
        coerce_it(VOIDP(&(opts->pzExplain)));
        coerce_it(VOIDP(&(opts->pzDetail)));
        {
            tOptDesc * od = opts->pOptDesc;
            for (ix = opts->optCt; ix > 0; ix--, od++)
                coerce_it(VOIDP(&(od->pzText)));
        }
    }
}
#endif /* ENABLE_NLS */

#ifdef DO_NOT_COMPILE_THIS_CODE_IT_IS_FOR_GETTEXT
/** I18N function strictly for xgettext.  Do not compile. */
static void bogus_function(void) {
  /* TRANSLATORS:

     The following dummy function was crated solely so that xgettext can
     extract the correct strings.  These strings are actually referenced
     by a field name in the tcpreplayOptions structure noted in the
     comments below.  The literal text is defined in tcpreplay_opt_strs.

     NOTE: the strings below are segmented with respect to the source string
     tcpreplay_opt_strs.  The strings above are handed off for translation
     at run time a paragraph at a time.  Consequently, they are presented here
     for translation a paragraph at a time.

     ALSO: often the description for an option will reference another option
     by name.  These are set off with apostrophe quotes (I hope).  Do not
     translate option names.
   */
  /* referenced via tcpreplayOptions.pzCopyright */
  puts(_("tcpreplay (tcpreplay)\n\
Copyright (C) 2000-2022 Aaron Turner and Fred Klassen, all rights reserved.\n\
This is free software. It is licensed for use, modification and\n\
redistribution under the terms of the GNU General Public License,\n\
version 3 or later <http://gnu.org/licenses/gpl.html>\n"));

  /* referenced via tcpreplayOptions.pzCopyNotice */
  puts(_("tcpreplay is free software: you can redistribute it and/or modify it under\n\
the terms of the GNU General Public License as published by the Free\n\
Software Foundation, either version 3 of the License, or (at your option)\n\
any later version.\n\n"));
  puts(_("tcpreplay is distributed in the hope that it will be useful, but WITHOUT\n\
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n\
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n\
more details.\n\n"));
  puts(_("You should have received a copy of the GNU General Public License along\n\
with this program.  If not, see <http://www.gnu.org/licenses/>.\n"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Enable debugging output"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Quiet mode"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Select packet timing mode: select, ioport, gtod, nano"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Sleep for no more then X milliseconds between packets"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Print decoded packets via tcpdump to STDOUT"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Arguments passed to tcpdump decoder"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Preloads packets into RAM before sending"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Split traffic via a tcpprep cache file"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Replay two files at a time from a network tap"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Client to server/RX/primary traffic output interface"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Server to client/TX/secondary traffic output interface"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("List available network interfaces and exit"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Loop through the capture file X times"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Delay between loops in milliseconds"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Override the snaplen and use the actual packet len"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Limit the number of packets to send"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Limit the number of seconds to send"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Modify replay speed to a given multiple"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Replay packets at a given packets/sec"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Replay packets at a given Mbps"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Replay packets as fast as possible"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Replay one packet at a time for each user input"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Number of packets to send for each time interval"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Modify IP addresses each loop iteration to generate unique flows"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Number of times to loop before assigning new unique ip"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Write packets directly to netmap enabled network adapter"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Netmap startup delay"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Suppress printing and tracking flow count, rates and expirations"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Number of inactive seconds before a flow is considered expired"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Print the PID of tcpreplay at startup"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Print statistics every X seconds, or every loop if '0'"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Print version information"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("Display less usage information and exit"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("display extended usage information and exit"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("extended usage information passed thru pager"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("save the option state to a config file"));

  /* referenced via tcpreplayOptions.pOptDesc->pzText */
  puts(_("load options from a config file"));

  /* referenced via tcpreplayOptions.pzUsageTitle */
  puts(_("tcpreplay (tcpreplay) - Replay network traffic stored in pcap files\n\
Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... \\\n\
\t\t<pcap_file(s)> | <pcap_dir(s)>\n"));

  /* referenced via tcpreplayOptions.pzExplain */
  puts(_("tcpreplay is a tool for replaying network traffic from files saved with\n\
tcpdump or other tools which write pcap(3) files.\n"));

  /* referenced via tcpreplayOptions.pzDetail */
  puts(_("The basic operation of tcpreplay is to resend all packets from the input\n\
file(s) at the speed at which they were recorded, or a specified data rate,\n\
up to as fast as the hardware is capable.\n\n"));
  puts(_("Optionally, the traffic can be split between two interfaces, written to\n\
files, filtered and edited in various ways, providing the means to test\n\
firewalls, NIDS and other network devices.\n\n"));
  puts(_("For more details, please see the Tcpreplay Manual at:\n\
http://tcpreplay.appneta.com\n"));

  /* referenced via tcpreplayOptions.pzFullUsage */
  puts(_("<<<NOT-FOUND>>>"));

  /* referenced via tcpreplayOptions.pzShortUsage */
  puts(_("<<<NOT-FOUND>>>"));
  /* LIBOPTS-MESSAGES: */
#line 67 "../autoopts.c"
  puts(_("allocation of %d bytes failed\n"));
#line 89 "../autoopts.c"
  puts(_("allocation of %d bytes failed\n"));
#line 48 "../init.c"
  puts(_("AutoOpts function called without option descriptor\n"));
#line 81 "../init.c"
  puts(_("\tThis exceeds the compiled library version:  "));
#line 79 "../init.c"
  puts(_("Automated Options Processing Error!\n"
       "\t%s called AutoOpts function with structure version %d:%d:%d.\n"));
#line 78 "../autoopts.c"
  puts(_("realloc of %d bytes at 0x%p failed\n"));
#line 83 "../init.c"
  puts(_("\tThis is less than the minimum library version:  "));
#line 121 "../version.c"
  puts(_("Automated Options version %s\n"
       "\tCopyright (C) 1999-2017 by Bruce Korb - all rights reserved\n"));
#line 49 "../makeshell.c"
  puts(_("(AutoOpts bug):  %s.\n"));
#line 90 "../reset.c"
  puts(_("optionResetOpt() called, but reset-option not configured"));
#line 241 "../usage.c"
  puts(_("could not locate the 'help' option"));
#line 330 "../autoopts.c"
  puts(_("optionProcess() was called with invalid data"));
#line 697 "../usage.c"
  puts(_("invalid argument type specified"));
#line 568 "../find.c"
  puts(_("defaulted to option with optional arg"));
#line 76 "../alias.c"
  puts(_("aliasing option is out of range."));
#line 210 "../enum.c"
  puts(_("%s error:  the keyword '%s' is ambiguous for %s\n"));
#line 78 "../find.c"
  puts(_("  The following options match:\n"));
#line 263 "../find.c"
  puts(_("%s: ambiguous option name: %s (matches %d options)\n"));
#line 161 "../check.c"
  puts(_("%s: Command line arguments required\n"));
#line 43 "../alias.c"
  puts(_("%d %s%s options allowed\n"));
#line 56 "../makeshell.c"
  puts(_("%s error %d (%s) calling %s for '%s'\n"));
#line 268 "../makeshell.c"
  puts(_("interprocess pipe"));
#line 171 "../version.c"
  puts(_("error: version option argument '%c' invalid.  Use:\n"
       "\t'v' - version only\n"
       "\t'c' - version and copyright\n"
       "\t'n' - version and full copyright notice\n"));
#line 58 "../check.c"
  puts(_("%s error:  the '%s' and '%s' options conflict\n"));
#line 187 "../find.c"
  puts(_("%s: The '%s' option has been disabled."));
#line 400 "../find.c"
  puts(_("%s: The '%s' option has been disabled."));
#line 38 "../alias.c"
  puts(_("-equivalence"));
#line 439 "../find.c"
  puts(_("%s: illegal option -- %c\n"));
#line 110 "../reset.c"
  puts(_("%s: illegal option -- %c\n"));
#line 241 "../find.c"
  puts(_("%s: illegal option -- %s\n"));
#line 740 "../find.c"
  puts(_("%s: illegal option -- %s\n"));
#line 118 "../reset.c"
  puts(_("%s: illegal option -- %s\n"));
#line 305 "../find.c"
  puts(_("%s: unknown vendor extension option -- %s\n"));
#line 135 "../enum.c"
  puts(_("  or an integer from %d through %d\n"));
#line 145 "../enum.c"
  puts(_("  or an integer from %d through %d\n"));
#line 696 "../usage.c"
  puts(_("%s error:  invalid option descriptor for %s\n"));
#line 1030 "../usage.c"
  puts(_("%s error:  invalid option descriptor for %s\n"));
#line 355 "../find.c"
  puts(_("%s: invalid option name: %s\n"));
#line 497 "../find.c"
  puts(_("%s: The '%s' option requires an argument.\n"));
#line 150 "../autoopts.c"
  puts(_("(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n"
       "\t'%s' and '%s'."));
#line 94 "../check.c"
  puts(_("%s error:  The %s option is required\n"));
#line 602 "../find.c"
  puts(_("%s: The '%s' option cannot have an argument.\n"));
#line 151 "../check.c"
  puts(_("%s: Command line arguments are not allowed.\n"));
#line 568 "../save.c"
  puts(_("error %d (%s) creating %s\n"));
#line 210 "../enum.c"
  puts(_("%s error:  '%s' does not match any %s keywords.\n"));
#line 93 "../reset.c"
  puts(_("%s error: The '%s' option requires an argument.\n"));
#line 122 "../save.c"
  puts(_("error %d (%s) stat-ing %s\n"));
#line 175 "../save.c"
  puts(_("error %d (%s) stat-ing %s\n"));
#line 143 "../restore.c"
  puts(_("%s error: no saved option state\n"));
#line 225 "../autoopts.c"
  puts(_("'%s' is not a command line option.\n"));
#line 113 "../time.c"
  puts(_("%s error:  '%s' is not a recognizable date/time.\n"));
#line 50 "../time.c"
  puts(_("%s error:  '%s' is not a recognizable time duration.\n"));
#line 92 "../check.c"
  puts(_("%s error:  The %s option must appear %d times.\n"));
#line 165 "../numeric.c"
  puts(_("%s error:  '%s' is not a recognizable number.\n"));
#line 176 "../enum.c"
  puts(_("%s error:  %s exceeds %s keyword count\n"));
#line 279 "../usage.c"
  puts(_("Try '%s %s' for more information.\n"));
#line 45 "../alias.c"
  puts(_("one %s%s option allowed\n"));
#line 170 "../makeshell.c"
  puts(_("standard output"));
#line 905 "../makeshell.c"
  puts(_("standard output"));
#line 223 "../usage.c"
  puts(_("standard output"));
#line 364 "../usage.c"
  puts(_("standard output"));
#line 574 "../usage.c"
  puts(_("standard output"));
#line 178 "../version.c"
  puts(_("standard output"));
#line 223 "../usage.c"
  puts(_("standard error"));
#line 364 "../usage.c"
  puts(_("standard error"));
#line 574 "../usage.c"
  puts(_("standard error"));
#line 178 "../version.c"
  puts(_("standard error"));
#line 170 "../makeshell.c"
  puts(_("write"));
#line 905 "../makeshell.c"
  puts(_("write"));
#line 222 "../usage.c"
  puts(_("write"));
#line 363 "../usage.c"
  puts(_("write"));
#line 573 "../usage.c"
  puts(_("write"));
#line 177 "../version.c"
  puts(_("write"));
#line 60 "../numeric.c"
  puts(_("%s error:  %s option value %ld is out of range.\n"));
#line 44 "../check.c"
  puts(_("%s error:  %s option requires the %s option\n"));
#line 121 "../save.c"
  puts(_("%s warning:  cannot save options - %s not regular file\n"));
#line 174 "../save.c"
  puts(_("%s warning:  cannot save options - %s not regular file\n"));
#line 193 "../save.c"
  puts(_("%s warning:  cannot save options - %s not regular file\n"));
#line 567 "../save.c"
  puts(_("%s warning:  cannot save options - %s not regular file\n"));
  /* END-LIBOPTS-MESSAGES */

  /* USAGE-TEXT: */
#line 822 "../usage.c"
  puts(_("\t\t\t\t- an alternate for '%s'\n"));
#line 1097 "../usage.c"
  puts(_("Version, usage and configuration options:"));
#line 873 "../usage.c"
  puts(_("\t\t\t\t- default option for unnamed options\n"));
#line 786 "../usage.c"
  puts(_("\t\t\t\t- disabled as '--%s'\n"));
#line 1066 "../usage.c"
  puts(_(" --- %-14s %s\n"));
#line 1064 "../usage.c"
  puts(_("This option has been disabled"));
#line 813 "../usage.c"
  puts(_("\t\t\t\t- enabled by default\n"));
#line 40 "../alias.c"
  puts(_("%s error:  only "));
#line 1143 "../usage.c"
  puts(_(" - examining environment variables named %s_*\n"));
#line 168 "../file.c"
  puts(_("\t\t\t\t- file must not pre-exist\n"));
#line 172 "../file.c"
  puts(_("\t\t\t\t- file must pre-exist\n"));
#line 329 "../usage.c"
  puts(_("Options are specified by doubled hyphens and their name or by a single\n"
       "hyphen and the flag character.\n"));
#line 882 "../makeshell.c"
  puts(_("\n"
       "= = = = = = = =\n\n"
       "This incarnation of genshell will produce\n"
       "a shell script to parse the options for %s:\n\n"));
#line 142 "../enum.c"
  puts(_("  or an integer mask with any of the lower %d bits set\n"));
#line 846 "../usage.c"
  puts(_("\t\t\t\t- is a set membership option\n"));
#line 867 "../usage.c"
  puts(_("\t\t\t\t- must appear between %d and %d times\n"));
#line 331 "../usage.c"
  puts(_("Options are specified by single or double hyphens and their name.\n"));
#line 853 "../usage.c"
  puts(_("\t\t\t\t- may appear multiple times\n"));
#line 840 "../usage.c"
  puts(_("\t\t\t\t- may not be preset\n"));
#line 1258 "../usage.c"
  puts(_("   Arg Option-Name    Description\n"));
#line 1194 "../usage.c"
  puts(_("  Flg Arg Option-Name    Description\n"));
#line 1252 "../usage.c"
  puts(_("  Flg Arg Option-Name    Description\n"));
#line 1253 "../usage.c"
  puts(_(" %3s %s"));
#line 1259 "../usage.c"
  puts(_(" %3s %s"));
#line 336 "../usage.c"
  puts(_("The '-#<number>' option may omit the hash char\n"));
#line 332 "../usage.c"
  puts(_("All arguments are named options.\n"));
#line 920 "../usage.c"
  puts(_(" - reading file %s"));
#line 358 "../usage.c"
  puts(_("\n"
       "Please send bug reports to:  <%s>\n"));
#line 100 "../version.c"
  puts(_("\n"
       "Please send bug reports to:  <%s>\n"));
#line 129 "../version.c"
  puts(_("\n"
       "Please send bug reports to:  <%s>\n"));
#line 852 "../usage.c"
  puts(_("\t\t\t\t- may NOT appear - preset only\n"));
#line 893 "../usage.c"
  puts(_("\n"
       "The following option preset mechanisms are supported:\n"));
#line 1141 "../usage.c"
  puts(_("\n"
       "The following option preset mechanisms are supported:\n"));
#line 631 "../usage.c"
  puts(_("prohibits these options:\n"));
#line 626 "../usage.c"
  puts(_("prohibits the option '%s'\n"));
#line 81 "../numeric.c"
  puts(_("%s%ld to %ld"));
#line 79 "../numeric.c"
  puts(_("%sgreater than or equal to %ld"));
#line 75 "../numeric.c"
  puts(_("%s%ld exactly"));
#line 68 "../numeric.c"
  puts(_("%sit must lie in one of the ranges:\n"));
#line 68 "../numeric.c"
  puts(_("%sit must be in the range:\n"));
#line 88 "../numeric.c"
  puts(_(", or\n"));
#line 66 "../numeric.c"
  puts(_("%sis scalable with a suffix: k/K/m/M/g/G/t/T\n"));
#line 77 "../numeric.c"
  puts(_("%sless than or equal to %ld"));
#line 339 "../usage.c"
  puts(_("Operands and options may be intermixed.  They will be reordered.\n"));
#line 601 "../usage.c"
  puts(_("requires the option '%s'\n"));
#line 604 "../usage.c"
  puts(_("requires these options:\n"));
#line 1270 "../usage.c"
  puts(_("   Arg Option-Name   Req?  Description\n"));
#line 1264 "../usage.c"
  puts(_("  Flg Arg Option-Name   Req?  Description\n"));
#line 143 "../enum.c"
  puts(_("or you may use a numeric representation.  Preceding these with a '!'\n"
       "will clear the bits, specifying 'none' will clear all bits, and 'all'\n"
       "will set them all.  Multiple entries may be passed as an option\n"
       "argument list.\n"));
#line 859 "../usage.c"
  puts(_("\t\t\t\t- may appear up to %d times\n"));
#line 52 "../enum.c"
  puts(_("The valid \"%s\" option keywords are:\n"));
#line 1101 "../usage.c"
  puts(_("The next option supports vendor supported extra options:"));
#line 722 "../usage.c"
  puts(_("These additional options are:"));
  /* END-USAGE-TEXT */
}
#endif /* uncompilable code */
#ifdef  __cplusplus
}
#endif
/* tcpreplay_opts.c ends here */
