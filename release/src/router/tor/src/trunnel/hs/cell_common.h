/* cell_common.h -- generated by Trunnel v1.5.2.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_CELL_COMMON_H
#define TRUNNEL_CELL_COMMON_H

#include <stdint.h>
#include "trunnel.h"

#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_CELL_EXTENSION_FIELDS)
struct trn_cell_extension_fields_st {
  uint8_t field_type;
  uint8_t field_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) field;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_cell_extension_fields_st trn_cell_extension_fields_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_CELL_EXTENSION)
struct trn_cell_extension_st {
  uint8_t num;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_cell_extension_fields_st *) fields;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_cell_extension_st trn_cell_extension_t;
/** Return a newly allocated trn_cell_extension_fields with all
 * elements set to zero.
 */
trn_cell_extension_fields_t *trn_cell_extension_fields_new(void);
/** Release all storage held by the trn_cell_extension_fields in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void trn_cell_extension_fields_free(trn_cell_extension_fields_t *victim);
/** Try to parse a trn_cell_extension_fields from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated trn_cell_extension_fields_t. On failure, return -2
 * if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t trn_cell_extension_fields_parse(trn_cell_extension_fields_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_cell_extension_fields in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t trn_cell_extension_fields_encoded_len(const trn_cell_extension_fields_t *obj);
/** Try to encode the trn_cell_extension_fields from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_cell_extension_fields_encode(uint8_t *output, size_t avail, const trn_cell_extension_fields_t *input);
/** Check whether the internal state of the trn_cell_extension_fields
 * in 'obj' is consistent. Return NULL if it is, and a short message
 * if it is not.
 */
const char *trn_cell_extension_fields_check(const trn_cell_extension_fields_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_cell_extension_fields_clear_errors(trn_cell_extension_fields_t *obj);
/** Return the value of the field_type field of the
 * trn_cell_extension_fields_t in 'inp'
 */
uint8_t trn_cell_extension_fields_get_field_type(const trn_cell_extension_fields_t *inp);
/** Set the value of the field_type field of the
 * trn_cell_extension_fields_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_cell_extension_fields_set_field_type(trn_cell_extension_fields_t *inp, uint8_t val);
/** Return the value of the field_len field of the
 * trn_cell_extension_fields_t in 'inp'
 */
uint8_t trn_cell_extension_fields_get_field_len(const trn_cell_extension_fields_t *inp);
/** Set the value of the field_len field of the
 * trn_cell_extension_fields_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_cell_extension_fields_set_field_len(trn_cell_extension_fields_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the field field of
 * the trn_cell_extension_fields_t in 'inp'.
 */
size_t trn_cell_extension_fields_getlen_field(const trn_cell_extension_fields_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * field of the trn_cell_extension_fields_t in 'inp'.
 */
uint8_t trn_cell_extension_fields_get_field(trn_cell_extension_fields_t *inp, size_t idx);
/** As trn_cell_extension_fields_get_field, but take and return a
 * const pointer
 */
uint8_t trn_cell_extension_fields_getconst_field(const trn_cell_extension_fields_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * field of the trn_cell_extension_fields_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int trn_cell_extension_fields_set_field(trn_cell_extension_fields_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field field of the
 * trn_cell_extension_fields_t in 'inp'.
 */
int trn_cell_extension_fields_add_field(trn_cell_extension_fields_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field field of
 * 'inp'.
 */
uint8_t * trn_cell_extension_fields_getarray_field(trn_cell_extension_fields_t *inp);
/** As trn_cell_extension_fields_get_field, but take and return a
 * const pointer
 */
const uint8_t  * trn_cell_extension_fields_getconstarray_field(const trn_cell_extension_fields_t *inp);
/** Change the length of the variable-length array field field of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_cell_extension_fields_setlen_field(trn_cell_extension_fields_t *inp, size_t newlen);
/** Return a newly allocated trn_cell_extension with all elements set
 * to zero.
 */
trn_cell_extension_t *trn_cell_extension_new(void);
/** Release all storage held by the trn_cell_extension in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void trn_cell_extension_free(trn_cell_extension_t *victim);
/** Try to parse a trn_cell_extension from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated trn_cell_extension_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_cell_extension_parse(trn_cell_extension_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_cell_extension in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_cell_extension_encoded_len(const trn_cell_extension_t *obj);
/** Try to encode the trn_cell_extension from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_cell_extension_encode(uint8_t *output, size_t avail, const trn_cell_extension_t *input);
/** Check whether the internal state of the trn_cell_extension in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *trn_cell_extension_check(const trn_cell_extension_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_cell_extension_clear_errors(trn_cell_extension_t *obj);
/** Return the value of the num field of the trn_cell_extension_t in
 * 'inp'
 */
uint8_t trn_cell_extension_get_num(const trn_cell_extension_t *inp);
/** Set the value of the num field of the trn_cell_extension_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_extension_set_num(trn_cell_extension_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the fields field of
 * the trn_cell_extension_t in 'inp'.
 */
size_t trn_cell_extension_getlen_fields(const trn_cell_extension_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * fields of the trn_cell_extension_t in 'inp'.
 */
struct trn_cell_extension_fields_st * trn_cell_extension_get_fields(trn_cell_extension_t *inp, size_t idx);
/** As trn_cell_extension_get_fields, but take and return a const
 * pointer
 */
 const struct trn_cell_extension_fields_st * trn_cell_extension_getconst_fields(const trn_cell_extension_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * fields of the trn_cell_extension_t in 'inp', so that it will hold
 * the value 'elt'. Free the previous value, if any.
 */
int trn_cell_extension_set_fields(trn_cell_extension_t *inp, size_t idx, struct trn_cell_extension_fields_st * elt);
/** As trn_cell_extension_set_fields, but does not free the previous
 * value.
 */
int trn_cell_extension_set0_fields(trn_cell_extension_t *inp, size_t idx, struct trn_cell_extension_fields_st * elt);
/** Append a new element 'elt' to the dynamic array field fields of
 * the trn_cell_extension_t in 'inp'.
 */
int trn_cell_extension_add_fields(trn_cell_extension_t *inp, struct trn_cell_extension_fields_st * elt);
/** Return a pointer to the variable-length array field fields of
 * 'inp'.
 */
struct trn_cell_extension_fields_st * * trn_cell_extension_getarray_fields(trn_cell_extension_t *inp);
/** As trn_cell_extension_get_fields, but take and return a const
 * pointer
 */
const struct trn_cell_extension_fields_st *  const  * trn_cell_extension_getconstarray_fields(const trn_cell_extension_t *inp);
/** Change the length of the variable-length array field fields of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_extension_setlen_fields(trn_cell_extension_t *inp, size_t newlen);


#endif
